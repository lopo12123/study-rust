## Cargo

> **æ–°å»ºé¡¹ç›®** `cargo new project_name`

- é¡¹ç›®ç»“æ„:

```yaml
project_name
- src
  - main.rs
- .gitignore
- Cargo.toml
- Cargo.lock
```

> **æ„å»ºé¡¹ç›®** `cargo build`

- åœ¨ç›®æ ‡è·¯å¾„ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶.
- è·¯å¾„: `target/debug/project_name.exe` \(windows\)

**ä¸ºå‘å¸ƒæ„å»º** `cargo build --release`

- ç¼–è¯‘æ—¶ä¼šè¿›è¡Œä¼˜åŒ–, ä»£ç ä¼šè¿è¡Œçš„æ›´å¿«, ä½†ç¼–è¯‘æ—¶é—´æ›´é•¿.
- ä¼šåœ¨ `target/release` ä¸‹ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶, è€Œä¸æ˜¯ `target/debug`

> **æ„å»ºå¹¶è¿è¡Œé¡¹ç›®** `cargo run`

- å¦‚æœé¡¹ç›®ç¼–è¯‘è¿‡ä½†æœªä¿®æ”¹, åˆ™ä¼šç›´æ¥è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶, ä¸ä¼šé‡å¤ç¼–è¯‘.

> **æ£€æŸ¥ä»£ç ** `cargo check`

- æ£€æŸ¥ä»£ç , ç¡®ä¿èƒ½é€šè¿‡ç¼–è¯‘, ä½†ä¸ä¼šäº§ç”Ÿä»»ä½•å¯æ‰§è¡Œæ–‡ä»¶.
- `cargo check` æ¯” `cargo build` å¿«å¾—å¤š, èƒ½è¿ç»­åå¤çš„ä½¿ç”¨ `cargo check` æ£€æŸ¥ä»£ç , æé«˜æ•ˆç‡.

> é…ç½®æ–‡ä»¶ `Cargo.toml` _Tom`s Obvious, Minimal Language_

- å¸¸è§å­—æ®µå«ä¹‰:

```toml
### åŒ…é…ç½®ä¿¡æ¯
[package]

# é¡¹ç›®å
name = "study-rust"

# é¡¹ç›®ç‰ˆæœ¬
version = "0.1.0"

# ä½¿ç”¨çš„rustç‰ˆæœ¬
edition = "2021"

# è½¯ä»¶åŒ…çš„è®¸å¯è¯
license = "MIT"

# ä½œè€…
authors = ["lopo <lopo@zju.edu.cn>"]

# å¯¹åŒ…çš„ç®€è¦ä»‹ç»è¯´æ˜
description = "a brief description of this package"

# æ˜¾å¼å£°æ˜å“ªäº›æ–‡ä»¶è¢«åŒ…å«(æ’é™¤)åœ¨å†…(å¤–)
exclude = ["build/**/*.o", "doc/**/*.html"]
include = ["src/**/*", "Cargo.toml"]

# æ›´å¤šä¿¡æ¯ (url)
documentation = "..."
homepage = "..."
repository = "..."

# æŒ‡å‘READMEæ–‡ä»¶, å¹¶ä¼šè¢«ä¿å­˜åœ¨æ³¨å†Œè¡¨æ•°æ®åº“ä¸­
readme = "..."

### ä¾èµ–ä¿¡æ¯
[dependencies]

# æŒ‡å®šåŒ…çš„ç‰ˆæœ¬
hammer = "0.5.0"

# æŒ‡å®šåŒ…çš„ç‰ˆæœ¬èŒƒå›´
color = "> 0.6.0, < 0.8.0"
```

## Rust

### å˜é‡

> **å˜é‡ä¸å¯å˜æ€§**

- å£°æ˜å˜é‡ä½¿ç”¨ `let` å…³é”®å­—
- é»˜è®¤æƒ…å†µä¸‹å˜é‡æ˜¯ä¸å¯å˜(_immutable_)çš„
- å£°æ˜å˜é‡æ—¶åœ¨å˜é‡å‰åŠ ä¸Š `mut`, ä½¿å˜é‡å¯å˜

```rust
fn mut_example() {
    let immut_variable = 1;
    let mut mut_variable = 1;
    // immut_variable = 2;  // panic
    mut_variable = 2;  // correct
}
```

> **å˜é‡ä¸å¸¸é‡**

- å¸¸é‡(_constant_)åœ¨ç»‘å®šå€¼åä¹Ÿæ˜¯ä¸å¯å˜çš„, ä½†å®ƒä¸ä¸å¯å˜å˜é‡æœ‰å¾ˆå¤šåŒºåˆ«:
    - ä¸å¯ä»¥ä½¿ç”¨ `mut`, å¸¸é‡æ˜¯æ°¸è¿œä¸å¯å˜çš„
    - å£°æ˜å¸¸é‡ä½¿ç”¨ `const` å…³é”®å­—, ä»–çš„ç±»å‹å¿…é¡»è¢«æ ‡æ³¨
    - å¸¸é‡å¯ä»¥åœ¨ä»»æ„ä½œç”¨åŸŸå†…è¿›è¡Œå£°æ˜, åŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
    - å¸¸é‡åªå¯ä»¥ç»‘å®šåˆ°å¸¸é‡è¡¨è¾¾å¼, æ— æ³•ç»‘å®šåˆ°å‡½æ•°çš„è°ƒç”¨ç»“æœæˆ–åªèƒ½åœ¨è¿è¡Œæ—¶æ‰èƒ½è®¡ç®—å¾—åˆ°çš„å€¼
- åœ¨ç¨‹åºè¿è¡ŒæœŸé—´, å¸¸é‡åœ¨å…¶å£°æ˜çš„ä½œç”¨åŸŸå†…ä¸€ç›´æœ‰æ•ˆ
- å‘½åè§„èŒƒ: **Rust**é‡Œçš„å¸¸é‡ä½¿ç”¨å…¨å¤§å†™å­—æ¯, å•è¯é—´ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”. (ä¾‹: `const MAX_POINTS: u32 = 10_000;`)

```rust
fn const_example() {
    const MAX_POINTS: [i32; 2] = [0, 0];
    // const mut MAX_POINTS_MUT: [i32; 2] = [0, 0];  // error
}
```

> **é‡å½± _Shadowing_**

- å¯ä»¥ä½¿ç”¨ç›¸åŒçš„åå­—å£°æ˜æ–°çš„å˜é‡(æ–°çš„ç±»å‹ã€æ–°çš„å€¼), æ–°çš„å˜é‡ä¼šé‡å½±(`shadow`)ä¹‹å‰å£°æ˜çš„å˜é‡
- `shadow` å’ŒæŠŠå˜é‡æ ‡è®°ä¸º `mut`æ˜¯ä¸ä¸€æ ·çš„:
    - å¦‚æœä¸ä½¿ç”¨ `let` å…³é”®å­—, é‚£ä¹ˆé‡æ–°ç»™é `mut` çš„å˜é‡èµ‹å€¼ä¼šå¯¼è‡´ç¼–è¯‘æ—¶é”™è¯¯
    - è€Œä½¿ç”¨ `let` å£°æ˜åŒåæ–°å˜é‡, ä¹Ÿæ˜¯ä¸å¯å˜çš„
    - ä½¿ç”¨ `let` å£°æ˜çš„æ–°å˜é‡, å¯ä»¥ä¸ºæ–°çš„ç±»å‹/æ–°çš„å€¼

```rust
fn shadow_example() {
    let what_type: u32 = 1;  // u32
    let what_type: &str = "1";  // &str
    let what_type: bool = false;  // bool
}
```

### æ•°æ®ç±»å‹

- æ ‡é‡å’Œå¤åˆç±»å‹
- **Rust**æ˜¯é™æ€ç¼–è¯‘è¯­è¨€, åœ¨ç¼–è¯‘æ—¶å¿…é¡»çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹
    - åŸºäºä½¿ç”¨çš„å€¼, ç¼–è¯‘å™¨é€šå¸¸èƒ½å¤Ÿæ¨æ–­å‡ºå®ƒçš„å…·ä½“ç±»å‹
    - ä½†å¦‚æœå¯èƒ½çš„ç±»å‹æ¯”è¾ƒå¤š(å¦‚ `String` çš„ `parse` æ–¹æ³•), å°±å¿…é¡»æ·»åŠ ç±»å‹æ ‡æ³¨, å¦åˆ™å°±ä¼šæŠ¥ç¼–è¯‘æ—¶é”™è¯¯

> **æ ‡é‡ç±»å‹**

- ä¸€ä¸ªæ ‡é‡ç±»å‹ä»£è¡¨ä¸€ä¸ªå•ä¸ªçš„å€¼
- **Rust**æœ‰å››ä¸ªä¸»è¦çš„æ ‡é‡ç±»å‹
    - æ•´æ•°ç±»å‹
    - æµ®ç‚¹ç±»å‹
    - å¸ƒå°”ç±»å‹
    - å­—ç¬¦ç±»å‹

> > **æ•´æ•°ç±»å‹**

- æ•´æ•°ç±»å‹æ²¡æœ‰å°æ•°éƒ¨åˆ†
- æ— ç¬¦å·ä»¥ `u` å¼€å¤´
- æœ‰ç¬¦å·ä»¥ `i` å¼€å¤´
- **Rust**çš„æ•´æ•°ç±»å‹åˆ—è¡¨å¦‚ä¸‹

| length | signed | unsigned |
| --- | --- | --- |
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch | isize | usize |

- `izise` å’Œ `usize` ç±»å‹çš„ä½æ•°ç”±ç¨‹åºè¿è¡Œçš„è®¡ç®—æœºçš„æ¶æ„å†³å®š
    - å¦‚æœæ˜¯64ä½è®¡ç®—æœº, é‚£ä¹ˆå°±æ˜¯64ä½çš„
    - ä½¿ç”¨ `isize` æˆ– `usize` çš„ä¸»è¦åœºæ™¯æ˜¯å¯¹æŸç§é›†åˆè¿›è¡Œç´¢å¼•æ“ä½œ
- æ•´æ•°å­—é¢é‡
    - é™¤äº† `byte` ç±»å‹å¤–, æ‰€æœ‰çš„æ•°å€¼å­—é¢é‡éƒ½å…è®¸ä½¿ç”¨ç±»å‹åç¼€ `42u8`
    - å¦‚æœä¸æ¸…æ¥šè¯¥ä½¿ç”¨ä»€ä¹ˆç±»å‹, åˆ™å¯ä»¥ä½¿ç”¨ç›¸åº”çš„é»˜è®¤ç±»å‹
        - æ•´æ•°çš„é»˜è®¤ç±»å‹æ˜¯ `i32`

| è¿›åˆ¶ | ä¾‹å­ |
| --- | --- |
| Decimal | `10_000` |
| Hex | `0xff` |
| Octal | `0o77` |
| Binary | `0b11` |
| Byte(`u8` only) | `b'A'` |

- æ•´æ•°æº¢å‡º
    - è°ƒè¯•æ¨¡å¼ä¸‹ç¼–è¯‘, **Rust** ä¼šæ£€æŸ¥æ•´æ•°æº¢å‡º, å¦‚æœå‘ç”Ÿæ•´æ•°æº¢å‡ºåˆ™ä¼šå¯¼è‡´ `panic`
    - å‘å¸ƒæ¨¡å¼(`--release`)ä¸‹ç¼–è¯‘, **Rust** ä¸ä¼šæ£€æŸ¥å¯èƒ½å¯¼è‡´ `panic` çš„æ•´æ•°æº¢å‡º
        - å¦‚æœæº¢å‡ºå‘ç”Ÿ, åˆ™ä¼šæ‰§è¡Œ _"ç¯ç»•"_ æ“ä½œ (ä¾‹: `u8` ç±»å‹çš„ `256` å˜æˆ `0`)

> > **æµ®ç‚¹ç±»å‹**

- æµ®ç‚¹ç±»å‹å«æœ‰å°æ•°éƒ¨åˆ†
- **Rust** æœ‰ä¸¤ç§åŸºç¡€çš„æµ®ç‚¹ç±»å‹
    - `f32` 32ä½, å•ç²¾åº¦
    - `f64` 64ä½, åŒç²¾åº¦
- **Rust** çš„æµ®ç‚¹ç±»å‹ä½¿ç”¨äº† `IEEE-754` æ ‡å‡†æ¥è¡¨è¿°
- `f64` æ˜¯é»˜è®¤ç±»å‹, å› ä¸ºç°ä»£CPUä¸Š `f64` å’Œ `f32` é€Ÿåº¦å·®ä¸å¤š, ä½†ç²¾åº¦æ›´é«˜
- æ•°å€¼æ“ä½œ

```rust
fn calculate_example() {
    let sum = 5 + 10;
    let difference = 95.5 - 33.2;
    let product = 4 * 30;
    let quotient = 5.67 / 3.22;
    let remainder = 51 % 4;
}
```

> > **å¸ƒå°”ç±»å‹**

- **Rust** çš„å¸ƒå°”ç±»å‹ä¹Ÿæœ‰ä¸¤ä¸ªå€¼: `true` å’Œ `false`
- å ç”¨ä¸€ä¸ªå­—èŠ‚å¤§å°
- ç¬¦å·ä¸º `bool`

> > **å­—ç¬¦ç±»å‹**

- **Rust** ä¸­çš„ `char` ç±»å‹è¢«ç”¨æ¥æè¿°å•ä¸ªå­—ç¬¦
- å­—ç¬¦ç±»å‹çš„å­—é¢é‡ä½¿ç”¨å•å¼•å· `'`
- å ç”¨4å­—èŠ‚å¤§å°
- æ˜¯ `Unicode` æ ‡é‡å€¼, å¯ä»¥è¡¨ç¤ºæ¯” `ASCII` å¤šå¾—å¤šçš„å­—ç¬¦å†…å®¹ (æ‹¼éŸ³ã€ä¸­æ—¥éŸ©æ–‡ã€emojiè¡¨æƒ…ç­‰)
    - èŒƒå›´ä¸º `U+0000` åˆ° `U+D7FF` å’Œ `U+E000` åˆ° `U+10FFFF`
- ä½† `Unicode` ä¸­æ²¡æœ‰ _å­—ç¬¦_ çš„æ¦‚å¿µ, æ‰€ä»¥ç›´è§‰ä¸Šçš„å­—ç¬¦ä¸ **Rust** ä¸­çš„å­—ç¬¦æ¦‚å¿µå¹¶ä¸ç›¸ç¬¦

```rust
fn char_example() {
    let x = 'x';
    let y: char = 'ãŠ';
    let z = 'ğŸ˜‚';
}
```

> **å¤åˆç±»å‹**

- å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œ
- **Rust** æä¾›äº†ä¸¤ç§åŸºç¡€çš„å¤åˆç±»å‹: å…ƒç»„(`Tuple`) å’Œ æ•°ç»„(`Array`)

> > å…ƒç»„

- å…ƒç»„å¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹ä¸­
- å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„, ä¸€æ—¦å£°æ˜å°±æ— æ³•æ”¹å˜

```rust
fn tuple_example() {
    // å£°æ˜
    let tup: (i32, f64, u8) = (-500, 6.4, 1);

    // è·å–å€¼
    let (x, y, z) = tup;
    println!("{}, {}, {}", x, y, z);  // -500, 6.4, 1

    // è®¿é—®
    println!("{}, {}, {}", tup.0, tup.1, tup.2);  // -500, 6.4, 1
}
```

> > æ•°ç»„

- æ•°ç»„ä¹Ÿå¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹ä¸­
- æ•°ç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„, ä¸”å…¶ä¸­çš„æ¯ä¸ªå…ƒç´ ç±»å‹å¿…é¡»ç›¸åŒ
- æ•°ç»„çš„ç±»å‹ä»¥è¿™ç§å½¢å¼è¡¨ç¤º: `[type; length]`
- \* å¦‚æœæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå€¼éƒ½ç›¸åŒ, é‚£ä¹ˆ:
    - åœ¨ä¸­æ‹¬å·ä¸­æŒ‡å®šåˆå§‹å€¼
    - ä½¿ç”¨åˆ†å·åˆ†éš”
    - æœ€åå†™ä¸Šæ•°ç»„çš„é•¿åº¦
    - `let a = [3; 5];` ç­‰ä»·äº `let a = [3, 3, 3, 3, 3];`
- è®¿é—®æ•°ç»„å…ƒç´ : ä½¿ç”¨ç´¢å¼•è®¿é—®(ç´¢å¼•ä» `0` å¼€å§‹)
- å¦‚æœè®¿é—®çš„ç´¢å¼•è¶…å‡ºäº†æ•°ç»„çš„èŒƒå›´
    - ç¼–è¯‘å¯èƒ½ä¼šé€šè¿‡
    - è¿è¡Œä¼šæŠ¥é”™ (`panic`)
    - **Rust** ä¸å…è®¸å…¶è®¿é—®æ•°ç»„è¶Šç•Œåç›¸åº”åœ°å€çš„å†…å­˜ (ä¸ `c/c++` åŒºåˆ«)

```rust
fn array_example() {
    // å£°æ˜
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let b = [1; 5];

    // è®¿é—®
    println!("a[1]: {}", a[1]);
    println!("b[2]: {}", b[2]);

    // è¶Šç•Œ
    let names = ["name1", "name2", "name3"];
    let idx = [1, 2, 3, 4];
    println!("{}", names[4]);  // panic in compiling
    println!("{}", names[idx[3]]);  // runtime panic
}
```

### å‡½æ•°

- å£°æ˜å‡½æ•°ä½¿ç”¨ `fn` å…³é”®å­—
- é’ˆå¯¹å‡½æ•°å’Œå˜é‡å, **Rust** ä½¿ç”¨ `snake case` å‘½åè§„èŒƒ
    - æ‰€æœ‰å­—æ¯éƒ½å°å†™, å•è¯é—´ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”
- å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆ, å¯é€‰çš„ç”±ä¸€ä¸ªè¡¨è¾¾å¼ç»“æŸ
    - **è¯­å¥** æ˜¯æ‰§è¡Œä¸€ç³»åˆ—åŠ¨ä½œçš„æŒ‡ä»¤
    - **è¡¨è¾¾å¼** ä¼šè®¡ç®—äº§ç”Ÿä¸€ä¸ªå€¼
- å‡½æ•°çš„è¿”å›å€¼
    - åœ¨ `->` ç¬¦å·åé¢å£°æ˜å‡½æ•°è¿”å›å€¼çš„ç±»å‹, ä½†æ˜¯ä¸å¯ä»¥ä¸ºè¿”å›å€¼å‘½å
    - åœ¨ **Rust** ä¸­, è¿”å›å€¼å°±æ˜¯å‡½æ•°ä½“é‡Œçš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
    - è‹¥æƒ³æå‰è¿”å›, åˆ™ä½¿ç”¨ `return` å…³é”®å­—, å¹¶æŒ‡å®šä¸€ä¸ªå€¼
        - å¤§å¤šæ•°å‡½æ•°éƒ½æ˜¯é»˜è®¤ä½¿ç”¨æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼

### æ§åˆ¶æµ

- `if` è¡¨è¾¾å¼
    - `if` è¡¨è¾¾å¼å…è®¸æ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒçš„åˆ†æ”¯ä»£ç , è¿™ä¸ªæ¡ä»¶**å¿…é¡»**æ˜¯ `bool` ç±»å‹çš„
    - ä¸‰ç›®ç”¨æ³• `let a = if condition { x } else { y };`
- `loop` è¡¨è¾¾å¼
    - `loop` å…³é”®å­—åå¤æ‰§è¡Œä¸€å—ä»£ç ç›´åˆ°åœæ­¢å¾ªç¯
    - å¯ä»¥åœ¨ `loop` å¾ªç¯ä¸­ä½¿ç”¨ `break` å…³é”®å­—æ¥å‘Šè¯‰ç¨‹åºä½•æ—¶åœæ­¢å¾ªç¯
    - `breal` é€€å‡ºå¾ªç¯å¯ä»¥è¿”å›å€¼ `let a = loop { break 3; };`
- `while` æ¡ä»¶å¾ªç¯
    - æ¯æ¬¡å¾ªç¯å‰éƒ½åˆ¤æ–­ä¸€æ¬¡æ¡ä»¶
- `for` å¾ªç¯

```rust
fn for_example() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter() {
        println!("{}", element);
    }
}
```

### æ‰€æœ‰æƒ

- **Rust** çš„æ ¸å¿ƒç‰¹æ€§å°±æ˜¯æ‰€æœ‰æƒ
- æ‰€æœ‰è¯­è¨€åœ¨è¿è¡Œæ—¶éƒ½å¿…é¡»ç®¡ç†ä»–ä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼
    - æœ‰çš„è¯­è¨€æœ‰åƒåœ¾æ”¶é›†æœºåˆ¶(`Gabrage Collect, GC`), åœ¨ç¨‹åºè¿è¡Œæ—¶ä¼šä¸æ–­å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜. å¦‚: `C#`, `Java`, `JavaScript` ç­‰
    - æœ‰çš„è¯­è¨€å¿…é¡»æ˜¾å¼åœ°åˆ†é…å’Œé‡Šæ”¾å†…å­˜. å¦‚: `C`, `C++` ç­‰
    - **Rust** ä½¿ç”¨äº†ç¬¬ä¸‰ç§æ–¹å¼, é€šè¿‡ä¸€ä¸ªæ‰€æœ‰æƒç³»ç»Ÿæ¥ç®¡ç†, å…¶åŒ…å«äº†ä¸€ç»„ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™
- æ ˆ`Stack` vs å †`Heap`
    - `Stack` æŒ‰å€¼çš„æ¥å—é¡ºåºæ¥å­˜å‚¨, æŒ‰ç›¸åé¡ºåºå°†ä»–ä»¬ç§»é™¤(**LIFO**)
    - æ‰€æœ‰å­˜å‚¨åœ¨ `Stack` ä¸Šçš„æ•°æ®å¿…é¡»æ‹¥æœ‰å·²çŸ¥ä¸”å›ºå®šçš„å¤§å°
        - ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥çš„æ•°æ®æˆ–è¿è¡Œæ—¶å¤§å°å¯èƒ½å‘ç”Ÿæ”¹å˜çš„æ•°æ®éƒ½å¿…é¡»å­˜æ”¾åœ¨ `Heap` ä¸­
    - `Heap` å†…å­˜ç»„ç»‡æ€§å·®ä¸€äº›
        - å½“æŠŠæ•°æ®æ”¾å…¥ `Heap` æ—¶, ä¼šè¯·æ±‚ä¸€å®šæ•°é‡çš„ç©ºé—´
        - æ“ä½œç³»ç»Ÿåœ¨ `Heap` ä¸­æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºé—´, å°†å…¶æ ‡è®°ä¸ºåœ¨ç”¨, å¹¶è¿”å›è¯¥ç©ºé—´çš„åœ°å€
- æ‰€æœ‰æƒè§£å†³çš„é—®é¢˜
    - è·Ÿè¸ªä»£ç ä¸­å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨ `Heap` çš„å“ªäº›æ•°æ®
    - æœ€å°åŒ– `Heap` ä¸Šçš„é‡å¤æ•°æ®é‡
    - æ¸…ç† `Heap` ä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³
    - æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› : ç®¡ç† `Heap` æ•°æ®
- æ‰€æœ‰æƒè§„åˆ™
    - æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡, è¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„**æ‰€æœ‰è€…**
    - æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
    - å½“æ‰€æœ‰è€…è¶…å‡º**ä½œç”¨åŸŸ**(`scope`)æ—¶, è¯¥å€¼å°†è¢«åˆ é™¤
    - å˜é‡çš„ä½œç”¨åŸŸå°±æ˜¯ç¨‹åºä¸­ä¸€ä¸ªé¡¹ç›®çš„æœ‰æ•ˆèŒƒå›´
    - å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ä¼šè‡ªåŠ¨æ‰§è¡Œä¸€ä¸ª `drop` å‡½æ•°

> å˜é‡å’Œæ•°æ®äº¤äº’çš„æ–¹å¼

- ç§»åŠ¨(`Move`)
    - å¤šä¸ªå˜é‡å¯ä»¥ä¸åŒä¸€ä¸ªæ•°æ®ä½¿ç”¨ä¸€ç§ç‹¬ç‰¹çš„æ–¹å¼æ¥äº¤äº’
- å…‹éš†(`Clone`)
- å¤åˆ¶(`Copy`)
    - `Copy trait` å¯ä»¥ç”¨äºåƒæ•´æ•°è¿™æ ·å®Œå…¨å­˜æ”¾åœ¨ `Stack` ä¸Šçš„ç±»å‹
    - å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy` è¿™ä¸ª `trait`, é‚£ä¹ˆå¤åˆ¶ä¹‹åæ—§çš„å˜é‡ä»»ç„¶å¯ç”¨
    - å¦‚æœä¸€ä¸ªç±»å‹æˆ–è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°äº† `Drop trait`, é‚£ä¹ˆ **Rust** ä¸å…è®¸è®©å®ƒå†å»å®ç° `Copy trait`
    - ä»»ä½•ç®€å•æ ‡é‡çš„ç»„åˆç±»å‹éƒ½æ˜¯å¯ä»¥ `Copy` çš„
    - ä»»ä½•éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§èµ„æºçš„éƒ½ä¸æ˜¯å¯ `Copy` çš„
    - ä¸€äº›å…·æœ‰ `Copy trait` çš„ç±»å‹
        - æ‰€æœ‰çš„æ•´æ•°ç±»å‹, å¦‚ `u32`
        - æ‰€æœ‰çš„æµ®ç‚¹ç±»å‹, å¦‚ `f64`
        - `bool`
        - `char`
        - `Tuple` (å¦‚æœå…¶æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯ `Copy` çš„, é‚£ä¹ˆå®ƒä¹Ÿæ˜¯å¯ `Copy` çš„)

```rust
fn move_and_clone_example() {
    // ç®€å•æ ‡é‡(åœ¨æ ˆä¸Šçš„æ•°æ®), å‘ç”Ÿå¤åˆ¶
    let x = 5;
    let y = x;
    println!("x: {}, y: {}", x, y);  // x: 5, y: 5

    // åœ¨å †ä¸Šçš„æ•°æ®, æ‰€æœ‰æƒå‘ç”Ÿè½¬ç§», s2èµ‹å€¼ås1å°†å¤±æ•ˆ
    let s1 = String::new("rust");
    let s2 = s1;
    println!("s1: {}, s2: {}", s1, s2);  // panic: borrow of moved value "s1"

    // å…‹éš†
    let s3 = s1.clone();
    println!("s1: {}, s3: {}", s1, s3);  // s1: rust, s3: rust
}
```

> æ‰€æœ‰æƒä¸å‡½æ•°

- åœ¨è¯­ä¹‰ä¸Š, å°†å€¼ä¼ é€’ç»™å‡½æ•°å’Œå°†å€¼èµ‹å€¼ç»™å˜é‡æ˜¯ç±»ä¼¼çš„(å€¼ä¼šå‘ç”Ÿ**ç§»åŠ¨**æˆ–**å¤åˆ¶**)
- å‡½æ•°çš„è¿”å›å€¼åœ¨è¿‡ç¨‹ä¸­åŒæ ·ä¹Ÿä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»
- ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªç›¸åŒçš„æ¨¡å¼
    - å°†ä¸€ä¸ªå€¼èµ‹å€¼ç»™å…¶ä»–å˜é‡æ—¶å°±ä¼šå‘ç”Ÿç§»åŠ¨
    - å½“ä¸€ä¸ªåŒ…å« `Heap` çš„æ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶, å®ƒçš„å€¼å°±ä¼šè¢« `drop` å‡½æ•°æ¸…ç†(é™¤éæ•°æ®æ‰€æœ‰æƒç§»åŠ¨åˆ°äº†å¦ä¸€ä¸ªå˜é‡ä¸Š)

> å¼•ç”¨å’Œå€Ÿç”¨

- `&` ç¬¦å·è¡¨ç¤ºå¼•ç”¨: å…è®¸å¼•ç”¨æŸäº›ä¹‹ä½†ä¸è·å¾—å…¶æ‰€æœ‰æƒ
- æŠŠå¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°çš„è¡Œä¸ºå«å€Ÿç”¨
- ä¸èƒ½ä¿®æ”¹å€Ÿç”¨çš„å˜é‡, å¼•ç”¨é»˜è®¤ä¹Ÿæ˜¯ä¸å¯å˜çš„
- å¯å˜å¼•ç”¨ `&mut`
    - å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªé‡è¦é™åˆ¶: åœ¨ç‰¹å®šä½œç”¨åŸŸå†…, å¯¹æŸä¸€æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨(å¯ä»¥åœ¨ç¼–è¯‘æ—¶é˜²æ­¢æ•°æ®ç«äº‰)
    - å¦ä¸€ä¸ªé™åˆ¶: ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€(å¤š)ä¸ªä¸å¯å˜å¼•ç”¨

> åˆ‡ç‰‡

- **Rust** çš„å¦ä¸€ç§ä¸æŒæœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹
- å½¢å¼: `&Origin[start, end]`
    - å¼€å§‹ç´¢å¼•å°±æ˜¯åˆ‡ç‰‡èµ·å§‹ä½ç½®çš„ç´¢å¼•å€¼
    - ç»“æŸç´¢å¼•æ˜¯åˆ‡ç‰‡ç»“æŸä½ç½®çš„ä¸‹ä¸€ä¸ªç´¢å¼•å€¼
- è¯­æ³•ç³–
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å¤´éƒ¨: `&Origin[..end]`
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å°¾éƒ¨: `&Origin[start..]`
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å…¨éƒ¨: `&Origin[..]`
- å­—ç¬¦ä¸²åˆ‡ç‰‡
    - æ˜¯æŒ‡å‘å­—ç¬¦ä¸²ä¸­ä¸€éƒ¨åˆ†å†…å®¹çš„å¼•ç”¨
    - å­—ç¬¦ä¸²å­—é¢é‡çš„å˜é‡ç±»å‹æ˜¯ `&str`, æ˜¯ä¸€ä¸ªæŒ‡å‘äºŒè¿›åˆ¶ç¨‹åºç‰¹å®šä½ç½®çš„åˆ‡ç‰‡, æ˜¯ä¸å¯å˜å¼•ç”¨
    - æ³¨æ„
        - å­—ç¬¦ä¸²åˆ‡ç‰‡çš„èŒƒå›´ç´¢å¼•å¿…é¡»å‘ç”Ÿåœ¨æœ‰æ•ˆçš„ `UTF-8` å­—ç¬¦è¾¹ç•Œå†…
        - å¦‚æœå°è¯•ä»ä¸€ä¸ªå¤šå­—èŠ‚çš„å­—ç¬¦ä¸­åˆ›å»ºåˆ‡ç‰‡, åˆ™ä¼šå¼•å‘ `panic`

```rust
fn slice_example() {
    let string = String::from("Hello world!");
    let arr = [1, 2, 3, 4, 5];

    let str_slice = &string[1..4];  // ell
    let arr_slice = &arr[2..5];  // [3, 4, 5] 
}
```

### ç»“æ„ä½“

- `struct` ç»“æ„ä½“
    - è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹
    - ä¸ºç›¸å…³è”çš„å€¼å‘½å, æ‰“åŒ… => æœ‰æ„ä¹‰çš„ç»„åˆ
    - ä¸€æ—¦ `struct` æ˜¯å¯å˜çš„, åˆ™ç»“æ„ä½“ä¸­çš„æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯å˜çš„
- å®šä¹‰
    - ä½¿ç”¨ `struct` å…³é”®å­—, å¹¶ä¸ºæ•´ä¸ªç»“æ„ä½“å‘½å
    - åœ¨èŠ±æ‹¬å·å†…ä¸ºæ‰€æœ‰å­—æ®µ(`field`)å®šä¹‰åç§°å’Œç±»å‹
- å®ä¾‹åŒ–
    - ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šå…·ä½“å€¼
    - æ— éœ€æŒ‰å£°æ˜çš„é¡ºåºæŒ‡å®š
- è®¿é—®
    - ä½¿ç”¨ç‚¹æ ‡è®°æ³• `struct_name.field_name`
- å…¶ä»–
    - å­—æ®µç®€å†™: æ„é€ æ—¶åŒ `js`
    - æ›´æ–°: ç±»ä¼¼ `js` å¯¹è±¡è§£æ„
    - `Tuple struct`
        - å¯ä»¥å®šä¹‰ç±»ä¼¼ `tuple` çš„ `struct`, å«åš `tuple struct`
        - `tuple struct` æ•´ä½“æœ‰å, ä½†é‡Œé¢çš„å…ƒç´ æ²¡æœ‰å
        - é€‚ç”¨: æƒ³ç»™æ•´ä¸ª `tuple` èµ·å, å¹¶è®©å®ƒä¸åŒäºå…¶ä»– `tuple`, è€Œä¸”åˆä¸éœ€è¦ç»™æ¯ä¸ªå…ƒç´ èµ·å
    - `Unit-Like Struct` (æ²¡æœ‰ä»»ä½•å­—æ®µ)
        - å¯ä»¥å®šä¹‰æ²¡æœ‰ä»»ä½•å­—æ®µçš„ `struct`, å«åš `Unit-Like struct`(å› ä¸ºä¸`()`, å•å…ƒç±»å‹ç±»ä¼¼)
        - ä½¿ç”¨: åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°æŸä¸ª `trait`, ä½†åˆæ²¡æœ‰æ•°æ®éœ€è¦å­˜å‚¨

```rust
// å®šä¹‰
struct User {
    username: String,
    email: String,
    account: u64,
    active: bool,
}

fn struct_example() {
    // å®ä¾‹åŒ–
    let user = User {
        username: String::from("name"),
        email: String::from("email@example.com"),
        account: 123456789,
        active: true
    };
}

// tuple struct
struct Color(i32, i32, i32);

struct Point(i32, i32, i32);

fn tuple_struct_example() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    // black å’Œ origin æ˜¯ä¸åŒç±»å‹(ä»–ä»¬æ˜¯ä¸åŒçš„ tuple struct çš„å®ä¾‹)
}
```

> `Struct` çš„ æ–¹æ³• / å…³è”å‡½æ•°

- æ–¹æ³•å’Œå‡½æ•°ç±»ä¼¼: `fn` å…³é”®å­—ã€åç§°ã€å‚æ•°ã€è¿”å›å€¼
- æ–¹æ³•å’Œå‡½æ•°ä¸åŒä¹‹å¤„
    - æ–¹æ³•æ˜¯åœ¨ `struct`(æˆ– `enum`, `trait` å¯¹è±¡)çš„ä¸Šä¸‹æ–‡ä¸­å®šä¹‰ (åœ¨ `impl` ä¸­å®ç°)
    - ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ `self`(æˆ– `&self`, `&mut self`), è¡¨ç¤ºæ–¹æ³•è¢«è°ƒç”¨çš„ `struct` å®ä¾‹
- å¯ä»¥åœ¨ `impl` å—é‡Œå®šä¹‰ä¸æŠŠ `self` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°, ä»–ä»¬å«åšå…³è”å‡½æ•°
    - å…³è”å‡½æ•°é€šå¸¸ç”¨äºæ„é€ å™¨(ä¾‹: `String::from()`)

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}
```

### æšä¸¾ä¸æ¨¡å¼åŒ¹é…

> æšä¸¾ `enum`

```rust
// å®šä¹‰
enum IpKind {
    V4,
    V6,
}

enum IpKindValue {
    V4(u8, u8, u8, u8),
    V6(String),
}

// æ–¹æ³•
impl IpKindValue {
    fn call(&self) {
        println!("{:?}", self);
    }
}

// ä½¿ç”¨
fn ip_enum_example() {
    let ipv4 = IpKind::V4;
    let ipv6 = IpKind::V6;

    let ipv4_val = IpKindValue::V4(0, 0, 0, 0);
    let ipv6_val = IpKindValue::V6(String::from("0::0"));

    ipv6_val.call();
}

// Option æšä¸¾
// å¤„ç†å…¶ä»–è¯­è¨€çš„ null æƒ…å†µ
enum Option<T> {
    Some(T),
    None,
}
```

> æ¨¡å¼åŒ¹é…

> > `match`

- å…è®¸ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡ŒåŒ¹é…, å¹¶æ‰§è¡ŒåŒ¹é…çš„æ¨¡å¼å¯¹åº”çš„ä»£ç 
- æ¨¡å¼å¯ä»¥æ˜¯å­—é¢é‡ã€å˜é‡åã€é€šé…ç¬¦ç­‰

```rust
fn match_example() {
    let v: u8 = 3;
    match v {
        // ä¸€è¡Œè¯­å¥: å¯ä»¥ç›´æ¥å†™
        1 => println!("one"),
        // å¤šè¡Œè¯­å¥: åŒ…è£¹åœ¨å—å†…
        2 => {
            println!("two");
            println!("two");
        }
        // æ— å…³å†…å®¹: ç”¨ _ é€šé…åŒ¹é…
        _ => {
            println!("more then 2");
        }
    }
}
```

> > `if let`

- åªå…³å¿ƒä¸€ç§åŒ¹é…è€Œå¿½ç•¥å…¶ä»–åŒ¹é…çš„æƒ…å†µ
- æ›´å°‘çš„ä»£ç ã€æ›´å°‘çš„ç¼©è¿›ã€æ›´å°‘çš„æ¨¡æ¿ä»£ç 
- æ”¾å¼ƒäº†ç©·ä¸¾çš„å¯èƒ½
- å¯ä»¥æ­é… `else`

```rust
fn if_let_example() {
    let v: u8 = 2;

    if let 0 = v % 2 {
        println!("even");
    } else {
        println!("odd");
    }
}
```

### æ¨¡å—ç³»ç»Ÿ

- **Rust** çš„æ¨¡å—ç³»ç»Ÿ
    - `Package`(åŒ…): `Cargo` çš„ç‰¹æ€§, èƒ½å¤Ÿæ„å»ºã€æµ‹è¯•ã€å…±äº« `crate`
    - `Crate`(å•å…ƒåŒ…): ä¸€ä¸ªæ¨¡å—æ ‘, å¯ä»¥äº§ç”Ÿä¸€ä¸ª `library` æˆ–å¯æ‰§è¡Œæ–‡ä»¶
    - `Module`(æ¨¡å—)ã€`use`: èƒ½å¤Ÿæ§åˆ¶ä»£ç çš„ç»„ç»‡ã€ä½œç”¨åŸŸã€ç§æœ‰è·¯å¾„
    - `Path`(è·¯å¾„): ä¸º `struct`ã€`function`ã€`module`ç­‰å‘½åçš„æ–¹å¼

> `Cargo` çš„æƒ¯ä¾‹

- `src/main.rs` æ˜¯ `binary crate` çš„ `crate root`, ä¸” `crate` åä¸ `package` åç›¸åŒ
- `src/lib.rs` æ˜¯ `library crate` çš„ `crate root`, ä¸” `crate` åä¸ `package` åç›¸åŒ
- ä¸€ä¸ª `package` å¯ä»¥åŒæ—¶åŒ…å« `src/main.rs` å’Œ `src.lib.rs`
    - ä¸€ä¸ª `binary crate`, ä¸€ä¸ª `library crate`
- ä¸€ä¸ª `package` å¯ä»¥åŒ…å«å¤šä¸ª `binary crate`
    - æ–‡ä»¶æ”¾åœ¨ `src/bin`
    - æ¯ä¸ªæ–‡ä»¶éƒ½æ˜¯å•ç‹¬çš„ `binary crate`

> `Package`

- ä¸€ä¸ª `Package` åŒ…å« - **1** ä¸ª `Cargo.toml`, ä»–æè¿°äº†å¦‚ä½•æ„å»ºè¿™äº› `crate`
- åªèƒ½åŒ…å« **0-1** ä¸ª `library crate`
- å¯ä»¥åŒ…å« **ä»»æ„æ•°é‡** çš„ `binary crate`
- å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª `crate`(`binary` æˆ– `library`)

> `Crate`

- ç±»å‹: `binary` æˆ– `library`
- ä½œç”¨: å°†ç›¸å…³åŠŸèƒ½æ”¾åˆ°ä¸€ä¸ªä½œç”¨åŸŸå†…, ä¾¿äºåœ¨é¡¹ç›®é—´è¿›è¡Œå…±äº«(é˜²æ­¢å†²çª)
- `crate Root` æ˜¯æºä»£ç æ–‡ä»¶, **Rust** ç¼–è¯‘å™¨ä»è¿™é‡Œå¼€å§‹æ„å»º `crate` æ ¹çš„ `Module`

> `Module`

- åœ¨ä¸€ä¸ª `crate` å†…, å°†ä»£ç è¿›è¡Œåˆ†ç»„
- ä½¿ç”¨ `mod` å…³é”®å­—, å¯åµŒå¥—
- å¯ä»¥åŒ…å«å…¶ä»–é¡¹(`struct`, `enum`, `trait`, å¸¸é‡, å‡½æ•°ç­‰)çš„å®šä¹‰

> `Path`

- ä¸ºäº†åœ¨ **Rust** çš„æ¨¡å—ä¸­æ‰¾åˆ°æŸä¸ªæ¡ç›®, éœ€è¦ä½¿ç”¨è·¯å¾„
- è·¯å¾„çš„ä¸¤ç§å½¢å¼
    - ç»å¯¹è·¯å¾„: ä» `crate root` å¼€å§‹, ä½¿ç”¨ `crate` å æˆ–å­—é¢é‡ `crate`
    - ç›¸å¯¹è·¯å¾„: ä»å½“å‰æ¨¡å—å¼€å§‹, ä½¿ç”¨ `self`, `super` æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦
- è·¯å¾„è‡³å°‘ç”±ä¸€ä¸ªæ ‡è¯†ç¬¦ç»„æˆ, æ ‡è¯†ç¬¦ä¹‹é—´ä½¿ç”¨ `::`

> ç§æœ‰è¾¹ç•Œ `privacy boundary`

- æ¨¡å—ä¸ä»…å¯ä»¥ç»„ç»‡ä»£ç , è¿˜å¯ä»¥å®šä¹‰ç§æœ‰è¾¹ç•Œ
- å¦‚æœæƒ³æŠŠå‡½æ•° æˆ– `struct` ç­‰è®¾ä¸ºç§æœ‰, å¯ä»¥å°†å®ƒæ”¾åˆ°æŸä¸ªæ¨¡å—ä¸­
- **Rust** ä¸­çš„æ‰€æœ‰æ¡ç›®(å‡½æ•°, æ–¹æ³•, å¸¸é‡, æ¨¡å—, `struct`, `enum` ç­‰)é»˜è®¤æ˜¯ç§æœ‰çš„
- çˆ¶çº§æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®
- å­æ¨¡å—å¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
- æ¨¡å—å®šä¹‰æ—¶, å¦‚æœæ¨¡å—åé¢æ˜¯ `;` è€Œä¸æ˜¯ä»£ç å—
    - **Rust** ä¼šä»ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹
    - æ¨¡å—æ ‘çš„ç»“æ„ä¸ä¼šå˜åŒ–
- å…³é”®å­—
    - `pub` æš´éœ²å…¬å…±
    - `super` è®¿é—®çˆ¶çº§æ¨¡å—ä¸­çš„å†…å®¹, ç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„ `..`
    - `pub struct`
        - `struct` æ˜¯å…¬å…±çš„
        - `struct` çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„
    - `pub enum`
        - `enum` æ˜¯å…¬å…±çš„
        - `enum` çš„å˜ä½“é»˜è®¤ä¹Ÿæ˜¯å…¬å…±çš„
    - `use`
        - å¯ä»¥ä½¿ç”¨ `use` å…³é”®å­—å°†è·¯å¾„å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…
        - ä»éµå¾ªç§æœ‰æ€§åŸåˆ™
        - `as`: alias, like js (esm: `import * as customName from "..."`)
        - `pub use`: re-export, like js (esm: `export * from "..."`)
        - `use std::{self, fmt, cmp};`: part-use, like js (esm: `import { classA, classB } from "...""`)
        - `use std::*;`: use all, like js (esm: `import * from "..."`)

```rust
/// module_in_other_file.file
pub fn function_in_other_file() {}

/// lib.rs
// ç”¨ä¸‹è¡Œè¯­å¥å¼•å…¥å¤–éƒ¨æ–‡ä»¶çš„ module
// mod module_in_other_file;

mod outer_module {
    pub mod inner_module {
        pub fn inner_function() {}
    }

    pub struct StructExample {
        private_item: i32,
        pub public_item: i32,
    }

    pub enum EnumExample {
        DefaultToPublic,
        NoNeedOfPub
    }

    fn super_example() {
        super::path_example()
    }
}

pub fn path_example() {
    // absolute
    crate::outer_module::inner_module::inner_function();

    // relative
    outer_module::inner_module::inner_function();
}

fn use_example() {
    use outer_module::inner_module;

    inner_module::inner_function();
}
```

### å¸¸ç”¨é›†åˆ

> `Vector`

- ç±»å‹ä¸º `Vec<T>`
- ç”±æ ‡å‡†åº“æä¾›
- å¯å­˜å‚¨å¤šä¸ªå€¼
- åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„æ•°æ®
- å€¼åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾

```rust
fn vector_example() {
    // åˆ›å»º
    // let mut v: Vec<i32> = Vec::new();
    let mut v = vec![1, 2, 3];

    // æ›´æ–°
    v.push(4);
    v.push(5);

    // å¼•ç”¨
    // - ç´¢å¼•è®¿é—® (è¶Šç•Œä¼š panic)
    let third_1: &i32 = &v[2];
    // - get è®¿é—® (è¶Šç•Œåˆ™ä¸º None)
    let third_2 = match v.get(2) {
        Some(val) => val,
        None => None
    };

    // éå† - for å¾ªç¯
    // - ä¸å¯å˜å¼•ç”¨ å¾ªç¯
    for val in &v {
        print!("{}", val);  // -> 1 2 3 4 5
    }
    // - å¯å˜å¼•ç”¨ å¾ªç¯
    for val in &mut v {
        *val += 10;
        print!("{}", i);  // -> 11 12 13 14 15
    }
}
```

> `String`

- **Rust** çš„ **æ ¸å¿ƒè¯­è¨€å±‚é¢**, åªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹: å­—ç¬¦ä¸²åˆ‡ç‰‡ `&str`
    - å­—ç¬¦ä¸²åˆ‡ç‰‡: å¯¹å­˜å‚¨åœ¨å…¶ä»–åœ°æ–¹çš„ `UTF-8` ç¼–ç çš„å­—ç¬¦ä¸²çš„å¼•ç”¨
    - å­—ç¬¦ä¸²å­—é¢é‡: å­˜å‚¨åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„å­—ç¬¦ä¸²åˆ‡ç‰‡
- `String` ç±»å‹
    - æ¥è‡ª **æ ‡å‡†åº“** è€Œä¸æ˜¯æ ¸å¿ƒè¯­è¨€
    - å¯å¢é•¿ã€å¯ä¿®æ”¹ã€å¯è·å¾—æ‰€æœ‰æƒ
    - `UTF-8` ç¼–ç 
    - æ˜¯å¯¹ `Vec<u8>` çš„åŒ…è£…, `len()` æ–¹æ³• è¿”å›çš„æ˜¯ `Unicode` æ ‡é‡å€¼, è€Œéå¸¸è§„æ„ä¹‰çš„å­—ç¬¦æ•° (ä¸æ”¯æŒç´¢å¼•å½¢å¼è®¿é—®, ç”¨ç´¢å¼•æ–¹å¼è¿›è¡Œè®¿é—®ä¼šæŠ¥é”™)
- å­—èŠ‚`Bytes`ã€æ ‡é‡å€¼`Scalar Values`ã€å­—å½¢ç°‡`Grapheme Clusters`
    - éå†å­—èŠ‚ `for b in s.bytes() {}`
    - éå†`Unicode`æ ‡é‡å€¼ `for c in s.chars() {}`
    - éå†å­—å½¢ç°‡ `æ— æ ‡å‡†åº“æä¾›`

```rust
fn string_example() {
    // åˆ›å»º
    // - ä½¿ç”¨ ::new æ–¹æ³•åˆ›å»º
    let s1 = String::new();
    // - ä½¿ç”¨ to_string æ–¹æ³•
    let s2 = "hello".to_string();
    // - ä½¿ç”¨ ::from æ–¹æ³•åˆ›å»º
    let mut s3 = String::from("hello");

    // æ›´æ–°
    // - push_str æŠŠå­—ç¬¦ä¸²åˆ‡ç‰‡é™„åŠ åˆ° String
    s3.push_str(" world");
    println!("{}", s3);  // -> hello world
    // - push æŠŠå•ä¸ªå­—ç¬¦é™„åŠ åˆ° String
    s3.push('!');
    println!("{}", s3);  // -> hello world!
    // - '+' è¿ç®—ç¬¦
    // ä½¿ç”¨äº†ç±»ä¼¼ fn add(self, s: &str) -> String {...} çš„æ–¹æ³•, ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å¤±å»å…¶æ‰€æœ‰æƒ
    let name = String::from(" bye.");
    let s4 = s3 + &name;  // -> hello world! bye. (s3 å‘ç”Ÿäº†ç§»åŠ¨å·²å¤±æ•ˆ)
    // - format! å® (ç±»ä¼¼ js å­—ç¬¦ä¸²æ¨¡æ¿è¯­æ³•)
    let s5 = format!("{}-{}", s2, s4);
    println!("{}", s5);  // -> hello-hello world! bye

    // è®¿é—®
    // - éå†å­—èŠ‚ 
    for b in s5.bytes() {}
    // - éå†`Unicode`æ ‡é‡å€¼ 
    for c in s5.chars() {}
    // - éå†å­—å½¢ç°‡ æ— æ ‡å‡†åº“æä¾›

    // åˆ‡å‰²
    // å…è®¸ ä½†ä¸èƒ½è·¨è¶Šå­—ç¬¦è¾¹ç•Œ, å¦‚æœåˆ‡å‰²äº†å­—ç¬¦è¾¹ç•Œåˆ™ä¼šå¼•å‘ panic
    // - &string[start..end]
    let string_part = &s5[0..3];
}
```

> `HashMap`

- ç±»å‹ `HashMap<K, V>`
- é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨, ä¸€ä¸ªé”® `K` å¯¹åº”ä¸€ä¸ªå€¼ `V`
- é€‚ç”¨åœºæ™¯: é€šè¿‡ `K` æ¥å¯»æ‰¾æ•°æ®, è€Œä¸æ˜¯é€šè¿‡ç´¢å¼•
- æ‰€æœ‰æƒ
    - å¯¹å®ç°äº† `Copy trait` çš„ç±»å‹(å¦‚`i32`), å€¼ä¼šè¢«å¤åˆ¶åˆ° `HashMap` ä¸­
    - å¯¹æ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼, å…¶å€¼ä¼šè¢«ç§»åŠ¨, æ‰€æœ‰æƒè½¬ç§»ç»™ `HashMap`
        - å¦‚æœå°†å€¼çš„å¼•ç”¨æ’å…¥åˆ° `HashMap` ä¸­, å€¼æœ¬èº«ä¸ä¼šç§»åŠ¨
        - ä½†åœ¨ `HashMap` æœ‰æ•ˆæœŸé—´, è¢«å¼•ç”¨çš„å€¼å¿…é¡»ä¿æŒæœ‰æ•ˆ
- é»˜è®¤æƒ…å†µä¸‹, `HashMap` ä½¿ç”¨åŠ å¯†åŠŸèƒ½å¼ºå¤§çš„ `Hash` å‡½æ•°, å¯ä»¥æŠµæŠ— `Dos` æ”»å‡»
    - ä¸æ˜¯å¯ç”¨çš„æœ€å¿«çš„ `Hash` ç®—æ³•, ä½†å…·æœ‰æ›´å¥½çš„å®‰å…¨æ€§
    - å¯ä»¥æŒ‡å®šä¸åŒçš„ `hasher` æ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå‡½æ•°, `hasher` æ˜¯å®ç° `BuildHasher trait` çš„ç±»å‹

```rust
use std::collections::HashMap;

fn hashmap_example() {
    // åˆ›å»º
    // - ä½¿ç”¨ ::new æ–¹æ³•åˆ›å»º
    let mut map: HashMap<&String, i32> = HashMap::new();
    // - ä½¿ç”¨ ::collect æ–¹æ³•åˆ›å»º
    // åœ¨å…ƒç´ ç±»å‹ä¸º Tuple çš„ Vector ä¸Šä½¿ç”¨ collect æ–¹æ³•, å¯ä»¥ç»„å»ºä¸€ä¸ª HashMap
    let teams = vec![String::from("red"), String::from("blue")];
    let scores = vec![10, 50];
    let team_with_score: HashMap<_, _> = teams.iter()
        .zip(scores.iter())
        .collect();

    // æ·»åŠ æ•°æ®
    let red_team = String::from("red");
    map.insert(&red_team, 10);

    // è®¿é—®æ•°æ®
    let red_score = match map.get(&red_team) {
        Some(score) => score,
        None => None,
    };

    // éå† - for å¾ªç¯
    for (k, v) in &map {
        println!("{}: {}", k, v);
    }

    // æ›´æ–°
    // - K å·²ç»å­˜åœ¨, å¯¹åº”ä¸€ä¸ª V
    // - - æ›¿æ¢ç°æœ‰çš„ V
    map.insert(&red_team, 20);
    // - - ä¿ç•™ç°æœ‰çš„ V, å¿½ç•¥æ–°çš„ V
    map.entry(&red_team).or_insert(30);  // å·²å­˜åœ¨, å¿½ç•¥
    let blue_team = String::from("blue");
    map.entry(&blue_team).or_insert(40);  // ä¸å­˜åœ¨, æ’å…¥
    // - - åˆå¹¶ç°æœ‰çš„ V å’Œæ–°çš„ V
    let text = "a b c a c";
    let mut char_map = HashMap::new();
    for char in text.split_whitespace() {
        let count = char_map.entry(char).or_insert(0);
        *count += 1;
    }
    println!("{:#?}", char_map);  // {"a": 2, "b": 1, "c": 2}
    // - K ä¸å­˜åœ¨: å¢åŠ ä¸€ä¸ª K-V å¯¹
    let new_team = String::from("new");
    map.insert(&new_team, 100);
}
```

### é”™è¯¯å¤„ç†

`unwrap` å’Œ `expect`

- `unwrap(self)`:
    - å¦‚æœæˆåŠŸ, åˆ™ç›´æ¥è¿”å› `Result::Ok` é‡Œçš„å€¼,
    - å¦‚æœå¤±è´¥, åˆ™è°ƒç”¨ `panic!` å®ä¸­æ­¢ç¨‹åº.
- `expect(self, msg: &str)`:
    - æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²å‚æ•°(åˆ‡ç‰‡ç±»å‹), å½“ç»“æœä¸º`Result::Error`çš„æ—¶å€™è¾“å‡º.
    - å¦‚æœæˆåŠŸ, åˆ™ç›´æ¥è¿”å› `result` é‡Œçš„å€¼,
    - å¦‚æœå¤±è´¥, åˆ™è¾“å‡º`expect`çš„å…¥å‚å¹¶è°ƒç”¨ `panic!` å®ä¸­æ­¢ç¨‹åº.
- `result` çš„ç»“æ„å¦‚ä¸‹:

```rust
enum Result<T, E> {
    Ok(T),
    Error(E),
}
```