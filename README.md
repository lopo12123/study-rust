## Links

- [Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ](https://rust.bootcss.com/title-page.html)
- [crates.io](https://crates.io/)
- [Rust Async](https://rust-lang.github.io/async-book/)

## Cargo

### æ–°å»ºé¡¹ç›®

`cargo new project_name`

- é¡¹ç›®ç»“æ„:

```yaml
project_name:
  - src
    - main.rs
  - .gitignore
  - Cargo.toml
  - Cargo.lock
```

### æ„å»ºé¡¹ç›®

`cargo build`

- åœ¨ç›®æ ‡è·¯å¾„ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶.
- è·¯å¾„: `target/debug/project_name.exe` \(windows\)

(ä¸ºå‘å¸ƒæ„å»º) `cargo build --release`

- ç¼–è¯‘æ—¶ä¼šè¿›è¡Œä¼˜åŒ–, ä»£ç ä¼šè¿è¡Œçš„æ›´å¿«, ä½†ç¼–è¯‘æ—¶é—´æ›´é•¿.
- ä¼šåœ¨ `target/release` ä¸‹ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶, è€Œä¸æ˜¯ `target/debug`

### æ„å»ºå¹¶è¿è¡Œé¡¹ç›®

`cargo run`

- å¦‚æœé¡¹ç›®ç¼–è¯‘è¿‡ä½†æœªä¿®æ”¹, åˆ™ä¼šç›´æ¥è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶, ä¸ä¼šé‡å¤ç¼–è¯‘.

### æ£€æŸ¥ä»£ç 

`cargo check`

- æ£€æŸ¥ä»£ç , ç¡®ä¿èƒ½é€šè¿‡ç¼–è¯‘, ä½†ä¸ä¼šäº§ç”Ÿä»»ä½•å¯æ‰§è¡Œæ–‡ä»¶.
- `cargo check` æ¯” `cargo build` å¿«å¾—å¤š, èƒ½è¿ç»­åå¤çš„ä½¿ç”¨ `cargo check` æ£€æŸ¥ä»£ç , æé«˜æ•ˆç‡.

### é…ç½®æ–‡ä»¶

`Cargo.toml` _Tom`s Obvious, Minimal Language_

- å¸¸è§å­—æ®µå«ä¹‰:

```toml
### åŒ…é…ç½®ä¿¡æ¯
[package]

# é¡¹ç›®å
name = "study-rust"

# é¡¹ç›®ç‰ˆæœ¬
version = "0.1.0"

# ä½¿ç”¨çš„rustç‰ˆæœ¬
edition = "2021"

# è½¯ä»¶åŒ…çš„è®¸å¯è¯
license = "MIT"

# ä½œè€…
authors = ["lopo <lopo@zju.edu.cn>"]

# å¯¹åŒ…çš„ç®€è¦ä»‹ç»è¯´æ˜
description = "a brief description of this package"

# æ˜¾å¼å£°æ˜å“ªäº›æ–‡ä»¶è¢«åŒ…å«(æ’é™¤)åœ¨å†…(å¤–)
exclude = ["build/**/*.o", "doc/**/*.html"]
include = ["src/**/*", "Cargo.toml"]

# æ›´å¤šä¿¡æ¯ (url)
documentation = "..."
homepage = "..."
repository = "..."

# æŒ‡å‘READMEæ–‡ä»¶, å¹¶ä¼šè¢«ä¿å­˜åœ¨æ³¨å†Œè¡¨æ•°æ®åº“ä¸­
readme = "..."

### ä¾èµ–ä¿¡æ¯
[dependencies]

# æŒ‡å®šåŒ…çš„ç‰ˆæœ¬
hammer = "0.5.0"

# æŒ‡å®šåŒ…çš„ç‰ˆæœ¬èŒƒå›´
color = "> 0.6.0, < 0.8.0"
```

## Rust

### å˜é‡

#### å˜é‡ä¸å¯å˜æ€§

- å£°æ˜å˜é‡ä½¿ç”¨ `let` å…³é”®å­—
- é»˜è®¤æƒ…å†µä¸‹å˜é‡æ˜¯ä¸å¯å˜(_immutable_)çš„
- å£°æ˜å˜é‡æ—¶åœ¨å˜é‡å‰åŠ ä¸Š `mut`, ä½¿å˜é‡å¯å˜

```rust
fn mut_example() {
    let immut_variable = 1;
    let mut mut_variable = 1;
    // immut_variable = 2;  // panic
    mut_variable = 2;  // correct
}
```

#### å˜é‡ä¸å¸¸é‡

- å¸¸é‡(_constant_)åœ¨ç»‘å®šå€¼åä¹Ÿæ˜¯ä¸å¯å˜çš„, ä½†å®ƒä¸ä¸å¯å˜å˜é‡æœ‰å¾ˆå¤šåŒºåˆ«:
    - ä¸å¯ä»¥ä½¿ç”¨ `mut`, å¸¸é‡æ˜¯æ°¸è¿œä¸å¯å˜çš„
    - å£°æ˜å¸¸é‡ä½¿ç”¨ `const` å…³é”®å­—, ä»–çš„ç±»å‹å¿…é¡»è¢«æ ‡æ³¨
    - å¸¸é‡å¯ä»¥åœ¨ä»»æ„ä½œç”¨åŸŸå†…è¿›è¡Œå£°æ˜, åŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
    - å¸¸é‡åªå¯ä»¥ç»‘å®šåˆ°å¸¸é‡è¡¨è¾¾å¼, æ— æ³•ç»‘å®šåˆ°å‡½æ•°çš„è°ƒç”¨ç»“æœæˆ–åªèƒ½åœ¨è¿è¡Œæ—¶æ‰èƒ½è®¡ç®—å¾—åˆ°çš„å€¼
- åœ¨ç¨‹åºè¿è¡ŒæœŸé—´, å¸¸é‡åœ¨å…¶å£°æ˜çš„ä½œç”¨åŸŸå†…ä¸€ç›´æœ‰æ•ˆ
- å‘½åè§„èŒƒ: **Rust**é‡Œçš„å¸¸é‡ä½¿ç”¨å…¨å¤§å†™å­—æ¯, å•è¯é—´ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”. (ä¾‹: `const MAX_POINTS: u32 = 10_000;`)

```rust
fn const_example() {
    const MAX_POINTS: [i32; 2] = [0, 0];
    // const mut MAX_POINTS_MUT: [i32; 2] = [0, 0];  // error
}
```

#### é‡å½± (Shadowing)

- å¯ä»¥ä½¿ç”¨ç›¸åŒçš„åå­—å£°æ˜æ–°çš„å˜é‡(æ–°çš„ç±»å‹ã€æ–°çš„å€¼), æ–°çš„å˜é‡ä¼šé‡å½±(`shadow`)ä¹‹å‰å£°æ˜çš„å˜é‡
- `shadow` å’ŒæŠŠå˜é‡æ ‡è®°ä¸º `mut`æ˜¯ä¸ä¸€æ ·çš„:
    - å¦‚æœä¸ä½¿ç”¨ `let` å…³é”®å­—, é‚£ä¹ˆé‡æ–°ç»™é `mut` çš„å˜é‡èµ‹å€¼ä¼šå¯¼è‡´ç¼–è¯‘æ—¶é”™è¯¯
    - è€Œä½¿ç”¨ `let` å£°æ˜åŒåæ–°å˜é‡, ä¹Ÿæ˜¯ä¸å¯å˜çš„
    - ä½¿ç”¨ `let` å£°æ˜çš„æ–°å˜é‡, å¯ä»¥ä¸ºæ–°çš„ç±»å‹/æ–°çš„å€¼

```rust
fn shadow_example() {
    let what_type: u32 = 1;  // u32
    let what_type: &str = "1";  // &str
    let what_type: bool = false;  // bool
}
```

### æ•°æ®ç±»å‹

- æ ‡é‡å’Œå¤åˆç±»å‹
- **Rust**æ˜¯é™æ€ç¼–è¯‘è¯­è¨€, åœ¨ç¼–è¯‘æ—¶å¿…é¡»çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹
    - åŸºäºä½¿ç”¨çš„å€¼, ç¼–è¯‘å™¨é€šå¸¸èƒ½å¤Ÿæ¨æ–­å‡ºå®ƒçš„å…·ä½“ç±»å‹
    - ä½†å¦‚æœå¯èƒ½çš„ç±»å‹æ¯”è¾ƒå¤š(å¦‚ `String` çš„ `parse` æ–¹æ³•), å°±å¿…é¡»æ·»åŠ ç±»å‹æ ‡æ³¨, å¦åˆ™å°±ä¼šæŠ¥ç¼–è¯‘æ—¶é”™è¯¯

#### æ ‡é‡ç±»å‹

- ä¸€ä¸ªæ ‡é‡ç±»å‹ä»£è¡¨ä¸€ä¸ªå•ä¸ªçš„å€¼
- **Rust**æœ‰å››ä¸ªä¸»è¦çš„æ ‡é‡ç±»å‹
    - æ•´æ•°ç±»å‹
    - æµ®ç‚¹ç±»å‹
    - å¸ƒå°”ç±»å‹
    - å­—ç¬¦ç±»å‹

##### æ•´æ•°ç±»å‹

- æ•´æ•°ç±»å‹æ²¡æœ‰å°æ•°éƒ¨åˆ†
- æ— ç¬¦å·ä»¥ `u` å¼€å¤´
- æœ‰ç¬¦å·ä»¥ `i` å¼€å¤´
- **Rust**çš„æ•´æ•°ç±»å‹åˆ—è¡¨å¦‚ä¸‹

| length  | signed | unsigned |
|---------|--------|----------|
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

- `izise` å’Œ `usize` ç±»å‹çš„ä½æ•°ç”±ç¨‹åºè¿è¡Œçš„è®¡ç®—æœºçš„æ¶æ„å†³å®š
    - å¦‚æœæ˜¯64ä½è®¡ç®—æœº, é‚£ä¹ˆå°±æ˜¯64ä½çš„
    - ä½¿ç”¨ `isize` æˆ– `usize` çš„ä¸»è¦åœºæ™¯æ˜¯å¯¹æŸç§é›†åˆè¿›è¡Œç´¢å¼•æ“ä½œ
- æ•´æ•°å­—é¢é‡
    - é™¤äº† `byte` ç±»å‹å¤–, æ‰€æœ‰çš„æ•°å€¼å­—é¢é‡éƒ½å…è®¸ä½¿ç”¨ç±»å‹åç¼€ `42u8`
    - å¦‚æœä¸æ¸…æ¥šè¯¥ä½¿ç”¨ä»€ä¹ˆç±»å‹, åˆ™å¯ä»¥ä½¿ç”¨ç›¸åº”çš„é»˜è®¤ç±»å‹
        - æ•´æ•°çš„é»˜è®¤ç±»å‹æ˜¯ `i32`

| è¿›åˆ¶              | ä¾‹å­       |
|-----------------|----------|
| Decimal         | `10_000` |
| Hex             | `0xff`   |
| Octal           | `0o77`   |
| Binary          | `0b11`   |
| Byte(`u8` only) | `b'A'`   |

- æ•´æ•°æº¢å‡º
    - è°ƒè¯•æ¨¡å¼ä¸‹ç¼–è¯‘, **Rust** ä¼šæ£€æŸ¥æ•´æ•°æº¢å‡º, å¦‚æœå‘ç”Ÿæ•´æ•°æº¢å‡ºåˆ™ä¼šå¯¼è‡´ `panic`
    - å‘å¸ƒæ¨¡å¼(`--release`)ä¸‹ç¼–è¯‘, **Rust** ä¸ä¼šæ£€æŸ¥å¯èƒ½å¯¼è‡´ `panic` çš„æ•´æ•°æº¢å‡º
        - å¦‚æœæº¢å‡ºå‘ç”Ÿ, åˆ™ä¼šæ‰§è¡Œ _"ç¯ç»•"_ æ“ä½œ (ä¾‹: `u8` ç±»å‹çš„ `256` å˜æˆ `0`)

##### æµ®ç‚¹ç±»å‹

- æµ®ç‚¹ç±»å‹å«æœ‰å°æ•°éƒ¨åˆ†
- **Rust** æœ‰ä¸¤ç§åŸºç¡€çš„æµ®ç‚¹ç±»å‹
    - `f32` 32ä½, å•ç²¾åº¦
    - `f64` 64ä½, åŒç²¾åº¦
- **Rust** çš„æµ®ç‚¹ç±»å‹ä½¿ç”¨äº† `IEEE-754` æ ‡å‡†æ¥è¡¨è¿°
- `f64` æ˜¯é»˜è®¤ç±»å‹, å› ä¸ºç°ä»£CPUä¸Š `f64` å’Œ `f32` é€Ÿåº¦å·®ä¸å¤š, ä½†ç²¾åº¦æ›´é«˜
- æ•°å€¼æ“ä½œ

```rust
fn calculate_example() {
    let sum = 5 + 10;
    let difference = 95.5 - 33.2;
    let product = 4 * 30;
    let quotient = 5.67 / 3.22;
    let remainder = 51 % 4;
}
```

##### å¸ƒå°”ç±»å‹

- **Rust** çš„å¸ƒå°”ç±»å‹ä¹Ÿæœ‰ä¸¤ä¸ªå€¼: `true` å’Œ `false`
- å ç”¨ä¸€ä¸ªå­—èŠ‚å¤§å°
- ç¬¦å·ä¸º `bool`

##### å­—ç¬¦ç±»å‹

- **Rust** ä¸­çš„ `char` ç±»å‹è¢«ç”¨æ¥æè¿°å•ä¸ªå­—ç¬¦
- å­—ç¬¦ç±»å‹çš„å­—é¢é‡ä½¿ç”¨å•å¼•å· `'`
- å ç”¨4å­—èŠ‚å¤§å°
- æ˜¯ `Unicode` æ ‡é‡å€¼, å¯ä»¥è¡¨ç¤ºæ¯” `ASCII` å¤šå¾—å¤šçš„å­—ç¬¦å†…å®¹ (æ‹¼éŸ³ã€ä¸­æ—¥éŸ©æ–‡ã€emojiè¡¨æƒ…ç­‰)
    - èŒƒå›´ä¸º `U+0000` åˆ° `U+D7FF` å’Œ `U+E000` åˆ° `U+10FFFF`
- ä½† `Unicode` ä¸­æ²¡æœ‰ _å­—ç¬¦_ çš„æ¦‚å¿µ, æ‰€ä»¥ç›´è§‰ä¸Šçš„å­—ç¬¦ä¸ **Rust** ä¸­çš„å­—ç¬¦æ¦‚å¿µå¹¶ä¸ç›¸ç¬¦

```rust
fn char_example() {
    let x = 'x';
    let y: char = 'ãŠ';
    let z = 'ğŸ˜‚';
}
```

#### å¤åˆç±»å‹

- å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œ
- **Rust** æä¾›äº†ä¸¤ç§åŸºç¡€çš„å¤åˆç±»å‹: å…ƒç»„(`Tuple`) å’Œ æ•°ç»„(`Array`)

##### å…ƒç»„

- å…ƒç»„å¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹ä¸­
- å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„, ä¸€æ—¦å£°æ˜å°±æ— æ³•æ”¹å˜

```rust
fn tuple_example() {
    // å£°æ˜
    let tup: (i32, f64, u8) = (-500, 6.4, 1);

    // è·å–å€¼
    let (x, y, z) = tup;
    println!("{}, {}, {}", x, y, z);  // -500, 6.4, 1

    // è®¿é—®
    println!("{}, {}, {}", tup.0, tup.1, tup.2);  // -500, 6.4, 1
}
```

##### æ•°ç»„

- æ•°ç»„ä¹Ÿå¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹ä¸­
- æ•°ç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„, ä¸”å…¶ä¸­çš„æ¯ä¸ªå…ƒç´ ç±»å‹å¿…é¡»ç›¸åŒ
- æ•°ç»„çš„ç±»å‹ä»¥è¿™ç§å½¢å¼è¡¨ç¤º: `[type; length]`
- \* å¦‚æœæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå€¼éƒ½ç›¸åŒ, é‚£ä¹ˆ:
    - åœ¨ä¸­æ‹¬å·ä¸­æŒ‡å®šåˆå§‹å€¼
    - ä½¿ç”¨åˆ†å·åˆ†éš”
    - æœ€åå†™ä¸Šæ•°ç»„çš„é•¿åº¦
    - `let a = [3; 5];` ç­‰ä»·äº `let a = [3, 3, 3, 3, 3];`
- è®¿é—®æ•°ç»„å…ƒç´ : ä½¿ç”¨ç´¢å¼•è®¿é—®(ç´¢å¼•ä» `0` å¼€å§‹)
- å¦‚æœè®¿é—®çš„ç´¢å¼•è¶…å‡ºäº†æ•°ç»„çš„èŒƒå›´
    - ç¼–è¯‘å¯èƒ½ä¼šé€šè¿‡
    - è¿è¡Œä¼šæŠ¥é”™ (`panic`)
    - **Rust** ä¸å…è®¸å…¶è®¿é—®æ•°ç»„è¶Šç•Œåç›¸åº”åœ°å€çš„å†…å­˜ (ä¸ `c/c++` åŒºåˆ«)

```rust
fn array_example() {
    // å£°æ˜
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let b = [1; 5];

    // è®¿é—®
    println!("a[1]: {}", a[1]);
    println!("b[2]: {}", b[2]);

    // è¶Šç•Œ
    let names = ["name1", "name2", "name3"];
    let idx = [1, 2, 3, 4];
    println!("{}", names[4]);  // panic in compiling
    println!("{}", names[idx[3]]);  // runtime panic
}
```

### å‡½æ•°

- å£°æ˜å‡½æ•°ä½¿ç”¨ `fn` å…³é”®å­—
- é’ˆå¯¹å‡½æ•°å’Œå˜é‡å, **Rust** ä½¿ç”¨ `snake case` å‘½åè§„èŒƒ
    - æ‰€æœ‰å­—æ¯éƒ½å°å†™, å•è¯é—´ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”
- å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆ, å¯é€‰çš„ç”±ä¸€ä¸ªè¡¨è¾¾å¼ç»“æŸ
    - **è¯­å¥** æ˜¯æ‰§è¡Œä¸€ç³»åˆ—åŠ¨ä½œçš„æŒ‡ä»¤
    - **è¡¨è¾¾å¼** ä¼šè®¡ç®—äº§ç”Ÿä¸€ä¸ªå€¼
- å‡½æ•°çš„è¿”å›å€¼
    - åœ¨ `->` ç¬¦å·åé¢å£°æ˜å‡½æ•°è¿”å›å€¼çš„ç±»å‹, ä½†æ˜¯ä¸å¯ä»¥ä¸ºè¿”å›å€¼å‘½å
    - åœ¨ **Rust** ä¸­, è¿”å›å€¼å°±æ˜¯å‡½æ•°ä½“é‡Œçš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
    - è‹¥æƒ³æå‰è¿”å›, åˆ™ä½¿ç”¨ `return` å…³é”®å­—, å¹¶æŒ‡å®šä¸€ä¸ªå€¼
        - å¤§å¤šæ•°å‡½æ•°éƒ½æ˜¯é»˜è®¤ä½¿ç”¨æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼

### æ§åˆ¶æµ

- `if` è¡¨è¾¾å¼
    - `if` è¡¨è¾¾å¼å…è®¸æ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒçš„åˆ†æ”¯ä»£ç , è¿™ä¸ªæ¡ä»¶**å¿…é¡»**æ˜¯ `bool` ç±»å‹çš„
    - ä¸‰ç›®ç”¨æ³• `let a = if condition { x } else { y };`
- `loop` è¡¨è¾¾å¼
    - `loop` å…³é”®å­—åå¤æ‰§è¡Œä¸€å—ä»£ç ç›´åˆ°åœæ­¢å¾ªç¯
    - å¯ä»¥åœ¨ `loop` å¾ªç¯ä¸­ä½¿ç”¨ `break` å…³é”®å­—æ¥å‘Šè¯‰ç¨‹åºä½•æ—¶åœæ­¢å¾ªç¯
    - `breal` é€€å‡ºå¾ªç¯å¯ä»¥è¿”å›å€¼ `let a = loop { break 3; };`
- `while` æ¡ä»¶å¾ªç¯
    - æ¯æ¬¡å¾ªç¯å‰éƒ½åˆ¤æ–­ä¸€æ¬¡æ¡ä»¶
- `for` å¾ªç¯

```rust
fn for_example() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter() {
        println!("{}", element);
    }
}
```

### æ‰€æœ‰æƒ

- **Rust** çš„æ ¸å¿ƒç‰¹æ€§å°±æ˜¯æ‰€æœ‰æƒ
- æ‰€æœ‰è¯­è¨€åœ¨è¿è¡Œæ—¶éƒ½å¿…é¡»ç®¡ç†ä»–ä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼
    - æœ‰çš„è¯­è¨€æœ‰åƒåœ¾æ”¶é›†æœºåˆ¶(`Gabrage Collect, GC`), åœ¨ç¨‹åºè¿è¡Œæ—¶ä¼šä¸æ–­å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜.
      å¦‚: `C#`, `Java`, `JavaScript` ç­‰
    - æœ‰çš„è¯­è¨€å¿…é¡»æ˜¾å¼åœ°åˆ†é…å’Œé‡Šæ”¾å†…å­˜. å¦‚: `C`, `C++` ç­‰
    - **Rust** ä½¿ç”¨äº†ç¬¬ä¸‰ç§æ–¹å¼, é€šè¿‡ä¸€ä¸ªæ‰€æœ‰æƒç³»ç»Ÿæ¥ç®¡ç†, å…¶åŒ…å«äº†ä¸€ç»„ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™
- æ ˆ`Stack` vs å †`Heap`
    - `Stack` æŒ‰å€¼çš„æ¥å—é¡ºåºæ¥å­˜å‚¨, æŒ‰ç›¸åé¡ºåºå°†ä»–ä»¬ç§»é™¤(**LIFO**)
    - æ‰€æœ‰å­˜å‚¨åœ¨ `Stack` ä¸Šçš„æ•°æ®å¿…é¡»æ‹¥æœ‰å·²çŸ¥ä¸”å›ºå®šçš„å¤§å°
        - ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥çš„æ•°æ®æˆ–è¿è¡Œæ—¶å¤§å°å¯èƒ½å‘ç”Ÿæ”¹å˜çš„æ•°æ®éƒ½å¿…é¡»å­˜æ”¾åœ¨ `Heap` ä¸­
    - `Heap` å†…å­˜ç»„ç»‡æ€§å·®ä¸€äº›
        - å½“æŠŠæ•°æ®æ”¾å…¥ `Heap` æ—¶, ä¼šè¯·æ±‚ä¸€å®šæ•°é‡çš„ç©ºé—´
        - æ“ä½œç³»ç»Ÿåœ¨ `Heap` ä¸­æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºé—´, å°†å…¶æ ‡è®°ä¸ºåœ¨ç”¨, å¹¶è¿”å›è¯¥ç©ºé—´çš„åœ°å€
- æ‰€æœ‰æƒè§£å†³çš„é—®é¢˜
    - è·Ÿè¸ªä»£ç ä¸­å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨ `Heap` çš„å“ªäº›æ•°æ®
    - æœ€å°åŒ– `Heap` ä¸Šçš„é‡å¤æ•°æ®é‡
    - æ¸…ç† `Heap` ä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³
    - æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› : ç®¡ç† `Heap` æ•°æ®
- æ‰€æœ‰æƒè§„åˆ™
    - æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡, è¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„**æ‰€æœ‰è€…**
    - æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
    - å½“æ‰€æœ‰è€…è¶…å‡º**ä½œç”¨åŸŸ**(`scope`)æ—¶, è¯¥å€¼å°†è¢«åˆ é™¤
    - å˜é‡çš„ä½œç”¨åŸŸå°±æ˜¯ç¨‹åºä¸­ä¸€ä¸ªé¡¹ç›®çš„æœ‰æ•ˆèŒƒå›´
    - å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ä¼šè‡ªåŠ¨æ‰§è¡Œä¸€ä¸ª `drop` å‡½æ•°

#### å˜é‡å’Œæ•°æ®äº¤äº’çš„æ–¹å¼

- ç§»åŠ¨(`Move`)
    - å¤šä¸ªå˜é‡å¯ä»¥ä¸åŒä¸€ä¸ªæ•°æ®ä½¿ç”¨ä¸€ç§ç‹¬ç‰¹çš„æ–¹å¼æ¥äº¤äº’
- å…‹éš†(`Clone`)
- å¤åˆ¶(`Copy`)
    - `Copy trait` å¯ä»¥ç”¨äºåƒæ•´æ•°è¿™æ ·å®Œå…¨å­˜æ”¾åœ¨ `Stack` ä¸Šçš„ç±»å‹
    - å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy` è¿™ä¸ª `trait`, é‚£ä¹ˆå¤åˆ¶ä¹‹åæ—§çš„å˜é‡ä»»ç„¶å¯ç”¨
    - å¦‚æœä¸€ä¸ªç±»å‹æˆ–è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°äº† `Drop trait`, é‚£ä¹ˆ **Rust** ä¸å…è®¸è®©å®ƒå†å»å®ç° `Copy trait`
    - ä»»ä½•ç®€å•æ ‡é‡çš„ç»„åˆç±»å‹éƒ½æ˜¯å¯ä»¥ `Copy` çš„
    - ä»»ä½•éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§èµ„æºçš„éƒ½ä¸æ˜¯å¯ `Copy` çš„
    - ä¸€äº›å…·æœ‰ `Copy trait` çš„ç±»å‹
        - æ‰€æœ‰çš„æ•´æ•°ç±»å‹, å¦‚ `u32`
        - æ‰€æœ‰çš„æµ®ç‚¹ç±»å‹, å¦‚ `f64`
        - `bool`
        - `char`
        - `Tuple` (å¦‚æœå…¶æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯ `Copy` çš„, é‚£ä¹ˆå®ƒä¹Ÿæ˜¯å¯ `Copy` çš„)

```rust
fn move_and_clone_example() {
    // ç®€å•æ ‡é‡(åœ¨æ ˆä¸Šçš„æ•°æ®), å‘ç”Ÿå¤åˆ¶
    let x = 5;
    let y = x;
    println!("x: {}, y: {}", x, y);  // x: 5, y: 5

    // åœ¨å †ä¸Šçš„æ•°æ®, æ‰€æœ‰æƒå‘ç”Ÿè½¬ç§», s2èµ‹å€¼ås1å°†å¤±æ•ˆ
    let s1 = String::from("rust");
    let s2 = s1;
    println!("s1: {}, s2: {}", s1, s2);  // panic: borrow of moved value "s1"

    // å…‹éš†
    let s3 = s1.clone();
    println!("s1: {}, s3: {}", s1, s3);  // s1: rust, s3: rust
}
```

#### æ‰€æœ‰æƒä¸å‡½æ•°

- åœ¨è¯­ä¹‰ä¸Š, å°†å€¼ä¼ é€’ç»™å‡½æ•°å’Œå°†å€¼èµ‹å€¼ç»™å˜é‡æ˜¯ç±»ä¼¼çš„(å€¼ä¼šå‘ç”Ÿ**ç§»åŠ¨**æˆ–**å¤åˆ¶**)
- å‡½æ•°çš„è¿”å›å€¼åœ¨è¿‡ç¨‹ä¸­åŒæ ·ä¹Ÿä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»
- ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªç›¸åŒçš„æ¨¡å¼
    - å°†ä¸€ä¸ªå€¼èµ‹å€¼ç»™å…¶ä»–å˜é‡æ—¶å°±ä¼šå‘ç”Ÿç§»åŠ¨
    - å½“ä¸€ä¸ªåŒ…å« `Heap` çš„æ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶, å®ƒçš„å€¼å°±ä¼šè¢« `drop` å‡½æ•°æ¸…ç†(é™¤éæ•°æ®æ‰€æœ‰æƒç§»åŠ¨åˆ°äº†å¦ä¸€ä¸ªå˜é‡ä¸Š)

#### å¼•ç”¨å’Œå€Ÿç”¨

- `&` ç¬¦å·è¡¨ç¤ºå¼•ç”¨: å…è®¸å¼•ç”¨æŸäº›ä¹‹ä½†ä¸è·å¾—å…¶æ‰€æœ‰æƒ
- æŠŠå¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°çš„è¡Œä¸ºå«å€Ÿç”¨
- ä¸èƒ½ä¿®æ”¹å€Ÿç”¨çš„å˜é‡, å¼•ç”¨é»˜è®¤ä¹Ÿæ˜¯ä¸å¯å˜çš„
- å¯å˜å¼•ç”¨ `&mut`
    - å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªé‡è¦é™åˆ¶: åœ¨ç‰¹å®šä½œç”¨åŸŸå†…, å¯¹æŸä¸€æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨(å¯ä»¥åœ¨ç¼–è¯‘æ—¶é˜²æ­¢æ•°æ®ç«äº‰)
    - å¦ä¸€ä¸ªé™åˆ¶: ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€(å¤š)ä¸ªä¸å¯å˜å¼•ç”¨

#### åˆ‡ç‰‡

- **Rust** çš„å¦ä¸€ç§ä¸æŒæœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹
- å½¢å¼: `&Origin[start, end]`
    - å¼€å§‹ç´¢å¼•å°±æ˜¯åˆ‡ç‰‡èµ·å§‹ä½ç½®çš„ç´¢å¼•å€¼
    - ç»“æŸç´¢å¼•æ˜¯åˆ‡ç‰‡ç»“æŸä½ç½®çš„ä¸‹ä¸€ä¸ªç´¢å¼•å€¼
- è¯­æ³•ç³–
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å¤´éƒ¨: `&Origin[..end]`
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å°¾éƒ¨: `&Origin[start..]`
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å…¨éƒ¨: `&Origin[..]`
- å­—ç¬¦ä¸²åˆ‡ç‰‡
    - æ˜¯æŒ‡å‘å­—ç¬¦ä¸²ä¸­ä¸€éƒ¨åˆ†å†…å®¹çš„å¼•ç”¨
    - å­—ç¬¦ä¸²å­—é¢é‡çš„å˜é‡ç±»å‹æ˜¯ `&str`, æ˜¯ä¸€ä¸ªæŒ‡å‘äºŒè¿›åˆ¶ç¨‹åºç‰¹å®šä½ç½®çš„åˆ‡ç‰‡, æ˜¯ä¸å¯å˜å¼•ç”¨
    - æ³¨æ„
        - å­—ç¬¦ä¸²åˆ‡ç‰‡çš„èŒƒå›´ç´¢å¼•å¿…é¡»å‘ç”Ÿåœ¨æœ‰æ•ˆçš„ `UTF-8` å­—ç¬¦è¾¹ç•Œå†…
        - å¦‚æœå°è¯•ä»ä¸€ä¸ªå¤šå­—èŠ‚çš„å­—ç¬¦ä¸­åˆ›å»ºåˆ‡ç‰‡, åˆ™ä¼šå¼•å‘ `panic`

```rust
fn slice_example() {
    let string = String::from("Hello world!");
    let arr = [1, 2, 3, 4, 5];

    let str_slice = &string[1..4];  // ell
    let arr_slice = &arr[2..5];  // [3, 4, 5] 
}
```

### ç»“æ„ä½“

- `struct` ç»“æ„ä½“
    - è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹
    - ä¸ºç›¸å…³è”çš„å€¼å‘½å, æ‰“åŒ… => æœ‰æ„ä¹‰çš„ç»„åˆ
    - ä¸€æ—¦ `struct` æ˜¯å¯å˜çš„, åˆ™ç»“æ„ä½“ä¸­çš„æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯å˜çš„
- å®šä¹‰
    - ä½¿ç”¨ `struct` å…³é”®å­—, å¹¶ä¸ºæ•´ä¸ªç»“æ„ä½“å‘½å
    - åœ¨èŠ±æ‹¬å·å†…ä¸ºæ‰€æœ‰å­—æ®µ(`field`)å®šä¹‰åç§°å’Œç±»å‹
- å®ä¾‹åŒ–
    - ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šå…·ä½“å€¼
    - æ— éœ€æŒ‰å£°æ˜çš„é¡ºåºæŒ‡å®š
- è®¿é—®
    - ä½¿ç”¨ç‚¹æ ‡è®°æ³• `struct_name.field_name`
- å…¶ä»–
    - å­—æ®µç®€å†™: æ„é€ æ—¶åŒ `js`
    - æ›´æ–°: ç±»ä¼¼ `js` å¯¹è±¡è§£æ„
    - `Tuple struct`
        - å¯ä»¥å®šä¹‰ç±»ä¼¼ `tuple` çš„ `struct`, å«åš `tuple struct`
        - `tuple struct` æ•´ä½“æœ‰å, ä½†é‡Œé¢çš„å…ƒç´ æ²¡æœ‰å
        - é€‚ç”¨: æƒ³ç»™æ•´ä¸ª `tuple` èµ·å, å¹¶è®©å®ƒä¸åŒäºå…¶ä»– `tuple`, è€Œä¸”åˆä¸éœ€è¦ç»™æ¯ä¸ªå…ƒç´ èµ·å
    - `Unit-Like Struct` (æ²¡æœ‰ä»»ä½•å­—æ®µ)
        - å¯ä»¥å®šä¹‰æ²¡æœ‰ä»»ä½•å­—æ®µçš„ `struct`, å«åš `Unit-Like struct`(å› ä¸ºä¸`()`, å•å…ƒç±»å‹ç±»ä¼¼)
        - ä½¿ç”¨: åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°æŸä¸ª `trait`, ä½†åˆæ²¡æœ‰æ•°æ®éœ€è¦å­˜å‚¨

```rust
// å®šä¹‰
struct User {
    username: String,
    email: String,
    account: u64,
    active: bool,
}

fn struct_example() {
    // å®ä¾‹åŒ–
    let user = User {
        username: String::from("name"),
        email: String::from("email@example.com"),
        account: 123456789,
        active: true
    };
}

// tuple struct
struct Color(i32, i32, i32);

struct Point(i32, i32, i32);

fn tuple_struct_example() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    // black å’Œ origin æ˜¯ä¸åŒç±»å‹(ä»–ä»¬æ˜¯ä¸åŒçš„ tuple struct çš„å®ä¾‹)
}
```

#### Struct çš„ æ–¹æ³• / å…³è”å‡½æ•°

- æ–¹æ³•å’Œå‡½æ•°ç±»ä¼¼: `fn` å…³é”®å­—ã€åç§°ã€å‚æ•°ã€è¿”å›å€¼
- æ–¹æ³•å’Œå‡½æ•°ä¸åŒä¹‹å¤„
    - æ–¹æ³•æ˜¯åœ¨ `struct`(æˆ– `enum`, `trait` å¯¹è±¡)çš„ä¸Šä¸‹æ–‡ä¸­å®šä¹‰ (åœ¨ `impl` ä¸­å®ç°)
    - ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ `self`(æˆ– `&self`, `&mut self`), è¡¨ç¤ºæ–¹æ³•è¢«è°ƒç”¨çš„ `struct` å®ä¾‹
- å¯ä»¥åœ¨ `impl` å—é‡Œå®šä¹‰ä¸æŠŠ `self` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°, ä»–ä»¬å«åšå…³è”å‡½æ•°
    - å…³è”å‡½æ•°é€šå¸¸ç”¨äºæ„é€ å™¨(ä¾‹: `String::from()`)

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}
```

### æšä¸¾ä¸æ¨¡å¼åŒ¹é…

#### æšä¸¾ enum

```rust
// å®šä¹‰
enum IpKind {
    V4,
    V6,
}

enum IpKindValue {
    V4(u8, u8, u8, u8),
    V6(String),
}

// æ–¹æ³•
impl IpKindValue {
    fn call(&self) {
        println!("{:?}", self);
    }
}

// ä½¿ç”¨
fn ip_enum_example() {
    let ipv4 = IpKind::V4;
    let ipv6 = IpKind::V6;

    let ipv4_val = IpKindValue::V4(0, 0, 0, 0);
    let ipv6_val = IpKindValue::V6(String::from("0::0"));

    ipv6_val.call();
}

// Option æšä¸¾
// å¤„ç†å…¶ä»–è¯­è¨€çš„ null æƒ…å†µ
enum Option<T> {
    Some(T),
    None,
}
```

#### æ¨¡å¼åŒ¹é…

##### match

- å…è®¸ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡ŒåŒ¹é…, å¹¶æ‰§è¡ŒåŒ¹é…çš„æ¨¡å¼å¯¹åº”çš„ä»£ç 
- æ¨¡å¼å¯ä»¥æ˜¯å­—é¢é‡ã€å˜é‡åã€é€šé…ç¬¦ç­‰

```rust
fn match_example() {
    let v: u8 = 3;
    match v {
        // ä¸€è¡Œè¯­å¥: å¯ä»¥ç›´æ¥å†™
        1 => println!("one"),
        // å¤šè¡Œè¯­å¥: åŒ…è£¹åœ¨å—å†…
        2 => {
            println!("two");
            println!("two");
        }
        // æ— å…³å†…å®¹: ç”¨ _ é€šé…åŒ¹é…
        _ => {
            println!("more then 2");
        }
    }
}
```

##### if let

- åªå…³å¿ƒä¸€ç§åŒ¹é…è€Œå¿½ç•¥å…¶ä»–åŒ¹é…çš„æƒ…å†µ
- æ›´å°‘çš„ä»£ç ã€æ›´å°‘çš„ç¼©è¿›ã€æ›´å°‘çš„æ¨¡æ¿ä»£ç 
- æ”¾å¼ƒäº†ç©·ä¸¾çš„å¯èƒ½
- å¯ä»¥æ­é… `else`

```rust
fn if_let_example() {
    let v: u8 = 2;

    if let 0 = v % 2 {
        println!("even");
    } else {
        println!("odd");
    }
}
```

### æ¨¡å—ç³»ç»Ÿ

- **Rust** çš„æ¨¡å—ç³»ç»Ÿ
    - `Package`(åŒ…): `Cargo` çš„ç‰¹æ€§, èƒ½å¤Ÿæ„å»ºã€æµ‹è¯•ã€å…±äº« `crate`
    - `Crate`(å•å…ƒåŒ…): ä¸€ä¸ªæ¨¡å—æ ‘, å¯ä»¥äº§ç”Ÿä¸€ä¸ª `library` æˆ–å¯æ‰§è¡Œæ–‡ä»¶
    - `Module`(æ¨¡å—)ã€`use`: èƒ½å¤Ÿæ§åˆ¶ä»£ç çš„ç»„ç»‡ã€ä½œç”¨åŸŸã€ç§æœ‰è·¯å¾„
    - `Path`(è·¯å¾„): ä¸º `struct`ã€`function`ã€`module`ç­‰å‘½åçš„æ–¹å¼

#### Cargo çš„æƒ¯ä¾‹

- `src/main.rs` æ˜¯ `binary crate` çš„ `crate root`, ä¸” `crate` åä¸ `package` åç›¸åŒ
- `src/lib.rs` æ˜¯ `library crate` çš„ `crate root`, ä¸” `crate` åä¸ `package` åç›¸åŒ
- ä¸€ä¸ª `package` å¯ä»¥åŒæ—¶åŒ…å« `src/main.rs` å’Œ `src.lib.rs`
    - ä¸€ä¸ª `binary crate`, ä¸€ä¸ª `library crate`
- ä¸€ä¸ª `package` å¯ä»¥åŒ…å«å¤šä¸ª `binary crate`
    - æ–‡ä»¶æ”¾åœ¨ `src/bin`
    - æ¯ä¸ªæ–‡ä»¶éƒ½æ˜¯å•ç‹¬çš„ `binary crate`

#### Package

- ä¸€ä¸ª `Package` åŒ…å« - **1** ä¸ª `Cargo.toml`, ä»–æè¿°äº†å¦‚ä½•æ„å»ºè¿™äº› `crate`
- åªèƒ½åŒ…å« **0-1** ä¸ª `library crate`
- å¯ä»¥åŒ…å« **ä»»æ„æ•°é‡** çš„ `binary crate`
- å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª `crate`(`binary` æˆ– `library`)

#### Crate

- ç±»å‹: `binary` æˆ– `library`
- ä½œç”¨: å°†ç›¸å…³åŠŸèƒ½æ”¾åˆ°ä¸€ä¸ªä½œç”¨åŸŸå†…, ä¾¿äºåœ¨é¡¹ç›®é—´è¿›è¡Œå…±äº«(é˜²æ­¢å†²çª)
- `crate Root` æ˜¯æºä»£ç æ–‡ä»¶, **Rust** ç¼–è¯‘å™¨ä»è¿™é‡Œå¼€å§‹æ„å»º `crate` æ ¹çš„ `Module`

#### Module

- åœ¨ä¸€ä¸ª `crate` å†…, å°†ä»£ç è¿›è¡Œåˆ†ç»„
- ä½¿ç”¨ `mod` å…³é”®å­—, å¯åµŒå¥—
- å¯ä»¥åŒ…å«å…¶ä»–é¡¹(`struct`, `enum`, `trait`, å¸¸é‡, å‡½æ•°ç­‰)çš„å®šä¹‰

#### Path

- ä¸ºäº†åœ¨ **Rust** çš„æ¨¡å—ä¸­æ‰¾åˆ°æŸä¸ªæ¡ç›®, éœ€è¦ä½¿ç”¨è·¯å¾„
- è·¯å¾„çš„ä¸¤ç§å½¢å¼
    - ç»å¯¹è·¯å¾„: ä» `crate root` å¼€å§‹, ä½¿ç”¨ `crate` å æˆ–å­—é¢é‡ `crate`
    - ç›¸å¯¹è·¯å¾„: ä»å½“å‰æ¨¡å—å¼€å§‹, ä½¿ç”¨ `self`, `super` æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦
- è·¯å¾„è‡³å°‘ç”±ä¸€ä¸ªæ ‡è¯†ç¬¦ç»„æˆ, æ ‡è¯†ç¬¦ä¹‹é—´ä½¿ç”¨ `::`

#### ç§æœ‰è¾¹ç•Œ (privacy boundary)

- æ¨¡å—ä¸ä»…å¯ä»¥ç»„ç»‡ä»£ç , è¿˜å¯ä»¥å®šä¹‰ç§æœ‰è¾¹ç•Œ
- å¦‚æœæƒ³æŠŠå‡½æ•° æˆ– `struct` ç­‰è®¾ä¸ºç§æœ‰, å¯ä»¥å°†å®ƒæ”¾åˆ°æŸä¸ªæ¨¡å—ä¸­
- **Rust** ä¸­çš„æ‰€æœ‰æ¡ç›®(å‡½æ•°, æ–¹æ³•, å¸¸é‡, æ¨¡å—, `struct`, `enum` ç­‰)é»˜è®¤æ˜¯ç§æœ‰çš„
- çˆ¶çº§æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®
- å­æ¨¡å—å¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
- æ¨¡å—å®šä¹‰æ—¶, å¦‚æœæ¨¡å—åé¢æ˜¯ `;` è€Œä¸æ˜¯ä»£ç å—
    - **Rust** ä¼šä»ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹
    - æ¨¡å—æ ‘çš„ç»“æ„ä¸ä¼šå˜åŒ–
- å…³é”®å­—
    - `pub` æš´éœ²å…¬å…±
    - `super` è®¿é—®çˆ¶çº§æ¨¡å—ä¸­çš„å†…å®¹, ç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„ `..`
    - `pub struct`
        - `struct` æ˜¯å…¬å…±çš„
        - `struct` çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„
    - `pub enum`
        - `enum` æ˜¯å…¬å…±çš„
        - `enum` çš„å˜ä½“é»˜è®¤ä¹Ÿæ˜¯å…¬å…±çš„
    - `use`
        - å¯ä»¥ä½¿ç”¨ `use` å…³é”®å­—å°†è·¯å¾„å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…
        - ä»éµå¾ªç§æœ‰æ€§åŸåˆ™
        - `as`: alias, like js (esm: `import * as customName from "..."`)
        - `pub use`: re-export, like js (esm: `export * from "..."`)
        - `use std::{self, fmt, cmp};`: part-use, like js (esm: `import { classA, classB } from "...""`)
        - `use std::*;`: use all, like js (esm: `import * from "..."`)

```rust
/// module_in_other_file.file
pub fn function_in_other_file() {}

/// lib.rs
// ç”¨ä¸‹è¡Œè¯­å¥å¼•å…¥å¤–éƒ¨æ–‡ä»¶çš„ module
// mod module_in_other_file;

mod outer_module {
    pub mod inner_module {
        pub fn inner_function() {}
    }

    pub struct StructExample {
        private_item: i32,
        pub public_item: i32,
    }

    pub enum EnumExample {
        DefaultToPublic,
        NoNeedOfPub
    }

    fn super_example() {
        super::path_example()
    }
}

pub fn path_example() {
    // absolute
    crate::outer_module::inner_module::inner_function();

    // relative
    outer_module::inner_module::inner_function();
}

fn use_example() {
    use outer_module::inner_module;

    inner_module::inner_function();
}
```

### å¸¸ç”¨é›†åˆ

#### Vector

- ç±»å‹ä¸º `Vec<T>`
- ç”±æ ‡å‡†åº“æä¾›
- å¯å­˜å‚¨å¤šä¸ªå€¼
- åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„æ•°æ®
- å€¼åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾

```rust
fn vector_example() {
    // åˆ›å»º
    // let mut v: Vec<i32> = Vec::new();
    let mut v = vec![1, 2, 3];

    // æ›´æ–°
    v.push(4);
    v.push(5);

    // å¼•ç”¨
    // - ç´¢å¼•è®¿é—® (è¶Šç•Œä¼š panic)
    let third_1: &i32 = &v[2];
    // - get è®¿é—® (è¶Šç•Œåˆ™ä¸º None)
    let third_2 = match v.get(2) {
        Some(val) => val,
        None => None
    };

    // éå† - for å¾ªç¯
    // - ä¸å¯å˜å¼•ç”¨ å¾ªç¯
    for val in &v {
        print!("{}", val);  // -> 1 2 3 4 5
    }
    // - å¯å˜å¼•ç”¨ å¾ªç¯
    for val in &mut v {
        *val += 10;
        print!("{}", i);  // -> 11 12 13 14 15
    }
}
```

#### String

- **Rust** çš„ **æ ¸å¿ƒè¯­è¨€å±‚é¢**, åªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹: å­—ç¬¦ä¸²åˆ‡ç‰‡ `&str`
    - å­—ç¬¦ä¸²åˆ‡ç‰‡: å¯¹å­˜å‚¨åœ¨å…¶ä»–åœ°æ–¹çš„ `UTF-8` ç¼–ç çš„å­—ç¬¦ä¸²çš„å¼•ç”¨
    - å­—ç¬¦ä¸²å­—é¢é‡: å­˜å‚¨åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„å­—ç¬¦ä¸²åˆ‡ç‰‡
- `String` ç±»å‹
    - æ¥è‡ª **æ ‡å‡†åº“** è€Œä¸æ˜¯æ ¸å¿ƒè¯­è¨€
    - å¯å¢é•¿ã€å¯ä¿®æ”¹ã€å¯è·å¾—æ‰€æœ‰æƒ
    - `UTF-8` ç¼–ç 
    - æ˜¯å¯¹ `Vec<u8>` çš„åŒ…è£…, `len()` æ–¹æ³• è¿”å›çš„æ˜¯ `Unicode` æ ‡é‡å€¼, è€Œéå¸¸è§„æ„ä¹‰çš„å­—ç¬¦æ•° (ä¸æ”¯æŒç´¢å¼•å½¢å¼è®¿é—®,
      ç”¨ç´¢å¼•æ–¹å¼è¿›è¡Œè®¿é—®ä¼šæŠ¥é”™)
- å­—èŠ‚`Bytes`ã€æ ‡é‡å€¼`Scalar Values`ã€å­—å½¢ç°‡`Grapheme Clusters`
    - éå†å­—èŠ‚ `for b in s.bytes() {}`
    - éå†`Unicode`æ ‡é‡å€¼ `for c in s.chars() {}`
    - éå†å­—å½¢ç°‡ `æ— æ ‡å‡†åº“æä¾›`

```rust
fn string_example() {
    // åˆ›å»º
    // - ä½¿ç”¨ ::new æ–¹æ³•åˆ›å»º
    let s1 = String::new();
    // - ä½¿ç”¨ to_string æ–¹æ³•
    let s2 = "hello".to_string();
    // - ä½¿ç”¨ ::from æ–¹æ³•åˆ›å»º
    let mut s3 = String::from("hello");

    // æ›´æ–°
    // - push_str æŠŠå­—ç¬¦ä¸²åˆ‡ç‰‡é™„åŠ åˆ° String
    s3.push_str(" world");
    println!("{}", s3);  // -> hello world
    // - push æŠŠå•ä¸ªå­—ç¬¦é™„åŠ åˆ° String
    s3.push('!');
    println!("{}", s3);  // -> hello world!
    // - '+' è¿ç®—ç¬¦
    // ä½¿ç”¨äº†ç±»ä¼¼ fn add(self, s: &str) -> String {...} çš„æ–¹æ³•, ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å¤±å»å…¶æ‰€æœ‰æƒ
    let name = String::from(" bye.");
    let s4 = s3 + &name;  // -> hello world! bye. (s3 å‘ç”Ÿäº†ç§»åŠ¨å·²å¤±æ•ˆ)
    // - format! å® (ç±»ä¼¼ js å­—ç¬¦ä¸²æ¨¡æ¿è¯­æ³•)
    let s5 = format!("{}-{}", s2, s4);
    println!("{}", s5);  // -> hello-hello world! bye

    // è®¿é—®
    // - éå†å­—èŠ‚ 
    for b in s5.bytes() {}
    // - éå†`Unicode`æ ‡é‡å€¼ 
    for c in s5.chars() {}
    // - éå†å­—å½¢ç°‡ æ— æ ‡å‡†åº“æä¾›

    // åˆ‡å‰²
    // å…è®¸ ä½†ä¸èƒ½è·¨è¶Šå­—ç¬¦è¾¹ç•Œ, å¦‚æœåˆ‡å‰²äº†å­—ç¬¦è¾¹ç•Œåˆ™ä¼šå¼•å‘ panic
    // - &string[start..end]
    let string_part = &s5[0..3];
}
```

#### HashMap

- ç±»å‹ `HashMap<K, V>`
- é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨, ä¸€ä¸ªé”® `K` å¯¹åº”ä¸€ä¸ªå€¼ `V`
- é€‚ç”¨åœºæ™¯: é€šè¿‡ `K` æ¥å¯»æ‰¾æ•°æ®, è€Œä¸æ˜¯é€šè¿‡ç´¢å¼•
- æ‰€æœ‰æƒ
    - å¯¹å®ç°äº† `Copy trait` çš„ç±»å‹(å¦‚`i32`), å€¼ä¼šè¢«å¤åˆ¶åˆ° `HashMap` ä¸­
    - å¯¹æ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼, å…¶å€¼ä¼šè¢«ç§»åŠ¨, æ‰€æœ‰æƒè½¬ç§»ç»™ `HashMap`
        - å¦‚æœå°†å€¼çš„å¼•ç”¨æ’å…¥åˆ° `HashMap` ä¸­, å€¼æœ¬èº«ä¸ä¼šç§»åŠ¨
        - ä½†åœ¨ `HashMap` æœ‰æ•ˆæœŸé—´, è¢«å¼•ç”¨çš„å€¼å¿…é¡»ä¿æŒæœ‰æ•ˆ
- é»˜è®¤æƒ…å†µä¸‹, `HashMap` ä½¿ç”¨åŠ å¯†åŠŸèƒ½å¼ºå¤§çš„ `Hash` å‡½æ•°, å¯ä»¥æŠµæŠ— `Dos` æ”»å‡»
    - ä¸æ˜¯å¯ç”¨çš„æœ€å¿«çš„ `Hash` ç®—æ³•, ä½†å…·æœ‰æ›´å¥½çš„å®‰å…¨æ€§
    - å¯ä»¥æŒ‡å®šä¸åŒçš„ `hasher` æ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå‡½æ•°, `hasher` æ˜¯å®ç° `BuildHasher trait` çš„ç±»å‹

```rust
use std::collections::HashMap;

fn hashmap_example() {
    // åˆ›å»º
    // - ä½¿ç”¨ ::new æ–¹æ³•åˆ›å»º
    let mut map: HashMap<&String, i32> = HashMap::new();
    // - ä½¿ç”¨ ::collect æ–¹æ³•åˆ›å»º
    // åœ¨å…ƒç´ ç±»å‹ä¸º Tuple çš„ Vector ä¸Šä½¿ç”¨ collect æ–¹æ³•, å¯ä»¥ç»„å»ºä¸€ä¸ª HashMap
    let teams = vec![String::from("red"), String::from("blue")];
    let scores = vec![10, 50];
    let team_with_score: HashMap<_, _> = teams.iter()
        .zip(scores.iter())
        .collect();

    // æ·»åŠ æ•°æ®
    let red_team = String::from("red");
    map.insert(&red_team, 10);

    // è®¿é—®æ•°æ®
    let red_score = match map.get(&red_team) {
        Some(score) => score,
        None => None,
    };

    // éå† - for å¾ªç¯
    for (k, v) in &map {
        println!("{}: {}", k, v);
    }

    // æ›´æ–°
    // - K å·²ç»å­˜åœ¨, å¯¹åº”ä¸€ä¸ª V
    // - - æ›¿æ¢ç°æœ‰çš„ V
    map.insert(&red_team, 20);
    // - - ä¿ç•™ç°æœ‰çš„ V, å¿½ç•¥æ–°çš„ V
    map.entry(&red_team).or_insert(30);  // å·²å­˜åœ¨, å¿½ç•¥
    let blue_team = String::from("blue");
    map.entry(&blue_team).or_insert(40);  // ä¸å­˜åœ¨, æ’å…¥
    // - - åˆå¹¶ç°æœ‰çš„ V å’Œæ–°çš„ V
    let text = "a b c a c";
    let mut char_map = HashMap::new();
    for char in text.split_whitespace() {
        let count = char_map.entry(char).or_insert(0);
        *count += 1;
    }
    println!("{:#?}", char_map);  // {"a": 2, "b": 1, "c": 2}
    // - K ä¸å­˜åœ¨: å¢åŠ ä¸€ä¸ª K-V å¯¹
    let new_team = String::from("new");
    map.insert(&new_team, 100);
}
```

### é”™è¯¯å¤„ç†

#### å¯æ¢å¤é”™è¯¯ å’Œ ä¸å¯æ¢å¤é”™è¯¯

- å¯æ¢å¤é”™è¯¯ `Result<T, E>`
    - ä¾‹: æ–‡ä»¶æœªæ‰¾åˆ°, å¯å†æ¬¡å°è¯•
    - `Result` æšä¸¾
- ä¸å¯æ¢å¤é”™è¯¯ `panic!`
    - ä¾‹: è®¿é—®çš„ç´¢å¼•è¶Šç•Œ
    - æ‰§è¡Œ `panic!` å®
        - æ‰“å°ä¸€ä¸ªé”™è¯¯ä¿¡æ¯
        - å±•å¼€ `unwind`, æ¸…ç†è°ƒç”¨æ ˆ `stack`
        - é€€å‡ºç¨‹åº

```rust
// Result ç»“æ„å¦‚ä¸‹
// enum Result<T, E> {
//     // æˆåŠŸè¿”å›å€¼
//     Ok(T),
//     // å¤±è´¥è¿”å›å€¼
//     Err(E),
// }
fn result_example() {
    let f = File::open("hello.txt");

    // åŒ¹é…æ–‡ä»¶æ‰“å¼€ç»“æœ
    let f = match f {
        Ok(file) => file,
        // åŒ¹é…é”™è¯¯ç±»å‹
        Err(err) => match err.kind() {
            ErrorKind::NotFound => println!("file not found!"),
            other_error => panic!("other error!"),
        }
    };

    // ä½¿ç”¨é—­åŒ…é‡å†™ä¸Šè¿°ä»£ç 
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() - ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!( "Error creating file: {:?}"ï¼Œ error);
            })
        } else {
            panic!("Error opening file: {:?}", error);
        }
    });
}
```

#### unwrap å’Œ expect å’Œ ? è¿ç®—ç¬¦

- `unwrap(self)`:
    - å¦‚æœæˆåŠŸ, åˆ™ç›´æ¥è¿”å› `Result::Ok` é‡Œçš„å€¼,
    - å¦‚æœå¤±è´¥, åˆ™è°ƒç”¨ `panic!` å®ä¸­æ­¢ç¨‹åº.
- `expect(self, msg: &str)`:
    - æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²å‚æ•°(åˆ‡ç‰‡ç±»å‹), å½“ç»“æœä¸º`Result::Error`çš„æ—¶å€™è¾“å‡º.
    - å¦‚æœæˆåŠŸ, åˆ™ç›´æ¥è¿”å› `result` é‡Œçš„å€¼,
    - å¦‚æœå¤±è´¥, åˆ™è¾“å‡º`expect`çš„å…¥å‚å¹¶è°ƒç”¨ `panic!` å®ä¸­æ­¢ç¨‹åº.
- `?`è¿ç®—ç¬¦
    - åœ¨è¿”å›ç±»å‹ä¸º `Result` çš„å‡½æ•°ä¸­ä½¿ç”¨
    - åœ¨ `Result` ç±»å‹çš„å€¼åé¢ä½¿ç”¨
    - å¯é“¾å¼è°ƒç”¨, ç±»ä¼¼äº `typescript` ä¸­çš„ `?.` æ“ä½œ
    - å¦‚æœæˆåŠŸ, `Ok(res)` ä¸­çš„ `res`ä½œä¸ºè¡¨è¾¾å¼çš„ç»“æœ, å‡½æ•°ç»§ç»­æ‰§è¡Œ
    - å¦‚æœå¤±è´¥, æ•´ä¸ªå‡½æ•°è¿”å› `Err(err)`, ç›¸å½“äºæ‰§è¡Œäº† `return Err(err)`

### æ³›å‹ã€Traitã€ç”Ÿå‘½å‘¨æœŸ

#### æ³›å‹

- æé«˜ä»£ç å¤ç”¨èƒ½åŠ›
- æ˜¯å…·ä½“ç±»å‹æˆ–å…¶ä»–å±æ€§çš„æŠ½è±¡ä»£æ›¿
- ä¸ `typescript` ç±»ä¼¼
    - `fn` -> `function`
    - `struct` -> `class`
    - `enum` -> `type` / `interface`
- `fn largest<T>(list: &[T]) -> T {...}`
- æ€§èƒ½å’Œæ™®é€šä»£ç ä¸€è‡´, å› ä¸ºç¼–è¯‘å™¨ä¼šæ‰§è¡Œå•æ€åŒ–(ç±»ä¼¼`c++`)

#### Trait

- æŠŠæ–¹æ³•ç­¾åæ”¾åœ¨ä¸€èµ·, å®šä¹‰å®ç°æŸç§ç›®çš„æ‰€å¿…é¡»çš„ä¸€ç»„è¡Œä¸º (ç±»ä¼¼æŠ½è±¡ç±»)
    - å…³é”®å­— `trait`
    - åªæœ‰æ–¹æ³•ç­¾å, æ²¡æœ‰å…·ä½“å®ç°
    - `trait` å¯ä»¥æœ‰å¤šä¸ªæ–¹æ³•: æ¯ä¸ªæ–¹æ³•ç­¾åå ä¸€è¡Œ, ä»¥ `;` ç»“å°¾
    - å®ç°è¯¥ `trait` çš„ç±»å‹å¿…é¡»æä¾›å…·ä½“çš„æ–¹æ³•å®ç°
- å®ç° `trait` çš„çº¦æŸ
    - è¿™ä¸ªç±»å‹æˆ–è¿™ä¸ª `trait` æ˜¯åœ¨æœ¬åœ° `crate` é‡Œå®šä¹‰çš„
    - æ— æ³•ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨çš„ `trait` (å­¤å„¿è§„åˆ™)
- é»˜è®¤å®ç°
    - åœ¨ `trait` ä¸­ç›´æ¥å®ç°æ–¹æ³•, ä½œä¸ºé»˜è®¤å®ç°
    - é»˜è®¤å®ç°ä¸­çš„æ–¹æ³•å¯ä»¥è°ƒç”¨ `trait` ä¸­å…¶ä»–çš„æ–¹æ³•, å³ä½¿è¿™äº›æ–¹æ³•æ²¡ç”¨é»˜è®¤å®ç°
- `trait` ä½œä¸ºå‚æ•°
    - `impl trait` è¯­æ³•, é€‚ç”¨äºç®€å•æƒ…å†µ (`trait bound` çš„ä¸€ç§è¯­æ³•ç³–)
    - `trait bound` è¯­æ³•, é€‚ç”¨äºå¤æ‚æƒ…å†µ
    - ä½¿ç”¨ `+` æŒ‡å®šå¤šä¸ª `trait bound`
    - `trait bound` å¯ä½¿ç”¨ `where` å­å¥
- `trait` ä½œä¸ºè¿”å›ç±»å‹
    - `impl trait` è¯­æ³•: åªèƒ½è¿”å›ç¡®å®šçš„åŒä¸€ç§ç±»å‹, è¿”å›å¯èƒ½ä¸åŒç±»å‹çš„ä»£ç ä¼šæŠ¥é”™

```rust
pub trait Summary {
    fn summarize1(&self) -> String;
    fn summarize2(&self) -> String;
}

pub trait Display {
    fn display1(&self) -> String;
    fn display2(&self) -> String;
}

// trait ä½œä¸ºå‚æ•°
fn impl_trait_example(item: impl Summary + Display) {
    println!("{}", item.summarize1());
}

fn trait_bound_example<T: Summary + Display>(item: T) {
    println!("{}", item.summarize1());
}

fn where_example<T, K>(item1: T, item2: K)
    where
        T: Summary,
        K: Summary + Display,
{
    println!("{}, {}", item1.summarize1(), item2.display1());
}

// trait ä½œä¸ºè¿”å›ç±»å‹
fn trait_as_result_example() -> impl Summary {
    // native code
}
```

#### ç”Ÿå‘½å‘¨æœŸ

- å¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸ
    - é¿å…å‚æ‚¬å¼•ç”¨ (`dangling reference`)
    - æ¯ä¸ªå¼•ç”¨éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
    - å¤§å¤šæ•°æƒ…å†µæ˜¯éšå¼çš„ã€å¯æ¨æ–­çš„
    - å½“å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½ä»¥ä¸åŒçš„æ–¹å¼äº’ç›¸å…³è”æ—¶, å¯ä»¥æ‰‹åŠ¨æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
- å€Ÿç”¨æ£€æŸ¥å™¨
    - æ¯”è¾ƒä½œç”¨åŸŸæ¥åˆ¤æ–­æ‰€æœ‰çš„å€Ÿç”¨æ˜¯å¦åˆæ³•
- ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    - ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ä¸ä¼šæ”¹å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦
    - å½“æŒ‡å®šäº†æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°, å‡½æ•°å¯ä»¥æ¥æ”¶å¸¦æœ‰ä»»ä½•ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
    - ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨æè¿°äº†å¤šä¸ªå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¹‹é—´çš„å…³ç³», ä½†ä¸å½±å“ç”Ÿå‘½å‘¨æœŸ
    - è¯­æ³•
        - å‚æ•°åä»¥ `'` å¼€å¤´, é€šå¸¸å…¨å°å†™éå¸¸çŸ­(`'a`)
        - `&i32`  // ä¸€ä¸ªå¼•ç”¨
        - `&'a i32`  // å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
        - `&'a mut i32`  // å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¯å˜å¼•ç”¨
- ç”Ÿå‘½å‘¨æœŸçœç•¥çš„ä¸‰ä¸ªè§„åˆ™ (é€‚ç”¨äº `fn` å’Œ `impl`)
    - è§„åˆ™1: æ¯ä¸ªå¼•ç”¨ç±»å‹çš„å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
    - è§„åˆ™2: å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°, é‚£ä¹ˆè¯¥ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
    - è§„åˆ™3: (åªé€‚ç”¨äºæ–¹æ³•) å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°, ä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ `&self` æˆ– `&mut self`, é‚£ä¹ˆ `self`
      çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
- å‡½æ•°å®šä¹‰ä¸­çš„å£°æ˜å‘¨æœŸæ ‡æ³¨
    - æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°å£°æ˜åœ¨åœ¨å‡½æ•°åå’Œå‚æ•°åˆ—è¡¨ä¹‹é—´çš„ `<>` é‡Œ
    - æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°çš„æ–¹å¼ä¾èµ–äºå‡½æ•°æ‰€åšçš„äº‹
        - ä»å‡½æ•°è¿”å›å¼•ç”¨æ—¶, è¿”å›ç±»å‹çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°éœ€è¦ä¸å…¶ä¸­ä¸€ä¸ªå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸåŒ¹é…
        - å¦‚æœè¿”å›çš„å¼•ç”¨æ²¡æœ‰æŒ‡å‘ä»»ä½•å‚æ•°, é‚£ä¹ˆå®ƒåªèƒ½å¼•ç”¨å‡½æ•°å†…åˆ›å»ºçš„å€¼(å‘ç”Ÿäº†æ‚¬å‚å¼•ç”¨,
          å› ä¸ºè¯¥å€¼åœ¨å‡½æ•°ç»“æŸæ—¶ç»“æŸäº†å…¶ç”Ÿå‘½å‘¨æœŸ)
- ç»“æ„ä½“å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨(è§ä¸‹ `code example`)
- æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    - åœ¨ `struct` ä¸Šä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå®ç°æ–¹æ³•, è¯­æ³•å’Œæ³›å‹å‚æ•°çš„è¯­æ³•ä¸€è‡´
    - `struct` å­—æ®µçš„ç”Ÿå‘½å‘¨æœŸå
        - åœ¨ `impl` åå£°æ˜
        - åœ¨ `struct` åä½¿ç”¨
        - è¿™äº›ç”Ÿå‘½å‘¨æœŸå‚æ•°æ˜¯ `struct` ç±»å‹çš„ä¸€éƒ¨åˆ†
    - `impl` å—å†…çš„æ–¹æ³•ç­¾åä¸­
        - å¼•ç”¨å¿…é¡»ç»‘å®šäº `struct` å­—æ®µå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ, æˆ–è€…å¼•ç”¨æ˜¯ç‹¬ç«‹çš„ä¹Ÿå¯ä»¥
        - ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ç»å¸¸ä½¿å¾—æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸æ˜¯å¿…é¡»çš„
- é™æ€ç”Ÿå‘½å‘¨æœŸ
    - `'static` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç”Ÿå‘½å‘¨æœŸ, æ˜¯æ•´ä¸ªç¨‹åºçš„æŒç»­æ—¶é—´
        - ä¾‹å¦‚: æ‰€æœ‰çš„å­—ç¬¦ä¸²å­—é¢é‡éƒ½æ‹¥æœ‰ `'static` çš„ç”Ÿå‘½å‘¨æœŸ

```rust
// ç”Ÿå‘½å‘¨æœŸé”™è¯¯ç¤ºä¾‹
fn life_circle_error_example() {
    let r;
    {
        let x = 5;
        r = &x;  // error[E0597]: borrowed value does not live long enough
    }
    println!("r: {}", r);
}

// ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å®ä¾‹
fn life_circle_mark_example() {
    let s1 = String::from("abcd");
    let s2 = "xyz";

    let result = longest(s1.as_str(), s2);

    println!("longest string is: {}", result);
}

// æ­¤å¤„çš„ç”Ÿå‘½å‘¨æœŸ 'a çš„å®é™…ç”Ÿå‘½å‘¨æœŸæ˜¯: x å’Œ y ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸä¸­è¾ƒå°çš„é‚£ä¸ª
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// ç”Ÿå‘½å‘¨æœŸå‚æ•°çœç•¥è§„åˆ™

// ä¾‹1
// åŸå§‹
fn ex1(s: &str) -> &str { "native code" }

// è§„åˆ™1
fn ex1_mid<'a>(s: &'a str) -> &str { "native code" }

// è§„åˆ™2
fn ex1_auto<'a>(s: &'a str) -> &'a str { "native code" }
// æ­¤æ—¶ç¬¦åˆ [æ‰€æœ‰å¼•ç”¨éƒ½æœ‰å…¶ç”Ÿå‘½å‘¨æœŸ] -> å³å¯ä»¥çœç•¥

// ä¾‹2
// åŸå§‹
fn ex2(x: &str, y: &str) -> &str { "native code" }

// è§„åˆ™1, è§„åˆ™23ä¸é€‚ç”¨
fn ex2_auto<'a, 'b>(x: &'a str, y: &'b str) -> &str { "native code" }
// æ­¤æ—¶ä¸ç¬¦åˆ [æ‰€æœ‰å¼•ç”¨éƒ½æœ‰å…¶ç”Ÿå‘½å‘¨æœŸ] -> å³ä¸å¯ä»¥çœç•¥

// ä¾‹3
struct LifeCircleMark<'a> {
    part: &'a str
}

impl<'a> LifeCircleMark<'a> {
    // æ— å¼•ç”¨è¿”å›, åˆ™æ— éœ€ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    fn no_ref_return(&self) -> i32 { 1 }

    // æ ¹æ®è§„åˆ™3, è‡ªåŠ¨ä¸ºè¿”å›ç±»å‹æ ‡æ³¨ä¸º self çš„ç”Ÿå‘½å‘¨æœŸ
    fn with_ref_return(&self, arg1: &str) -> &str {
        "native code"
    }
}
```

```rust
// ç»¼åˆä½¿ç”¨
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>
(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);

    if x.len() > y.len() { x } else { y }
}
```

### æµ‹è¯•

- ä½¿ç”¨ `#[test]` æ ‡æ³¨æ‰€æœ‰çš„æµ‹è¯•å‡½æ•°
- ä½¿ç”¨ `cargo test` å‘½ä»¤è¿è¡Œæ‰€æœ‰çš„æµ‹è¯•å‡½æ•°
    - æ„å»ºä¸€ä¸ª `Test Runner` å¯æ‰§è¡Œæ–‡ä»¶
    - è¿è¡Œæ ‡æ³¨äº† `test` çš„å‡½æ•°å¹¶æŠ¥å‘Šå…¶æ˜¯å¦æˆåŠŸ
- å½“ä½¿ç”¨ `cargo` åˆ›å»º `library` é¡¹ç›®æ—¶, ä¼šç”Ÿæˆä¸€ä¸ª `test module`, é‡Œé¢æœ‰ä¸€ä¸ª `test` å‡½æ•°
    - å¯ä»¥æœ‰ä»»æ„æ•°é‡çš„ `test module` å’Œ `test` å‡½æ•°

#### æ–­è¨€

- `assert!` æµ‹è¯• `bool`
    - æ–­è¨€å¤±è´¥: è¾“å‡º `FAILED`
- `assert_eq!` å’Œ `assert_ne!` æµ‹è¯•ç›¸ç­‰æ€§
    - ä¸¤ä¸ªå‚æ•°
    - è¦æ±‚å‚æ•°å®ç°äº† `PartialEq` å’Œ `Debug` è¿™ä¸¤ä¸ª `trait` (æ‰€æœ‰çš„åŸºæœ¬ç±»å‹å’Œæ ‡å‡†åº“çš„å¤§éƒ¨åˆ†ç±»å‹éƒ½å·²å®ç°)
    - æ–­è¨€å¤±è´¥: è¾“å‡º ä¸¤ä¸ªå‚æ•°çš„å€¼
- æ·»åŠ è‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯
    - åœ¨ `assert!` çš„ç¬¬äºŒä¸ªå‚æ•°å’Œ `assert_eq!`/`assert_ne!` çš„ç¬¬ä¸‰ä¸ªå‚æ•°æ·»åŠ è‡ªå®šä¹‰ä¿¡æ¯ (å¯ä»¥ä½¿ç”¨å ä½ç¬¦æ·»åŠ æ›´å¤šä¿¡æ¯)
- ä½¿ç”¨ `#[should_panic]` æ ‡æ³¨åº”è¯¥å‘ç”Ÿ `panic`
    - `#[should_panic(expected = "expected error msg")]` æ ‡æ³¨å‘ç”Ÿ `panic` çš„é”™è¯¯ä¿¡æ¯åº”è¯¥åŒ…å«æŸäº›å†…å®¹æ–‡æœ¬
- ä½¿ç”¨ `Result<T, E>` (æ— éœ€ `panic`)
    - è¿”å› `Ok`: æµ‹è¯•é€šè¿‡
    - è¿”å› `Err`: æµ‹è¯•å¤±è´¥

#### cargo test

- é»˜è®¤è¡Œä¸º
    - å¹¶è¡Œè¿è¡Œ
    - æ‰§è¡Œæ‰€æœ‰æµ‹è¯•
    - æ•è·(ä¸æ˜¾ç¤º)æ‰€æœ‰è¾“å‡º, ä½¿è¯»å–ä¸æµ‹è¯•ç»“æœç›¸å…³çš„è¾“å‡ºæ›´å®¹æ˜“
- å‘½ä»¤è¡Œå‚æ•°
    - é’ˆå¯¹ `cargo`: æ”¾åœ¨ `cargo test` ä¹‹å
        - ä½¿ç”¨ `cargo test --help` æŸ¥çœ‹å¯ç”¨ä¿¡æ¯
    - é’ˆå¯¹æµ‹è¯•å¯æ‰§è¡Œç¨‹åº: æ”¾åœ¨ `--` ä¹‹å
        - ä½¿ç”¨ `cargo test -- --help` æŸ¥çœ‹å¯ç”¨ä¿¡æ¯
- å¹¶è¡Œ/ä¸²è¡Œ è¿è¡Œæµ‹è¯•
    - å¹¶è¡Œ(é»˜è®¤)
        - è¿è¡Œæ›´å¿«
        - éœ€è¦ç¡®ä¿æµ‹è¯•ä¹‹é—´ä¸äº’ç›¸ä¾èµ–ä¸”ä¸ä¾èµ–äºæŸä¸€å…±äº«çŠ¶æ€
    - ä¸²è¡Œ(æ§åˆ¶çº¿ç¨‹æ•°é‡)
        - `cargo test -- --test-threads=1`
- æ˜¾å¼å‡½æ•°è¾“å‡º
    - å¦‚æœæµ‹è¯•é€šè¿‡, é»˜è®¤ä¼šæ•è·æ‰€æœ‰æ ‡å‡†è¾“å‡ºå†…å®¹(ä¸æ˜¾ç¤º)
    - ä½¿ç”¨ `cargo test -- --show-output` åœ¨æˆåŠŸçš„æµ‹è¯•ä¸­æ˜¾ç¤ºè¾“å‡º
- æŒ‰åç§°è¿è¡Œæµ‹è¯•
    - å°†æµ‹è¯•çš„åç§°(ä¸€ä¸ªæˆ–å¤šä¸ª)ä½œä¸º `cargo test` çš„å‚æ•°
    - `cargo test name_of_test_fn`
    - ç”¨æµ‹è¯•åçš„ä¸€éƒ¨åˆ†åŒ¹é…å¤šä¸ªæµ‹è¯•
        - å¦‚: ä½¿ç”¨ `cargo test my_test` åŒ¹é… `my_test_1`ã€`my_test_2` ç­‰å¤šä¸ªæµ‹è¯•å‡½æ•°
    - å¿½ç•¥æŸäº›æµ‹è¯•, è¿è¡Œå‰©ä½™æµ‹è¯•
        - ä½¿ç”¨ `#[ignore]` æ ‡è®°å¿½ç•¥æµ‹è¯•å‡½æ•°
        - ä½¿ç”¨ `cargo test -- --ignored` åªè¿è¡Œè¢«æ ‡è®°ä¸ºå¿½ç•¥çš„æµ‹è¯•å‡½æ•°

#### å•å…ƒæµ‹è¯• / é›†æˆæµ‹è¯•

- å•å…ƒæµ‹è¯•
    - ä¸€æ¬¡å¯¹ä¸€ä¸ªæ¨¡å—è¿›è¡Œéš”ç¦»çš„æµ‹è¯•
    - å¯æµ‹è¯• `private` æ¥å£
    - ä¸€èˆ¬ä¸æ¨¡å—åŒæ–‡ä»¶ä¸‹, ä½¿ç”¨ `#[cfg(test)]` è¿›è¡Œæ ‡æ³¨
        - åªæœ‰è¿è¡Œ `cargo test` æ‰ä¼šç¼–è¯‘è¿è¡Œä»£ç 
        - è¿è¡Œ `cargo build` ä¸ä¼šç¼–è¯‘/è¿è¡Œ ä»£ç 
    - æµ‹è¯•ç§æœ‰å‡½æ•°
        - å…è®¸ç›´æ¥è°ƒç”¨ç§æœ‰å‡½æ•°
- é›†æˆæµ‹è¯•
    - å’Œå¤–éƒ¨ä»£ç ä¸€æ ·è°ƒç”¨æ¨¡å—(å¯èƒ½ä½¿ç”¨åˆ°å¤šä¸ªæ¨¡å—)
    - åªèƒ½æµ‹è¯• `public` æ¥å£
    - `tests` ç›®å½•(ä¸ `src` å¹¶åˆ—)
        - ä¸éœ€è¦ `#[cfg(test)]` æ ‡æ³¨
        - åªä¼šåœ¨ä½¿ç”¨ `cargo test` æ—¶ç¼–è¯‘
        - æ¯ä¸€ä¸ªæ–‡ä»¶éƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„ `crate`
    - è¿è¡ŒæŒ‡å®šçš„é›†æˆæµ‹è¯•
        - è¿è¡Œç‰¹å®šçš„é›†æˆæµ‹è¯•: `cargo test name_of_test_fn`
        - è¿è¡ŒæŸä¸ªæµ‹è¯•æ–‡ä»¶å†…çš„æ‰€æœ‰æµ‹è¯•: `cargo test --test filename`
- é’ˆå¯¹ `binary crate` çš„é›†æˆæµ‹è¯•
    - å¦‚æœé¡¹ç›®æ˜¯ `binary crate`, åªå«æœ‰ `src/main.rs` è€Œæ²¡æœ‰ `src/lib.rs`
        - ä¸èƒ½åœ¨ `tests` ç›®å½•ä¸‹åˆ›å»ºé›†æˆæµ‹è¯•
        - æ— æ³•æŠŠ `main.rs` çš„å‡½æ•°å¯¼å…¥åˆ°ä½œç”¨åŸŸ
            - åªæœ‰ `library crate` æ‰èƒ½æš´éœ²å‡½æ•°ç»™å…¶ä»– `crate` ä½¿ç”¨
            - `binary crate` æ„å‘³ç€ç‹¬ç«‹è¿è¡Œ
- `#[cfg(condition)]`: `configuration`(é…ç½®)
    - åªæœ‰åœ¨æŒ‡å®šçš„é…ç½®æ¡ä»¶ä¸‹æ‰è¢«åŒ…å«

### å®ä¾‹

- `code example`: `git clone` -> `cargo run`
- æµ‹è¯•é©±åŠ¨å¼€å‘ `TDD, test-driven development`
    - ç¼–å†™ä¸€ä¸ªä¼šå¤±è´¥çš„æµ‹è¯•, è¿è¡Œè¯¥æµ‹è¯•, ç¡®ä¿å…¶æŒ‰ç…§é¢„æœŸçš„åŸå› å¤±è´¥
    - ç¼–å†™æˆ–ä¿®æ”¹åˆšå¥½è¶³å¤Ÿçš„ä»£ç è®©æ–°æµ‹è¯•é€šè¿‡
    - é‡æ„åˆšåˆšæ·»åŠ æˆ–ä¿®æ”¹çš„ä»£ç , ç¡®ä¿æµ‹è¯•ä¼šå§‹ç»ˆé€šè¿‡
    - è¿”å›æ­¥éª¤1, ç»§ç»­

### é—­åŒ…ã€è¿­ä»£å™¨

#### é—­åŒ… (closure)

- åŸºæœ¬
    - é—­åŒ…æ˜¯å¯ä»¥æ•è·å…¶æ‰€åœ¨ç¯å¢ƒçš„åŒ¿åå‡½æ•°
        - æ˜¯åŒ¿åå‡½æ•°
        - ä¿å­˜ä¸ºå˜é‡, ä½œä¸ºå‚æ•°ä½¿ç”¨
        - å¯ä»¥åœ¨ä¸€ä¸ªåœ°æ–¹åˆ›å»ºé—­åŒ…, åœ¨å¦ä¸€ä¸ªä¸Šä¸‹æ–‡ä¸­è°ƒç”¨é—­åŒ…æ¥å®Œæˆè¿ç®—
        - å¯ä»¥ä»å…¶å®šä¹‰çš„ä½œç”¨åŸŸæ•è·å€¼
    - ä¸è¦æ±‚æ ‡æ³¨å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹(ä¹Ÿå¯ä»¥æ‰‹åŠ¨æ ‡æ³¨)
    - é€šå¸¸å¾ˆçŸ­å°, åªåœ¨ç‹­å°çš„ä¸Šä¸‹æ–‡ä¸­å·¥ä½œ, ç¼–è¯‘å™¨ä¸€èˆ¬èƒ½å¤Ÿæ¨æ–­å…¶å‚æ•°å’Œè¿”å›ç±»å‹

```rust
fn closure_example() {
    let closure1 = |x1| x1 + 1;
    let closure2 = |x2| {
        println!("x2: {}", x2);
        x2 + 1
    };
    let closure3 = |x3: u32| -> u32 {
        println!("x3: {}", x3);
        x3 + 1
    };
}
```

- è®© `struct` æŒæœ‰é—­åŒ…
    - `Fn trait`: `Fn`, `FnMut`, `FnOnce`

```rust
struct Cacher<F>
    where F: Fn(u32) -> u32 {
    closure: F,
    value: Option<u32>
}

impl<T> Cacher<T>
    where T: Fn(u32) -> u32 {
    fn new() -> Self <T> {
        Self {
            closure: |x| x + 1,
            value: None,
        }
    }
    fn calculate(&mut self, arg: u32) {
        match self.value {
            Some(v) => v,
            None => {
                let v = self.closure(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

fn closure_in_struct_example() {}
```

- é—­åŒ…ä»æ‰€åœ¨ç¯å¢ƒæ•è·å€¼çš„æ–¹å¼
    - å–å¾—æ‰€æœ‰æƒ: `FnOnce`, æ‰€æœ‰é—­åŒ…éƒ½å®ç°äº† `FnOnce`
    - å¯å˜å€Ÿç”¨: `FnMut`, æ²¡æœ‰ç§»åŠ¨æ•è·å˜é‡çš„å®ç°äº† `FnMut`
    - ä¸å¯å˜å€Ÿç”¨: `Fn`, æ— éœ€å¯å˜è®¿é—®æ•è·å˜é‡çš„é—­åŒ…å®ç°äº† `Fn`
    - `move` å…³é”®å­—: åœ¨å‚æ•°åˆ—è¡¨å‰ä½¿ç”¨ `move` å…³é”®å­—, å¯ä»¥å¼ºåˆ¶é—­åŒ…å–å¾—å®ƒæ‰€ä½¿ç”¨çš„ç¯å¢ƒå€¼çš„æ‰€æœ‰æƒ

#### è¿­ä»£å™¨ (iterator)

- **Rust** çš„è¿­ä»£å™¨: é™¤éè°ƒç”¨æ¶ˆè´¹è¿­ä»£å™¨çš„æ–¹æ³•, å¦åˆ™è¿­ä»£å™¨æœ¬èº«æ²¡æœ‰ä»»ä½•æ•ˆæœ
- `Iterator trait`
    - æ‰€æœ‰çš„è¿­ä»£å™¨éƒ½å®ç°äº† `Iterator trait`
    - `type Item` å’Œ `Self::Item` å®šä¹‰äº†ä¸æ­¤ `trait` å…³è”çš„ç±»å‹
    - `Iterator trait` ä»…è¦æ±‚å®ç°ä¸€ä¸ªæ–¹æ³• `next`
        - æ¯æ¬¡è¿”å›è¿­ä»£å™¨ä¸­çš„ä¸€é¡¹
        - è¿”å›ç»“æœåŒ…è£¹åœ¨ `Some` é‡Œ
        - è¿­ä»£ç»“æŸè¿”å› `None`
        - å¯ä»¥ç›´æ¥åœ¨è¿­ä»£å™¨ä¸Šè°ƒç”¨ `next` æ–¹æ³•
- è¿­ä»£æ–¹æ³•
    - `iter`: åœ¨ä¸å¯å˜å¼•ç”¨ä¸Šåˆ›å»ºè¿­ä»£å™¨
    - `into_iter`: åˆ›å»ºçš„è¿­ä»£å™¨ä¼šè·å¾—æ‰€æœ‰æƒ
    - `iter_mut`: è¿­ä»£å¯å˜çš„å¼•ç”¨
- æ¶ˆè€—è¿­ä»£å™¨çš„æ–¹æ³• (æ¶ˆè€—å‹é€‚é…å™¨)
    - ä¾‹: `sum` æ–¹æ³•, ä¼šå°†ç»“æœæ”¶å½•ä¸ºä¸€ä¸ªæ€»å’Œ
    - ä¾‹: `collect` æ–¹æ³•, ä¼šå°†ç»“æœæ”¶é›†åˆ°ä¸€ä¸ªé›†åˆç±»å‹ä¸­
- äº§ç”Ÿå…¶ä»–è¿­ä»£å™¨çš„æ–¹æ³• (è¿­ä»£å™¨é€‚é…å™¨)
    - ä¾‹: `map` æ–¹æ³•, ä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„è¿­ä»£å™¨
- ä½¿ç”¨é—­åŒ…æ•è·ç¯å¢ƒ
    - `filter` æ–¹æ³• (ç”¨æ³•åŒ`js` çš„ `filter`)
- è‡ªå®šä¹‰è¿­ä»£å™¨ (è§ `code example`)
- å¾ªç¯ vs è¿­ä»£å™¨
    - è¿­ä»£å™¨: é›¶æˆæœ¬æŠ½è±¡

```rust
// Iterator trait
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// è‡ªå®šä¹‰è¿­ä»£å™¨
struct Counter {
    count: u32,
    max: u32,
}

impl Counter {
    fn new(max: u32) -> Self {
        Self {
            count: 0,
            max
        }
    }
}

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        if self.count <= self.max {
            self.count += 1;
            Some(self.count - 1)
        } else {
            None
        }
    }
}
```

### æ„å»ºã€å‘å¸ƒ

#### release profile

- æ˜¯é¢„å®šä¹‰çš„(å¯è‡ªå®šä¹‰: å¯ä½¿ç”¨ä¸åŒçš„é…ç½®, å¯¹ä»£ç ç¼–è¯‘æœ‰æ›´å¤šçš„é…ç½®)
- æ¯ä¸ª `profile` çš„é…ç½®éƒ½ç‹¬ç«‹äºå…¶ä»–çš„ `profile`
- ä¸»è¦æœ‰ä¸¤ä¸ª
    - `dev profile`: é€‚ç”¨äºå¼€å‘, `cargo build`
    - `release profile`: é€‚ç”¨äºå‘å¸ƒ, `cargo build --release`
- è‡ªå®šä¹‰ `profile`
    - åœ¨ `cargo.toml` é‡Œæ·»åŠ  `[profile.xxx]` åŒºåŸŸ, åœ¨é‡Œé¢è¦†ç›–é»˜è®¤é…ç½®çš„å­é›†

```toml
# Cargo.toml

[package]
name = "demo"
version = "0.1.0"
authors = ["lopo <lopo@zju.edu.cn>"]
edition = "2021"

[profile.dev]
opt-level = 0  # opt-level æ˜¯ä»£ç çš„ä¼˜åŒ–ç¨‹åº¦ (è¶Šå¤§ä¼˜åŒ–è¶Šé«˜, æ‰€éœ€ç¼–è¯‘æ—¶é—´è¶Šé•¿)

[profile.release]
opt-level = 3
```

#### å‘å¸ƒåŒ…åˆ° crates.io

- æ–‡æ¡£æ³¨é‡Š: ç”¨äºç”Ÿæˆæ–‡æ¡£
    - ç”Ÿæˆ `HTML` æ–‡æ¡£
        - ä½¿ç”¨ `cargo doc` å‘½ä»¤ (ä½¿ç”¨ `--open` ç”Ÿæˆå¹¶æ‰“å¼€)
        - å®ƒä¼šä½¿ç”¨ `rustdoc` å·¥å…·, ä¸º **Rust** å®‰è£…åŒ…è‡ªå¸¦
        - ç”Ÿæˆçš„ `HTML` æ–‡æ¡£ä½äº `target/doc` ç›®å½•ä¸‹
    - æ˜¾ç¤ºå…¬å…± `API` çš„æ–‡æ¡£æ³¨é‡Š
    - ä½¿ç”¨ `///`
    - æ”¯æŒ `Markdown`
    - æ”¾ç½®åœ¨è¢«è¯´æ˜æ¡ç›®ä¹‹å‰
- ä¸ºåŒ…å«æ³¨é‡Šçš„é¡¹æ·»åŠ æ–‡æ¡£æ³¨é‡Š
    - ç¬¦å·: `//!`
    - é€šå¸¸ç”¨äºæè¿° `crate` å’Œ æ¨¡å—

```rust
/// Add x and y
/// # Examples
/// ```
/// let x = 1;
/// let y = 2;
///
/// assert_eq!(add(x, y), 3)
/// ```
pub fn add(x: i32, y: i32) -> i32 {
    x + y
}
```

##### pub use

- é‡æ–°å¯¼å‡º, åˆ›å»ºä¸€ä¸ªä¸å†…éƒ¨ç§æœ‰ç»“æ„ä¸åŒçš„å¯¹å¤–å…¬å…±ç»“æ„

##### å‘å¸ƒ crate

- æ³¨å†Œ `crates.io` å¹¶ç”Ÿæˆ `token` (ä½¿ç”¨ `cargo login` æœ¬åœ°ä¿å­˜å‡­è¯)
- `Cargo.toml` ä¸­ä¸€äº›(å¿…é¡»çš„)å…ƒæ•°æ®
    - `name` åŒ…å
    - `description` æè¿°
    - `license` è®¸å¯è¯æ ‡è¯†å€¼
        - å¯æŒ‡å®šå¤šä¸ª, ä½¿ç”¨ `OR` éš”å¼€
    - `version` ç‰ˆæœ¬
    - `author` ä½œè€…
- å‘å¸ƒ: ä½¿ç”¨ `cargo publish`
- `cargo yank` æ’¤å›ç‰ˆæœ¬
    - ä¸å¯ä»¥åˆ é™¤ `crates.io` ä¸Šçš„ç‰ˆæœ¬
    - ä½†å¯ä»¥é˜²æ­¢å…¶ä»–æ–°é¡¹ç›®æŠŠå®ƒä½œä¸ºä¾èµ–
    - `cargo yank --vers 0.1.0`
    - `cargo yank --vers 0.1.0 --undo`

##### å·¥ä½œç©ºé—´

- ç±»ä¼¼ `yarn` / `lerna`

```toml
[workspace]

members = [
    "proj1",
    "proj2",
    # ...
]
```

##### å®‰è£…äºŒè¿›åˆ¶ crate

- `cargo install`
- é™åˆ¶: åªèƒ½å®‰è£…å…·æœ‰äºŒè¿›åˆ¶ç›®æ ‡çš„ `crate`
- äºŒè¿›åˆ¶ç›®æ ‡: `binary target`, æ˜¯ä¸€ä¸ªå¯è¿è¡Œç¨‹åº. ç”±æ‹¥æœ‰ `src/main.rs` æˆ–å…¶å®ƒè¢«æŒ‡å®šä¸ºäºŒè¿›åˆ¶æ–‡ä»¶çš„ `crate` ç”Ÿæˆ

##### ä½¿ç”¨è‡ªå®šä¹‰å‘½ä»¤æ‰©å±• cargo

- å¦‚æœç¯å¢ƒå˜é‡ä¸­æŸä¸ªäºŒè¿›åˆ¶åä¸º `cargo-xxx`, åˆ™å¯ä»¥ä½¿ç”¨å­å‘½ä»¤å½¢å¼è°ƒç”¨
    - `cargo xxx`
- ç±»ä¼¼çš„è‡ªå®šä¹‰å‘½ä»¤å¯ä»¥é€šè¿‡ `cargo --list` åˆ—å‡º

### æ™ºèƒ½æŒ‡é’ˆ

- æ™ºèƒ½æŒ‡é’ˆé€šå¸¸ä½¿ç”¨ `struct` å®ç°, å¹¶ä¸”å®ç°äº† `Deref` å’Œ `Drop` è¿™ä¸¤ä¸ª `trait`
    - `Deref`: å…è®¸æ™ºèƒ½æŒ‡é’ˆ `struct` å®ä¾‹åƒå¼•ç”¨ä¸€æ ·ä½¿ç”¨
    - `Drop`: å…è®¸è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆå®ä¾‹èµ°å‡ºä½œç”¨åŸŸæ—¶çš„ä»£ç 
- å€Ÿç”¨
    - ä½¿ç”¨ `&`
    - æŒ‡å‘å®ƒå€Ÿç”¨çš„å€¼
    - æ²¡æœ‰é¢å¤–å¼€é”€
    - æœ€å¸¸è§çš„æŒ‡é’ˆç±»å‹
- æ™ºèƒ½æŒ‡é’ˆ
    - è¡Œä¸ºå’ŒæŒ‡é’ˆç±»ä¼¼
    - æœ‰é¢å¤–çš„å…ƒæ•°æ®å’ŒåŠŸèƒ½

|          | `Box<T>` | `Rc<T>` | `RefCell<T>` |  
|----------|----------|---------|--------------|
| åŒä¸€æ•°æ®çš„æ‰€æœ‰è€… | ä¸€ä¸ª       | å¤šä¸ª      | ä¸€ä¸ª           |
| å¯å˜æ€§      | å¯å˜/ä¸å¯å˜   | ä¸å¯å˜     | å¯å˜/ä¸å¯å˜       |
| å€Ÿç”¨æ£€æŸ¥     | ç¼–è¯‘æ—¶æ£€æŸ¥    | ç¼–è¯‘æ—¶æ£€æŸ¥   | è¿è¡Œæ—¶æ£€æŸ¥        |

å…¶ä¸­: å³ä½¿ `RefCell<T>` æœ¬èº«ä¸å¯å˜, ä½†ä»èƒ½ä¿®æ”¹å…¶ä¸­å­˜å‚¨çš„å€¼

#### Deref & Drop

- `Deref`: `dereference`
    - å‡½æ•°å’Œæ–¹æ³•çš„éšå¼è§£å¼•ç”¨è½¬åŒ– `Deref Coercion`
    - å‡è®¾ `T` å®ç°äº† `Deref trait`
        - `Deref Coercion` å¯ä»¥æŠŠ `T` çš„å¼•ç”¨è½¬åŒ–ä¸º `T` ç»è¿‡ `Deref` æ“ä½œåç”Ÿæˆçš„å¼•ç”¨
    - å½“æŠŠæŸç±»å‹çš„å¼•ç”¨ä¼ é€’ç»™å‡½æ•°æˆ–æ–¹æ³•æ—¶, ä½†å®ƒçš„ç±»å‹ä¸å®šä¹‰çš„å‚æ•°ç±»å‹ä¸åŒ¹é…
        - `Deref Coercion` ä¼šè‡ªåŠ¨å‘ç”Ÿ. ç¼–è¯‘å™¨ä¼šå¯¹ `deref` è¿›è¡Œä¸€ç³»åˆ—è°ƒç”¨, è½¬æ¢ä¸ºæ‰€éœ€çš„å‚æ•°ç±»å‹. (ç¼–è¯‘æ—¶å®Œæˆ, æ— é¢å¤–å¼€é”€)
    - è§£å¼•ç”¨ä¸å¯å˜æ€§
        - å¯ä»¥ä½¿ç”¨ `DerefMut trait` é‡è½½å¯å˜å¼•ç”¨çš„ `*` è¿ç®—ç¬¦
        - åœ¨ç±»å‹å’Œ `trait` åœ¨ä»¥ä¸‹ä¸‰ç§æƒ…å†µå‘ç”Ÿæ—¶, **Rust** ä¼šæ‰§è¡Œ `deref coercion`
            - å½“ `T: Deref<Target = U>`, å…è®¸ `&T` è½¬æ¢ä¸º `&U`
            - å½“ `T: DerefMut<Target = U>`, å…è®¸ `&mut T` è½¬æ¢ä¸º `&mut U`
            - å½“ `T: Deref<Target = U>`, å…è®¸ `&mut T` è½¬æ¢ä¸º `&U`
- `Drop`: `destructor`
    - å®ç° `Drop trait`, å¯ä»¥è‡ªå®šä¹‰å½“å€¼å°†è¦ç¦»å¼€ä½œç”¨åŸŸæ—¶å‘ç”Ÿçš„åŠ¨ä½œ
    - `Drop trait` åªè¦æ±‚å®ç° `drop` æ–¹æ³•
        - å‚æ•°: å¯¹ `self` çš„å¯å˜å¼•ç”¨
    - **Rust** ä¸å…è®¸æ‰‹åŠ¨è°ƒç”¨ `Drop trait` çš„ `drop` æ–¹æ³•
    - å¯ä»¥é€šè¿‡è°ƒç”¨æ ‡å‡†åº“çš„ `std::mem::drop` å‡½æ•°, æå‰ `drop` æŸä¸ªå˜é‡

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        Self(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = (T);
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T> Drop for MyBox<T> {
    fn drop(&mut self) {
        println!("i`m going to be dropped!");
    }
}

fn say_hello(name: &str) {
    println!("hello {}", name);
}

fn deref_drop_example() {
    let x = 5;
    let my_box = MyBox::new(x);

    assert_eq!(x, 5);
    assert_eq!(*my_box, 5);
    // â†‘ æ­¤å¤„ *my_box å³ä¸º *(my_box.deref()), ç±»ä¼¼äºè¿ç®—ç¬¦é‡è½½

    let my_name = MyBox::new(String::from("lopo"));

    // &my_name -> &MyBox<String> ç±»å‹
    // è‡ªåŠ¨æ‰§è¡Œ deref -> &String
    // ç”±äº String ç±»å‹å®ç°äº† Deref trait
    // å†æ¬¡è‡ªåŠ¨æ‰§è¡Œ deref -> &str
    say_hello(&my_name);
}
```

#### Box<T>

- `Box<T>` æ˜¯æœ€ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆ(ç±»ä¼¼é“¾è¡¨)
- å…è®¸åœ¨ `heap` ä¸Šå­˜å‚¨æ•°æ®
- `stack` ä¸Šåªå­˜å‚¨äº†æŒ‡å‘ `heap` æ•°æ®çš„æŒ‡é’ˆ
- æ²¡æœ‰æ€§èƒ½å¼€é”€, ä½†ä¹Ÿæ²¡æœ‰å…¶ä»–é¢å¤–åŠŸèƒ½
- å®ç°äº† `Deref trait` å’Œ `Drop trait`
- ä½¿ç”¨åœºæ™¯
    - ç¼–è¯‘æ—¶æŸç±»å‹çš„å¤§å°æ— æ³•ç¡®å®š, ä½†ä½¿ç”¨è¯¥ç±»å‹çš„æ—¶å€™ä¸Šä¸‹æ–‡å´éœ€è¦çŸ¥é“å®ƒçš„ç¡®åˆ‡å¤§å°
    - æœ‰å¤§é‡æ•°æ®æƒ³ç§»äº¤æ‰€æœ‰æƒä½†éœ€è¦ç¡®ä¿åœ¨æ“ä½œæ—¶æ•°æ®ä¸ä¼šè¢«å¤åˆ¶
    - ä½¿ç”¨æŸä¸ªå€¼çš„æ—¶å€™åªå…³å¿ƒå…¶æ˜¯å¦å®ç°äº†ç‰¹å®šçš„ `trait`, è€Œä¸å…³å¿ƒå…¶å…·ä½“ç±»å‹

```rust
enum List {
    Node(i32, Box<List>),
    End,
}

fn box_example() {
    let demo_list = List::Node(1, Box::new(Node(2, Box::new(List::End))));
}
```

#### Rc<T>

- é€šè¿‡ä¸å¯å˜å¼•ç”¨, åœ¨ç¨‹åºä¸åŒéƒ¨åˆ†ä¹‹é—´å…±äº«åªè¯»æ•°æ®
- åœ¨æ²¡æœ‰ä»»ä½•æ‰€æœ‰è€…æ—¶è‡ªåŠ¨æ¸…ç†æ•°æ®
- ä½¿ç”¨åœºæ™¯
    - éœ€è¦åœ¨ `heap` ä¸Šåˆ†é…æ•°æ®, è¿™äº›æ•°æ®è¢«ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†è¯»å–(åªè¯»), ä½†åœ¨ç¼–è¯‘é˜¶æ®µæ— æ³•ç¡®å®šå“ªä¸ªéƒ¨åˆ†æœ€åä½¿ç”¨å®Œè¿™äº›æ•°æ®
    - `Rc<T>` åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯
- `Rc::clone(&xx)` vs `xx.clone()`
    - `Rc::clone(&xx)`: å¢åŠ å¼•ç”¨è®¡æ•°, ä¸ä¼šæ‰§è¡Œæ•°æ®æ·±æ‹·è´
    - `xx.clone()`: å¾ˆå¤šä¼šæ‰§è¡Œæ•°æ®çš„æ·±æ‹·è´

```rust
enum List {
    Node(i32, Rc<List>),
    Nil,
}

use std::rc::Rc;
use List::{Node, Nil};

fn rc_example() {
    let a = Rc::new(Node(1,
                         Rc::new(Node(2,
                                      Rc::new(Nil))
                         ),
    ));
    println!("strong ref count: {}", Rc::strong_count(&a));  // 1

    let b = Node(3, Rc::clone(&a));
    println!("strong ref count: {}", Rc::strong_count(&a));  // 2

    {
        let c = Node(4, Rc::clone(&a));
        println!("strong ref count: {}", Rc::strong_count(&a));  // 3
    }

    println!("strong ref count: {}", Rc::strong_count(&a));  // 2
}
```

#### RefCell

- ä¸ `Rc<T>` ä¸€æ ·, åªé€‚ç”¨äºå•çº¿ç¨‹åœºæ™¯
- ä¸ `Rc<T>` ä¸åŒ, `RefCell<T>` ç±»å‹ä»£è¡¨äº†å…¶æŒæœ‰æ•°æ®çš„å”¯ä¸€æ‰€æœ‰æƒ
- å†…éƒ¨å¯å˜æ€§ `interior mutability`
    - å†…éƒ¨å¯å˜æ€§æ˜¯ **Rust** çš„è®¾è®¡æ¨¡å¼ä¹‹ä¸€
    - å…è®¸åœ¨åªæŒæœ‰ä¸å¯å˜å¼•ç”¨çš„å‰æä¸‹å¯¹æ•°æ®è¿›è¡Œä¿®æ”¹(æ•°æ®ç»“æ„ä¸­ä½¿ç”¨äº† `unsafe` ä»£ç æ¥ç»•è¿‡ **Rust** æ­£å¸¸çš„å¯å˜æ€§å’Œå€Ÿç”¨è§„åˆ™)
- ä½¿ç”¨ `RefCell<T>` åœ¨è¿è¡Œæ—¶è®°å½•å€Ÿç”¨ä¿¡æ¯
    - ä¸¤ä¸ªæ–¹æ³•(å®‰å…¨æ¥å£)
        - `borrow`: è¿”å›æ™ºèƒ½æŒ‡é’ˆ `Ref<T>`, å®ƒå®ç°äº† `Deref`
        - `borrow_mut`: è¿”å›æ™ºèƒ½æŒ‡é’ˆ `RefMut<T>`, å®ƒå®ç°äº† `Deref`
    - `RefCell<T>` ä¼šè®°å½•å½“å‰å­˜åœ¨å¤šå°‘æ´»è·ƒçš„ `Ref<T>` å’Œ `RefMut<T>` æ™ºèƒ½æŒ‡é’ˆ. ä»¥æ­¤æŠ€æœ¯æ¥ç»´æŠ¤å€Ÿç”¨æ£€æŸ¥è§„åˆ™
        - æ¯æ¬¡è°ƒç”¨ `borrow`, ä¸å¯å˜å€Ÿç”¨è®¡æ•° `+1`
        - ä»»ä½•ä¸€ä¸ª `Ref<T>` çš„å€¼ç¦»å¼€ä½œç”¨åŸŸè¢«é‡Šæ”¾æ—¶, ä¸å¯å˜å€Ÿç”¨è®¡æ•° `-1`
        - æ¯æ¬¡è°ƒç”¨ `borrow_mut`, å¯å˜å€Ÿç”¨è®¡æ•° `+1`
        - ä»»ä½•ä¸€ä¸ª `RefMut<T>` çš„å€¼ç¦»å¼€ä½œç”¨åŸŸè¢«é‡Šæ”¾æ—¶, å¯å˜å€Ÿç”¨è®¡æ•° `-1`
- å¯ä»¥ä½¿ç”¨ `Rc<T>` å’Œ `RefCell<T>` åˆ›å»ºæ‹¥æœ‰å¤šä¸ªå¯å˜å¼•ç”¨çš„æ•°æ®ç»“æ„(ä¾‹: `Rc<RefCell<T>>`)
- å…¶ä»–å®ç°å†…éƒ¨å¯å˜æ€§çš„ç±»å‹
    - `Cell<T>` é€šè¿‡å¤åˆ¶æ¥è®¿é—®æ•°æ®
    - `Mutex<T>` ç”¨äºå®ç°è·¨çº¿ç¨‹æƒ…å†µä¸‹çš„å†…éƒ¨å¯å˜æ€§æ¨¡å¼

```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: 'a + Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
    where T: Messenger {
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;
    }
}

#[cfg(test)]
mod refcell_example {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, msg: &str) {
            // ä½¿ç”¨ borrow_mut æ–¹æ³•è·å–å¯å˜å€Ÿç”¨
            self.sent_messages.borrow_mut().push(String::from(msg));
        }
    }
}
```

### å¤šçº¿ç¨‹

- `concurrent`: ç¨‹åºä¸åŒéƒ¨åˆ†ä¹‹é—´ç‹¬ç«‹çš„æ‰§è¡Œ(å¹¶å‘)
- `parallel`: ç¨‹åºä¸åŒéƒ¨åˆ†ä¹‹é—´åŒæ—¶è¿è¡Œ(å¹¶è¡Œ)

#### è¿›ç¨‹å’Œçº¿ç¨‹

- å¤§éƒ¨åˆ†OSä¸­, ä»£ç è¿è¡Œåœ¨è¿›ç¨‹(`process`)ä¸­, OSåŒæ—¶ç®¡ç†å¤šä¸ªè¿›ç¨‹
- ç¨‹åºä¸­å„ä¸ªç‹¬ç«‹çš„éƒ¨åˆ†å¯ä»¥åŒæ—¶è¿è¡Œ, è¿™äº›ç‹¬ç«‹éƒ¨åˆ†å°±æ˜¯çº¿ç¨‹(`thread`)
- å¤šçº¿ç¨‹è¿è¡Œ
    - æå‡æ€§èƒ½è¡¨ç°
    - å¢åŠ å¤æ‚æ€§: æ— æ³•ä¿éšœå„çº¿ç¨‹çš„æ‰§è¡Œé¡ºåº
    - å¯¼è‡´çš„é—®é¢˜
        - ç«äº‰çŠ¶æ€
        - æ­»é”
- å®ç°çº¿ç¨‹çš„æ–¹å¼
    - è°ƒç”¨OSçš„APIåˆ›å»ºçº¿ç¨‹: `1:1` æ¨¡å‹ (éœ€è¦è¾ƒå°çš„è¿è¡Œæ—¶)
    - è¯­è¨€è‡ªå·±å®ç°çš„çº¿ç¨‹(ç»¿è‰²çº¿ç¨‹): `M:N` æ¨¡å‹ (éœ€è¦æ›´å¤§çš„è¿è¡Œæ—¶)
    - **Rust** æ ‡å‡†åº“ä»…æä¾› `1:1` æ¨¡å‹çš„çº¿ç¨‹

#### å¤šçº¿ç¨‹æ‰§è¡Œ

- ä½¿ç”¨ `thread::spawn` åˆ›å»ºæ–°çº¿ç¨‹, å…¶è¿”å›å€¼ç±»å‹ä¸º `JoinHandle`
- `JoinHandle` æŒæœ‰å€¼çš„æ‰€æœ‰æƒ, è°ƒç”¨å…¶ `join` æ–¹æ³•å¯ä»¥ç­‰å¾…å¯¹åº”çº¿ç¨‹å®Œæˆ
- `join` æ–¹æ³•: è°ƒç”¨ `handle` çš„ `join` æ–¹æ³•ä¼šé˜»æ­¢å½“å‰çº¿ç¨‹çš„è¿è¡Œ, ç›´åˆ° `handle` æ‰€è¡¨ç¤ºçš„çº¿ç¨‹è¿è¡Œç»“æŸ
- ä½¿ç”¨ `move` é—­åŒ…
    - `move` é—­åŒ…é€šå¸¸å’Œ `thread::spawn` ä¸€èµ·ä½¿ç”¨, å…è®¸ä½¿ç”¨å…¶ä»–çº¿ç¨‹çš„å€¼

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("from spawned thread: {}", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("from main thread: {}", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}

fn move_example() {
    let v = vec![1, 2, 3];

    // ä½¿ç”¨ move å°† v çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°é—­åŒ…ä¸­
    let handle = thread::spawn(move || {
        println("vector from main thread: {}", v);
    });

    handle.join().unwrap();
}
```

#### æ¶ˆæ¯ä¼ é€’

- ä¸€ç§å¾ˆæµè¡Œä¸”èƒ½ä¿è¯å®‰å…¨å¹¶å‘çš„æŠ€æœ¯: æ¶ˆæ¯ä¼ é€’, çº¿ç¨‹(æˆ– `actor`)é€šè¿‡å½¼æ­¤å‘é€æ¶ˆæ¯æ¥è¿›è¡Œé€šä¿¡
- `Channel`
    - åŒ…å«: å‘é€ç«¯ã€æ¥æ”¶ç«¯
    - è°ƒç”¨å‘é€ç«¯æ¥æ”¶æ•°æ®, æ¥æ”¶ç«¯æ£€æŸ¥å’Œæ¥å—åˆ°è¾¾çš„æ•°æ®
    - å¦‚æœä»»æ„ä¸€ç«¯è¢«ä¸¢å¼ƒ, åˆ™è¯¥ `Channel` å°±è¢« 'å…³é—­' äº†
- åˆ›å»º `Channel`
    - ä½¿ç”¨ `mpsc::channel` å‡½æ•°åˆ›å»º `Channel`
        - `mpsc` è¡¨ç¤º `multiple producer, single consumer`
        - è¿”å›ä¸€ä¸ª `tuple`, é‡Œé¢çš„å…ƒç´ ä¸º `(sender, receiver)`
    - å‘é€ç«¯æ–¹æ³•
        - å‚æ•°: è¦å‘é€çš„æ•°æ®
        - è¿”å›: `Result<T, E>`
            - å¦‚æœæœ‰é—®é¢˜(å¦‚æ¥æ”¶ç«¯å·²è¢«ä¸¢å¼ƒ), å°±è¿”å›ä¸€ä¸ªé”™è¯¯
        - å¯ä»¥é€šè¿‡å…‹éš†åˆ›å»ºå¤šä¸ªå‘é€è€… `mpsc::Sender::clone(&sender);`
    - æ¥æ”¶ç«¯æ–¹æ³•
        - `recv` æ–¹æ³•: é˜»æ­¢å½“å‰çº¿ç¨‹æ‰§è¡Œ, ç›´åˆ° `Channel` ä¸­æœ‰å€¼è¢«å‘é€è¿‡æ¥
            - ä¸€æ—¦æœ‰å€¼æ”¶åˆ°, å°±è¿”å› `Result<T, E>`
            - å½“å‘é€ç«¯å…³é—­, å°±ä¼šæ”¶åˆ°ä¸€ä¸ªé”™è¯¯
        - `try_recv` æ–¹æ³•: ä¸ä¼šé˜»å¡
            - ç«‹å³è¿”å› `Result<T, E>`
                - æœ‰æ•°æ®åˆ°è¾¾, è¿”å› `Ok`, é‡Œé¢åŒ…å«æ•°æ®
                - å¦åˆ™è¿”å›é”™è¯¯
            - é€šå¸¸ä½¿ç”¨å¾ªç¯è°ƒç”¨æ¥æ£€æŸ¥ `try_recv` çš„ç»“æœ

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (sender, receiver) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");

        // val çš„æ‰€æœ‰æƒè¢«å‘é€, ä¹‹åæ— æ³•å†ä½¿ç”¨ val
        sender.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("got: {}", received);
    // got: hi
}

fn recv_example() {
    let (sender, receiver) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("one"),
            String::from("two"),
            String::from("three"),
            String::from("four"),
        ];

        for val in vals {
            sender.send(val).unwrap();
            thread::sleep(Duration::from_millis(200));
        }
    });

    // ä½¿ç”¨å¾ªç¯è°ƒç”¨
    // receiver ä¼šä¾æ¬¡ç­‰å¾…ä¿¡æ¯, å½“ sender è¢«ä¸¢å¼ƒå°±ä¼šé€€å‡ºå¾ªç¯
    for received in receiver {
        println!("got: {}", received);
    }

    // é—´éš” 200ms æ‰“å°ä¸€æ¡
    // got: one
    // got: two
    // got: three
    // got: four
}
```

#### å…±äº«å®ç°å¹¶å‘

- `channel` ç±»ä¼¼å•æ‰€æœ‰æƒ: ä¸€æ—¦å°†å€¼çš„æ‰€æœ‰æƒè½¬ç§»åˆ° `channel`, å°±æ— æ³•å†ä½¿ç”¨å®ƒ
- **Rust** æ”¯æŒé€šè¿‡å…±äº«çŠ¶æ€æ¥å®ç°å¹¶å‘. å…±äº«å†…å­˜å¹¶å‘ç±»ä¼¼å¤šæ‰€æœ‰æƒ: å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è®¿é—®ä¸€å—å†…å­˜
- ä½¿ç”¨ `Mutex`(äº’æ–¥é”, `mutual exclusion`) ä½¿æ¯æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è®¿é—®æ•°æ®
    - åœ¨ä½¿ç”¨æ•°æ®å‰å¿…é¡»å…ˆè·å–äº’æ–¥é”
    - ä½¿ç”¨å®Œåå¿…é¡»è§£é”ä»¥ä¾¿å…¶ä»–çº¿ç¨‹è·å–æ•°æ®
    - é€šè¿‡ `Mutex::new(data)` æ¥åˆ›å»º `Mutex<T>`(æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆ)
    - è®¿é—®æ•°æ®å‰é€šè¿‡ `lock` æ–¹æ³•è·å–é”
        - ä¼šé˜»å¡å½“å‰çº¿ç¨‹
        - `lock` å¯èƒ½ä¼šå¤±è´¥
        - è¿”å›çš„æ˜¯ `MutexGuard` (æ™ºèƒ½æŒ‡é’ˆ, å®ç°äº† `Deref` å’Œ `Drop`)
- ä½¿ç”¨ `Arc<T>` (`atomic reference count`) è¿›è¡ŒåŸå­å¼•ç”¨è®¡æ•°
    - `Arc<T>` å’Œ `Rc<T>` ç±»ä¼¼, å¯ä»¥ç”¨äºå¹¶å‘åœºæ™¯
- `RefCell<T>/Rc<T>` vs `Mutex<T>/Arc<T>`
    - `Mutex<T>` æä¾›äº†å†…éƒ¨å¯å˜æ€§, å’Œ `Cell` å®¶æ—ä¸€æ ·
    - å¯ä»¥ä½¿ç”¨ `RefCell<T>` æ¥æ”¹å˜ `Rc<T>` é‡Œçš„å†…å®¹
    - å¯ä»¥ä½¿ç”¨ `Mutex<T>` æ¥æ”¹å˜ `Arc<T> é‡Œçš„å†…å®¹
    - æ³¨æ„: `Mutex<T>` æœ‰æ­»é”é£é™©

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        // ä½¿ç”¨ lock è·å–é”
        let mut num = m.lock().unwrap();
        // å¯ä¿®æ”¹
        *num = 6;

        // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨è§£é”
    }

    println!("m = {:?}", m);
    // m = Mutex { data: 6 }
}
```

#### Send å’Œ Sync

- **Rust** ä¸­æœ‰ä¸¤ä¸ªå¹¶å‘æ¦‚å¿µ: `std::marker::Sync` å’Œ `std::marker::Send`
- `Send`: å…è®¸çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ
    - å®ç°äº† `Send trait` çš„ç±»å‹å¯ä»¥åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ
    - **Rust** ä¸­å‡ ä¹æ‰€æœ‰ç±»å‹éƒ½å®ç°äº† `Send`
        - ä½† `Rc<T>` æ²¡æœ‰å®ç° `Send`, å®ƒåªç”¨äºå•çº¿ç¨‹åœºæ™¯
    - å®Œå…¨ç”± `Send` ç±»å‹æ ‡è®°çš„ç±»å‹ä¹Ÿè¢«æ ‡è®°ä¸º `Send`
    - é™¤äº†åŸå§‹æŒ‡é’ˆå¤–, å‡ ä¹æ‰€æœ‰åŸºç¡€ç±»å‹éƒ½æ˜¯ `Send`
- `Sync`: å…è®¸ä»å¤šçº¿ç¨‹è®¿é—®
    - å®ç°äº† `Sync trait` çš„ç±»å‹å¯ä»¥å®‰å…¨åœ°è¢«å¤šä¸ªçº¿ç¨‹å¼•ç”¨
    - å¦‚æœ `T` æ˜¯ `Sync`, é‚£ä¹ˆ `&T` å°±æ˜¯ `Send` (å¼•ç”¨å¯ä»¥è¢«å®‰å…¨åœ°é€å¾€å¦ä¸€ä¸ªçº¿ç¨‹)
    - åŸºç¡€ç±»å‹éƒ½æ˜¯ `Sync`
    - å®Œå…¨ç”± `Sync` ç±»å‹æ ‡è®°çš„ç±»å‹ä¹Ÿè¢«æ ‡è®°ä¸º `Sync`
        - ä½† `Rc<T>` ä¸æ˜¯ `Sync` çš„, å®ƒåªç”¨äºå•çº¿ç¨‹åœºæ™¯
        - `RefCell<T>` å’Œ `Cell<T>` å®¶æ—ä¹Ÿä¸æ˜¯ `Sync` çš„
        - `Mutex<T>` æ˜¯ `Sync` çš„
- æ‰‹åŠ¨å®ç° `Send` å’Œ `Sync` å¾ˆéš¾ä¿è¯å®‰å…¨

### é¢å‘å¯¹è±¡

- å°è£…
    - **Rust** ä½¿ç”¨ `struct` å°è£…å±æ€§, `impl` å°è£…æ–¹æ³•
- ç»§æ‰¿
    - **Rust** æ²¡æœ‰ç»§æ‰¿, ä½†ä½¿ç”¨ `trait` å®ç°ä»£ç å…±äº«
- å¤šæ€
    - **Rust** ä½¿ç”¨æ³›å‹å’Œ `trait` çº¦æŸ
- `trait` å¯¹è±¡å¿…é¡»æ»¡è¶³å¯¹è±¡å®‰å…¨(`object-safe`)
    - æ–¹æ³•è¿”å›çš„ç±»å‹ä¸æ˜¯ `Self`
    - æ–¹æ³•ä¸­ä¸åŒ…å«ä»»ä½•æ³›å‹ç±»å‹å‚æ•°
- çŠ¶æ€æ¨¡å¼(`state pattern`)
    - æ˜¯ä¸€ç§é¢å‘å¯¹è±¡è®¾è®¡æ¨¡å¼
    - ä¸€ä¸ªå€¼æ‹¥æœ‰çš„å†…éƒ¨çŠ¶æ€ç”±æ•°ä¸ªçŠ¶æ€å¯¹è±¡(`state object`)è¡¨è¾¾è€Œæˆ, è€Œå€¼çš„è¡Œä¸ºåˆ™éšç€å†…éƒ¨çŠ¶æ€çš„æ”¹å˜è€Œæ”¹å˜
    - ä¸šåŠ¡éœ€æ±‚å˜åŒ–æ—¶, ä¸éœ€è¦ä¿®æ”¹æŒæœ‰çŠ¶æ€çš„å€¼çš„ä»£ç æˆ–è€…ä½¿ç”¨è¿™ä¸ªå€¼çš„ä»£ç 
    - åªéœ€è¦æ›´æ–°çŠ¶æ€å¯¹è±¡å†…éƒ¨çš„ä»£ç , ä»¥ä¾¿æ”¹å˜å…¶è§„åˆ™; æˆ–è€…å¢åŠ ä¸€äº›æ–°çš„çŠ¶æ€å¯¹è±¡

### æ¨¡å¼åŒ¹é…

- æ¨¡å¼æ˜¯ **Rust** ä¸­çš„ä¸€ç§ç‰¹æ®Šè¯­æ³•, ç”¨äºåŒ¹é…å¤æ‚å’Œç®€å•ç±»å‹çš„ç»“æ„
- å°†æ¨¡å¼ä¸åŒ¹é…è¡¨è¾¾å¼å’Œå…¶ä»–æ„é€ ç»“åˆä½¿ç”¨èƒ½æ›´å¥½åœ°æ§åˆ¶ç¨‹åºçš„æ§åˆ¶æµ
- æ¨¡å¼ç”±ä»¥ä¸‹å…ƒç´ (çš„ä¸€äº›ç»„åˆ)ç»„æˆ
    - å­—é¢é‡
    - è§£æ„çš„æ•°ç»„ã€`enum`ã€`struct`ã€`tuple`
    - å˜é‡
    - é€šé…ç¬¦
    - å ä½ç¬¦
- å¦‚æœè¦ä½¿ç”¨æ¨¡å¼, å°±è¦å°†å…¶ä¸æŸä¸ªå€¼è¿›è¡Œæ¯”è¾ƒ
    - å¦‚æœæ¨¡å¼åŒ¹é…, å°±èƒ½ä½¿ç”¨è¿™ä¸ªå€¼çš„ç›¸åº”éƒ¨åˆ†

#### æ¨¡å¼

- `match`
    - è¦æ±‚: ç©·å°½(åˆ†æ”¯å¿…é¡»åŒ…å«æ‰€æœ‰çš„å¯èƒ½æ€§)
    - ä¸€ä¸ªç‰¹æ®Šçš„æ¨¡å¼: `_`
        - å®ƒä¼šåŒ¹é…ä»»æ„å†…å®¹
        - ä¸ä¼šç»‘å®šåˆ°å˜é‡
        - é€šå¸¸ç”¨äº `match` çš„æœ€åä¸€ä¸ªåˆ†æ”¯, æˆ–ç”¨äºå¿½ç•¥æŸäº›å€¼
- `if let`
    - ä¸»è¦ä½œä¸ºç®€çŸ­çš„æ–¹å¼æ¥ç­‰ä»·çš„æ›¿ä»£åªæœ‰ä¸€ä¸ªåŒ¹é…é¡¹çš„ `match`
    - å¯é€‰åœ°å¯ä»¥æ‹¥æœ‰ `else`, `else if`, `else if let`
    - ä¸ä¼šæ£€æŸ¥ç©·å°½æ€§
- `while let`
    - åªè¦æ¨¡å¼æ»¡è¶³åŒ¹é…çš„æ¡ä»¶, å¾ªç¯å°±ä¼šä¸€ç›´è¿è¡Œ
- `for`
    - `for` å¾ªç¯ä¸­, æ¨¡å¼å°±æ˜¯ç´§éš `for` å…³é”®å­—åçš„å€¼
- `let`
    - `let` ä¹Ÿæ˜¯æ¨¡å¼, `let PATTERN = EXPRESSION;`
- å‡½æ•°å‚æ•°
    - å‚æ•°ä¹Ÿå¯ä»¥æ˜¯æ¨¡å¼(ç±»ä¼¼ `javascript` ç›´æ¥å½¢å‚è§£æ„å†™æ³•)

#### å¯è¾©é©³æ€§

- æ— å¯è¾©é©³çš„: èƒ½åŒ¹é…ä»»ä½•å¯èƒ½ä¼ é€’çš„å€¼ (ä¾‹: `let x = 5;`)
- å¯è¾¨é©³çš„: å¯¹æŸäº›å¯èƒ½çš„å€¼, æ— æ³•è¿›è¡ŒåŒ¹é… (ä¾‹: `if let Some(x) = 5`)
- å‡½æ•°å‚æ•°ã€`let` è¯­å¥ã€`for` å¾ªç¯åªæ¥å—æ— å¯è¾©é©³çš„æ¨¡å¼
- `if let`ã€`while let` æ¥å—å¯è¾¨é©³å’Œæ— å¯è¾©é©³(ä¼š`warning`)çš„æ¨¡å¼

#### æ¨¡å¼(åŒ¹é…)è¯­æ³•

- å­—é¢é‡: å¯ä»¥ç›´æ¥åŒ¹é…
- å‘½åå˜é‡: æ˜¯å¯åŒ¹é…ä»»ä½•å€¼çš„æ— å¯è¾©é©³æ¨¡å¼
- å¤šé‡æ¨¡å¼: åœ¨ `match` è¡¨è¾¾å¼ä¸­, ä½¿ç”¨ `|` è¯­æ³•è¡¨ç¤ºæˆ–, ç”¨äºåŒ¹é…å¤šç§æ¨¡å¼
- èŒƒå›´åŒ¹é…: ä½¿ç”¨ `..=` åŒ¹é…èŒƒå›´å€¼
- è§£æ„ä»¥åˆ†è§£å€¼(åŒ `javascript`, `ES6` è§£æ„è¯­æ³•): å¯ä»¥ä½¿ç”¨æ¨¡å¼æ¥è§£æ„ `struct`, `enum`, `tuple` ä»è€Œå¼•ç”¨è¿™äº›å€¼çš„ä¸åŒéƒ¨åˆ†
- åœ¨æ¨¡å¼ä¸­å¿½ç•¥å€¼
    - `_` å¿½ç•¥æ•´ä¸ªå€¼
    - ä»¥ `_` å¼€å¤´çš„åç§°å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡
    - ä»¥ `..` ç»“å°¾å¿½ç•¥å‰©ä½™éƒ¨åˆ† (ç±»ä¼¼ `javascript` çš„ `...` å‰©ä½™è¿ç®—ç¬¦)
- ä½¿ç”¨ `match` å®ˆå«æä¾›é¢å¤–æ¡ä»¶
    - åœ¨ `match` åˆ†æ”¯çš„æ¨¡å¼åæ·»åŠ é¢å¤–çš„ `if` æ¡ä»¶
- `@` ç»‘å®š
    - `@` ç¬¦å·å¯ä»¥åˆ›å»ºä¸€ä¸ªå˜é‡, è¯¥å˜é‡å¯ä»¥åœ¨æµ‹è¯•æŸä¸ªå€¼æ˜¯å¦ä¸æ¨¡å¼åŒ¹é…çš„åŒæ—¶ä¿å­˜è¯¥å€¼

```rust
fn pattern_example() {
    // å­—é¢é‡
    let a = 3;
    match a {
        1 => println!("1"),
        2 => println!("2"),
        3 => println!("3"),  // âˆš
        _ => println!("other")
    }

    // å‘½åå˜é‡
    let b = Some(1);
    if let Some(c) = b {
        println!("c is {}", c);  // c is 1
    }

    // å¤šé‡æ¨¡å¼
    let d = 1;
    match d {
        1 | 2 => println!("1 or 2"),
        _ => println!("< 1 or > 2"),
    }

    // èŒƒå›´åŒ¹é…
    let e = 3;
    match e {
        1..=5 => println!("in [1, 5]"),
        _ => println!("in (-âˆ, 1) or (5, +âˆ)"),
    }
    let f = 'w';
    match f {
        'a'..='k' => println!("in [a, k]"),
        _ => println!("other"),
    }

    // è§£æ„ä»¥åˆ†è§£å€¼
    let g = (0, '1', "two");
    let (g1, g2, g3) = g;
    assert_eq!(0, g1);
    assert_eq!('1', g2);
    assert_eq!("two", g3);

    // match å®ˆå«
    let h = Some(3);
    match h {
        Some(x) if x > 0 => println!("x is greater then 0"),
        _ => println!("other"),
    }

    // @ ç»‘å®š
    struct Bind {
        val: i32
    }
    let i = Bind { val: 3 };
    match i {
        Bind { val: real_val @ 0..=10 } => println!("i is {}", real_val),
        Bind { val: 11..=20 } => println!("val in [11, 20]"),
        _ => println!("other"),
    }
}
```

### é«˜çº§ç‰¹æ€§

#### unsafe

- å’Œæ™®é€šçš„ **Rust** ä¸€æ ·, ä½†æä¾›äº†é¢å¤–çš„åŠŸèƒ½
- å­˜åœ¨çš„åŸå› 
    - é™æ€åˆ†ææ˜¯ä¿å®ˆçš„
    - ä½¿ç”¨ `unsafe rust`, å¼€å‘è€…çŸ¥é“å‘ç”Ÿçš„è¡Œä¸ºå¹¶æ‰¿æ‹…ç›¸åº”é£é™©
    - è®¡ç®—æœºç¡¬ä»¶æœ¬èº«å°±æ˜¯ä¸å®‰å…¨çš„, **Rust** éœ€è¦èƒ½å¤Ÿè¿›è¡Œåº•å±‚ç³»ç»Ÿç¼–ç¨‹
- ä½¿ç”¨ `unsafe` å…³é”®å­—å¼€å¯ä¸€ä¸ªå—, é‡Œé¢æ”¾ `unsafe` ä»£ç . å¯ä»¥æ‰§è¡Œå››ä¸ªåŠ¨ä½œ
    - è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
        - åŸå§‹æŒ‡é’ˆ (`raw pointer`)
            - å¯å˜çš„: `*mut T`
            - ä¸å¯å˜çš„: `*const T`, (æ„å‘³ç€æŒ‡é’ˆåœ¨è§£å¼•ç”¨åä¸èƒ½ç›´æ¥å¯¹å…¶èµ‹å€¼)
        - ä¸å¼•ç”¨ä¸åŒ
            - åŸå§‹æŒ‡é’ˆå…è®¸é€šè¿‡åŒæ—¶å…·æœ‰å¯å˜å’Œä¸å¯å˜æŒ‡é’ˆæˆ–å¤šä¸ªå¯å˜æŒ‡é’ˆæ¥å¿½ç•¥å€Ÿç”¨è§„åˆ™
            - æ— æ³•ä¿è¯èƒ½æŒ‡å‘åˆç†çš„å†…å­˜
            - å…è®¸ä¸º `null`
            - ä¸å®ç°ä»»ä½•è‡ªåŠ¨æ¸…ç†
        - åŸå› 
            - ä¸Cè¯­è¨€è¿›è¡Œæ¥å£äº¤äº’
            - æ„å»ºå€Ÿç”¨æ£€æŸ¥å™¨æ— æ³•ç†è§£çš„å®‰å…¨æŠ½è±¡
    - è°ƒç”¨ `unsafe` å‡½æ•°æˆ–æ–¹æ³•
        - `unsafe` å‡½æ•°æˆ–æ–¹æ³•: åœ¨å®šä¹‰å‰åŠ ä¸Šäº† `unsafe` å…³é”®å­—
            - è°ƒç”¨å‰éœ€è¦æ‰‹åŠ¨æ»¡è¶³ä¸€äº›æ¡ä»¶(ä¸»è¦é çœ‹æ–‡æ¡£, å› ä¸º **Rust** æ— æ³•å¯¹è¿™äº›æ¡ä»¶è¿›è¡ŒéªŒè¯)
            - éœ€è¦åœ¨ `unsafe` å—é‡Œè¿›è¡Œè°ƒç”¨
        - åˆ›å»º `unsafe` ä»£ç çš„å®‰å…¨æŠ½è±¡
            - å‡½æ•°åŒ…å« `unsafe` ä»£ç ä¸æ„å‘³ç€éœ€è¦å°†æ•´ä¸ªå‡½æ•°æ ‡è®°ä¸º `unsafe`
            - å°† `unsafe` ä»£ç åŒ…è£¹åœ¨å®‰å…¨å‡½æ•°ä¸­æ˜¯ä¸€ä¸ªå¸¸è§çš„æŠ½è±¡
            - ä¾‹: å‚è€ƒæ ‡å‡†åº“å‡½æ•° `split_at_mut`
        - ä½¿ç”¨ `extern` å‡½æ•°è°ƒç”¨å¤–éƒ¨ä»£ç 
            - `extern` å…³é”®å­—: ç®€åŒ–åˆ›å»ºå’Œä½¿ç”¨å¤–éƒ¨å‡½æ•°æ¥å£çš„è¿‡ç¨‹
            - å¤–éƒ¨å‡½æ•°æ¥å£(`FFI, Foreign Function Interface`): å®ƒå…è®¸ä¸€ç§ç¼–ç¨‹è¯­è¨€å®šä¹‰å‡½æ•°, å¹¶è®©å…¶ä»–çš„ç¼–ç¨‹è¯­è¨€è°ƒç”¨è¯¥å‡½æ•°
            - åº”ç”¨äºŒè¿›åˆ¶æ¥å£(`ABI, Application Binary Interface`): å®šä¹‰å‡½æ•°åœ¨æ±‡ç¼–å±‚é¢çš„è°ƒç”¨æ–¹å¼
                - `"C"` æ˜¯æœ€å¸¸è§çš„ **ABI**, å®ƒéµå¾ªCè¯­è¨€çš„ **ABI**
            - ä»å…¶ä»–è¯­è¨€è°ƒç”¨ **Rust** å‡½æ•°
                - ä½¿ç”¨ `extern` åˆ›å»ºæ¥å£, å…¶ä»–è¯­è¨€é€šè¿‡å®ƒä»¬å¯ä»¥è°ƒç”¨ **Rust** çš„å‡½æ•°
                - åœ¨ `fn` å‰æ·»åŠ  `extern` å…³é”®å­—, å¹¶æŒ‡å®š **ABI**
                - è¿˜éœ€è¦æ·»åŠ  `#[no_mangle]` æ³¨è§£: é¿å… **Rust** åœ¨ç¼–è¯‘æ—¶æ”¹å˜å…¶åç§°
    - è®¿é—®æˆ–ä¿®æ”¹å¯å˜çš„é™æ€å˜é‡
        - **Rust** æ”¯æŒå…¨å±€å˜é‡, ä½†å› ä¸ºæ‰€æœ‰æƒæœºåˆ¶å¯èƒ½äº§ç”ŸæŸäº›é—®é¢˜(å¦‚æ•°æ®ç«äº‰)
        - åœ¨ **Rust** ä¸­, å…¨å±€å˜é‡å«åšé™æ€(`static`)å˜é‡
            - ä¸å¸¸é‡ç±»ä¼¼, å‘½åä½¿ç”¨å¤§å†™è›‡å½¢å‘½å
            - å¿…é¡»æ ‡æ³¨ç±»å‹
            - é™æ€å˜é‡åªèƒ½å­˜å‚¨ `'static` ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨, æ— éœ€æ˜¾å¼æ ‡æ³¨
            - è®¿é—®ä¸å¯å˜é™æ€å˜é‡æ˜¯å®‰å…¨çš„
        - å¸¸é‡ vs é™æ€å˜é‡
            - é™æ€å˜é‡: æœ‰å›ºå®šçš„å†…å­˜åœ°å€, ä½¿ç”¨å®ƒçš„å€¼æ€»æ˜¯ä¼šè®¿é—®ç›¸åŒçš„æ•°æ®
            - å¸¸é‡: å…è®¸ä½¿ç”¨å®ƒä»¬çš„æ—¶å€™å¯¹æ•°æ®è¿›è¡Œå¤åˆ¶
            - é™æ€å˜é‡: å¯ä»¥æ˜¯å¯å˜çš„, è®¿é—®å’Œä¿®æ”¹é™æ€å¯å˜å˜é‡æ˜¯ä¸å®‰å…¨(`unsafe`)çš„
    - å®ç° `unsafe trait`
        - å£°æ˜: åœ¨å®šä¹‰å‰æ·»åŠ  `unsafe` å…³é”®å­—, è¯¥ `trait` åªèƒ½åœ¨ `unsafe` å—ä¸­å®ç°
- æ³¨æ„
    - `unsafe` å¹¶æ²¡æœ‰å…³é—­å€Ÿç”¨æ£€æŸ¥æˆ–å…¶ä»–å®‰å…¨æ£€æŸ¥
    - ä»»ä½•å†…å­˜å®‰å…¨ç›¸å…³çš„é”™è¯¯å¿…é¡»ç•™åœ¨ `unsafe` å—ä¸­
    - å°½å¯èƒ½éš”ç¦» `unsafe` ä»£ç , æœ€å¥½å°†å…¶å°è£…åœ¨å®‰å…¨çš„æŠ½è±¡ä¸­, æä¾›å®‰å…¨çš„ `API`

```rust
// è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
fn unsafe_example_raw_pointer() {
    let mut num = 1;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
    unsafe {
        println!("r1: {}", *r1);  // r1: 1
        println!("r2: {}", *r2);  // r2: 1
    }

    let address = 0x012345usize;
    let r = address as *const i32;
    unsafe {
        println!("r: {}", *r);  // å¯èƒ½ä¼šå‡ºç° panic, éæ³•è®¿é—®
    }
}

// è°ƒç”¨ `unsafe` å‡½æ•°æˆ–æ–¹æ³•
unsafe fn dangerous() {}

fn unsafe_example_invoke() {
    unsafe {
        dangerous();
    }
}

#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("hello c, from rust.");
}

// è®¿é—®æˆ–ä¿®æ”¹å¯å˜çš„é™æ€å˜é‡
static mut STATIC_COUNTER: u32 = 0;

fn static_counter_increase() {
    unsafe {
        STATIC_COUNTER += 1;
    }
}

fn unsafe_example_static() {
    unsafe {
        println!("STATIC_COUNTER: {}", STATIC_COUNTER);
    }
}

// å®ç° `unsafe trait`
struct MyUnsafeStruct {}

unsafe trait AnUnsafeTrait {
    // some methods
}

unsafe impl AnUnsafeTrait for MyUnsafeStruct {
    // some implementations
}
```

#### é«˜çº§ trait

- åœ¨ `trait` å®šä¹‰ä¸­ä½¿ç”¨å…³è”ç±»å‹æ¥æŒ‡å®šå ä½ç±»å‹
    - å…³è”ç±»å‹(`associated type`) æ˜¯ `trait` ä¸­çš„ç±»å‹å ä½ç¬¦, å®ƒå¯ä»¥ç”¨äº `trait` çš„æ–¹æ³•ç­¾åä¸­
    - å…³è”ç±»å‹ä¸æ³›å‹çš„åŒºåˆ«

| æ³›å‹                                | å…³è”ç±»å‹                  |
|-----------------------------------|-----------------------|
| æ¯æ¬¡å®ç° `trait` çš„æ—¶å€™æ ‡æ³¨ç±»å‹              | æ— éœ€æ ‡æ³¨ç±»å‹                |
| å¯ä»¥ä¸ºä¸€ä¸ªç±»å‹å¤šæ¬¡å®ç°æŸä¸ª `trait` (ä½¿ç”¨ä¸åŒçš„æ³›å‹å‚æ•°) | æ— æ³•ä¸ºå•ä¸ªç±»å‹å¤šæ¬¡å®ç°æŸä¸ª `trait` |

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

- é»˜è®¤æ³›å‹å‚æ•°å’Œè¿ç®—ç¬¦é‡è½½
    - å¯ä»¥åœ¨ä½¿ç”¨æ³›å‹å‚æ•°æ—¶ä¸ºæ³›å‹æŒ‡å®šä¸€ä¸ªé»˜è®¤çš„å…·ä½“ç±»å‹: `<PlaceholderType = DefaultType>`
    - **Rust** ä¸å…è®¸åˆ›å»ºè‡ªå·±çš„è¿ç®—ç¬¦åŠé‡è½½ä»»æ„çš„è¿ç®—ç¬¦, ä½†æ˜¯å¯ä»¥é€šè¿‡å®ç° `std::ops` ä¸­åˆ—å‡ºçš„é‚£äº› `trait` æ¥é‡è½½ç›¸åº”çš„è¿ç®—ç¬¦
    - é»˜è®¤æ³›å‹å‚æ•°ä¸»è¦ä½¿ç”¨åœºæ™¯
        - æ‰©å±•ä¸€ä¸ªç±»å‹è€Œä¸ç ´åç°æœ‰ä»£ç 
        - å…è®¸å¤§éƒ¨åˆ†ç”¨æˆ·éƒ½ä¸éœ€è¦çš„ç‰¹å®šåœºæ™¯ä¸‹è¿›è¡Œè‡ªå®šä¹‰(å¦‚: è¿ç®—ç¬¦é‡è½½)

```rust
#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn override_ops_example() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };

    let p3 = p1.add(p2);
    println!("p3: {:#?}", p3);
    // p3: Point { x: 4, y: 6 }
}
```

- å®Œå…¨é™å®šè¯­æ³• `Fully Qualified Syntax`
    - `<Type as Trait>::function(receiver_if_method, next_arg, ...);`
    - å¯ä»¥åœ¨ä»»ä½•è°ƒç”¨å‡½æ•°æˆ–æ–¹æ³•çš„åœ°æ–¹ä½¿ç”¨
    - å…è®¸å¿½ç•¥ä»å…¶ä»–ä¸Šä¸‹æ–‡æ¨å¯¼å‡ºæ¥çš„éƒ¨åˆ†
    - å½“ **Rust** æ— æ³•åŒºåˆ†æœŸæœ›ä½¿ç”¨å“ªä¸ªå…·ä½“å®ç°æ—¶, æ‰éœ€è¦ä½¿ç”¨è¿™ç§è¯­æ³•

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        print!("pilot fly!");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        print!("wizard fly!");
    }
}

impl Human {
    fn fly(&self) {
        print!("human fly!");
    }
}

fn fqs_example1() {
    let me = Human;

    me.fly();  // human fly
    Pilot::fly(&me);  // pilot fly
    Wizard::fly(&me);  // wizard fly 
}

trait Animal {
    fn name() -> String;
}

struct Dog {}

impl Dog {
    fn name() {
        String::from("Dog")
    }
}

impl Animal for Dog {
    fn name() {
        String::from("Animal")
    }
}

fn fqs_example2() {
    let name1 = Dog::name();  // Dog
    let name2 = <Dog as Animal>::name();  // Animal
}
```

- ä½¿ç”¨ `supertrait` æ¥è¦æ±‚ `trait` é™„å¸¦å…¶ä»– `trait` çš„åŠŸèƒ½
    - éœ€è¦åœ¨ä¸€ä¸ª `trait` ä¸­ä½¿ç”¨å…¶ä»– `trait` çš„åŠŸèƒ½
        - éœ€è¦è¢«ä¾èµ–çš„ `trait` ä¹Ÿè¢«å®ç°
        - è¢«é—´æ¥ä¾èµ–çš„ `trait` å°±æ˜¯å½“å‰ `trait` çš„ `supertrait`

```rust
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn print_outline(&self) {
        let output = self.to_string();
        // inner code
    }
}

struct Point {
    x: i32,
    y: i32
}

impl OutlinePrint for Point {
    // inner code
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y);
    }
}
```

- ä½¿ç”¨ `newtype` æ¨¡å¼åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ `trait`
    - å­¤å„¿è§„åˆ™: åªæœ‰å½“ `trait` æˆ–ç±»å‹å®šä¹‰åœ¨æœ¬åœ°æ—¶, æ‰èƒ½ä¸ºè¯¥ç±»å‹å®ç°è¯¥ `trait`
    - å¯ä»¥é€šè¿‡ `newtype` æ¨¡å¼ç»•è¿‡è¿™ä¸€è§„åˆ™
        - åˆ©ç”¨ `tuple struct` åˆ›å»ºä¸€ä¸ªæ–°çš„ç±»å‹

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "));
    }
}

fn newtype_example() {
    let w = Wrapper(vec![
        String::from("a"),
        String::from("b"),
        String::from("c"),
        String::from("d"),
    ]);
    print!("w = {}", w);
    // w = a, b, c, d
}
```

#### é«˜çº§ç±»å‹

- ä½¿ç”¨ `newtype` æ¨¡å¼å®ç°ç±»å‹å®‰å…¨å’ŒæŠ½è±¡
    - é™æ€çš„ä¿è¯å„ç§å€¼ä¹‹é—´ä¸ä¼šæ··æ·†å¹¶è¡¨æ˜å€¼çš„å•ä½
    - ä¸ºç±»å‹çš„æŸäº›ç»†èŠ‚æä¾›æŠ½è±¡èƒ½åŠ›
    - é€šè¿‡è½»é‡çº§çš„å°è£…æ¥éšè—å†…éƒ¨å®ç°ç»†èŠ‚
- ç±»å‹åˆ«å
    - ç±»ä¼¼ `typescript`
- `Never` ç±»å‹
    - åä¸º `!` çš„ç‰¹æ®Šç±»å‹
    - æ²¡æœ‰ä»»ä½•å€¼(ç©ºç±»å‹, `empty type`)
    - ä¸è¿”å›å€¼çš„å‡½æ•°ä¹Ÿè¢«ç§°ä½œå‘æ•£å‡½æ•° `diverging function`

```rust
fn never_example() {
    let guess = "";

    loop {
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,  // æ­¤å¤„çš„ continue æ˜¯ä¸€ä¸ªè¿”å›ä¸º ! çš„åˆ†æ”¯
        };
    }
}
```

- åŠ¨æ€å¤§å°å’Œ `Sized trait`
    - **Rust** éœ€è¦åœ¨ç¼–è¯‘æ—¶ç¡®å®šä¸ºä¸€ä¸ªç‰¹å®šç±»å‹çš„å€¼åˆ†é…å¤šå°‘ç©ºé—´
    - åŠ¨æ€å¤§å°çš„ç±»å‹(`DST, Dynamically Sized Type`): ç¼–å†™ä»£ç æ—¶ä½¿ç”¨åªæœ‰åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šå¤§å°çš„å€¼
    - åŠ¨æ€å¤§å°
        - `str`(æ³¨æ„ä¸æ˜¯ `&str`) æ˜¯åŠ¨æ€å¤§å°çš„ç±»å‹: åªæœ‰è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šå­—ç¬¦ä¸²çš„é•¿åº¦
        - `trait` æ˜¯åŠ¨æ€å¤§å°çš„ç±»å‹: é€šè¿‡åç§°å¯¹å…¶è¿›è¡Œå¼•ç”¨ (å¦‚: `Box<dyn TraitName>`)
    - `Sized trait`
        - ä¸ºäº†å¤„ç†åŠ¨æ€å¤§å°çš„ç±»å‹, **Rust** æä¾›äº†ä¸€ä¸ª `Sized trait` æ¥ç¡®å®šä¸€ä¸ªç±»å‹çš„å¤§å°åœ¨ç¼–è¯‘æ—¶æ˜¯å¦å·²çŸ¥
        - ç¼–è¯‘æ—¶å¯è®¡ç®—å‡ºå¤§å°çš„ç±»å‹ä¼šè‡ªåŠ¨å®ç°è¿™ä¸€ `trait`
        - **Rust** ä¼šä¸ºæ¯ä¸€ä¸ªæ³›å‹å‡½æ•°éšå¼åœ°æ·»åŠ  `Sized` çº¦æŸ
        - `?Sized` çº¦æŸ: `T` å¯èƒ½æ˜¯ä¹Ÿå¯èƒ½ä¸æ˜¯ `Sized` çš„

```rust
// fn sized_example<T>(t: T) {}
// â†“ éšå¼æ·»åŠ çº¦æŸ
// fn sized_example<T: Sized>(t: T) {}

//                                   â†“ ç”±äº T å¯èƒ½ä¸æ˜¯ Sized çš„, æ‰€ä»¥æ­¤å¤„éœ€è¦ç”¨å¼•ç”¨æ¥ä½¿ç”¨ t
fn sized_bound_example<T: ?Sized>(t: &T) {}
```

#### é«˜çº§å‡½æ•°å’Œé—­åŒ…

- å‡½æ•°æŒ‡é’ˆ
    - å¯ä»¥å°†å‡½æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°
    - å‡½æ•°åœ¨ä¼ é€’è¿‡ç¨‹ä¸­ä¼šè¢«å¼ºåˆ¶è½¬æ¢ä¸º `fn` ç±»å‹
    - `fn` ç±»å‹å°±æ˜¯å‡½æ•°æŒ‡é’ˆ (`function pointer`)

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn fn_pointer_example() {
    let res = do_twice(add_one, 1);
    println!("res: {}", res);  // res: 3
}
```

- å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…çš„åŒºåˆ«
    - `fn` æ˜¯ä¸€ä¸ªç±»å‹, è€Œä¸æ˜¯ä¸€ä¸ª `trait`
        - å¯ä»¥ç›´æ¥æŒ‡å®š `fn` çš„å‚æ•°ç±»å‹, ä¸ç”¨å£°æ˜ä¸€ä¸ªä»¥ `F trait` ä¸ºçº¦æŸçš„æ³›å‹å‚æ•°
    - å‡½æ•°æŒ‡é’ˆå®ç°äº†å…¨éƒ¨ä¸‰ç§é—­åŒ… `trait`
        - æ€»æ˜¯å¯ä»¥æŠŠå‡½æ•°æŒ‡é’ˆç”¨ä½œå‚æ•°ä¼ é€’ç»™ä¸€ä¸ªæ¥æ”¶é—­åŒ…çš„å‡½æ•°
        - æ‰€ä»¥å€¾å‘äºæ­é…é—­åŒ… `trait` çš„æ³›å‹æ¥ç¼–å†™å‡½æ•°: å¯ä»¥åŒæ—¶æ¥æ”¶é—­åŒ…å’Œæ™®é€šå‡½æ•°
    - æŸäº›æƒ…æ™¯, åªæƒ³æ¥å— `fn` è€Œä¸æ¥æ”¶é—­åŒ…
        - ä¸å¤–éƒ¨ä¸æ”¯æŒé—­åŒ…çš„ä»£ç äº¤äº’: å¦‚ Cå‡½æ•°
- è¿”å›é—­åŒ…
    - é—­åŒ…ä½¿ç”¨ `trait` è¿›è¡Œè¡¨è¾¾, æ— æ³•åœ¨å‡½æ•°ä¸­ç›´æ¥è¿”å›ä¸€ä¸ªé—­åŒ…, å¯ä»¥å°†ä¸€ä¸ªå®ç°äº†è¯¥ `trait` çš„å…·ä½“ç±»å‹ä½œä¸ºè¿”å›å€¼

```rust
// é”™è¯¯å†™æ³•
// fn return_a_closure() -> Fn(i32) -> i32 {
//     |x| x + 1 
// }
// æ­£ç¡®å†™æ³•
fn return_a_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```

#### å® macro

- å®åœ¨ **Rust** é‡ŒæŒ‡çš„æ˜¯ä¸€ç»„ç›¸å…³ç‰¹æ€§çš„é›†åˆç§°è°“
    - ä½¿ç”¨ `macro_rule!` æ„å»ºçš„å£°æ˜å® (`declarative macro`)
    - ä¸‰ç§è¿‡ç¨‹å®
- å‡½æ•°ä¸å®çš„åŒºåˆ«
    - æœ¬è´¨ä¸Š, å®æ˜¯ç”¨æ¥ç¼–å†™å¯ä»¥ç”Ÿæˆå…¶ä»–ä»£ç çš„ä»£ç  (å…ƒç¼–ç¨‹, `metaprogramming`)
    - å‡½æ•°åœ¨å®šä¹‰ç­¾åæ—¶, å¿…é¡»å£°æ˜å‚æ•°çš„ä¸ªæ•°å’Œç±»å‹, å®å¯ä»¥å¤„ç†å¯å˜çš„å‚æ•°
    - ç¼–è¯‘å™¨ä¼šåœ¨è§£é‡Šä»£ç å‰å±•å¼€å®
    - å®çš„å®šä¹‰æ¯”å‡½æ•°å¤æ‚å¾—å¤š, éš¾ä»¥é˜…è¯»ã€ç†è§£ã€ç»´æŠ¤
    - åœ¨æŸä¸ªæ–‡ä»¶è°ƒç”¨å®æ—¶, å¿…é¡»æå‰å®šä¹‰å®æˆ–å°†å®å¼•å…¥å½“å‰ä½œç”¨åŸŸ
    - å‡½æ•°å¯ä»¥åœ¨ä»»ä½•ä½ç½®å®šä¹‰å¹¶åœ¨ä»»ä½•ä½ç½®ä½¿ç”¨
- `macro_rules!` å£°æ˜å® (å¼ƒç”¨?)
    - **Rust** ä¸­æœ€å¸¸è§çš„å®å½¢å¼: å£°æ˜å®
        - ç±»ä¼¼ `match` çš„æ¨¡å¼åŒ¹é…
        - éœ€è¦ä½¿ç”¨ `macro_rules!`

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x: expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

- åŸºäºå±æ€§æ¥ç”Ÿæˆä»£ç çš„è¿‡ç¨‹å®
    - æ¥å—å¹¶æ“ä½œè¾“å…¥çš„ **Rust** ä»£ç 
    - ç”Ÿæˆå¦å¤–ä¸€äº› **Rust** ä»£ç ä½œä¸ºç»“æœ
    - ä¸‰ç§è¿‡ç¨‹å®
        - è‡ªå®šä¹‰æ´¾ç”Ÿ
        - å±æ€§å®
        - å‡½æ•°å®
    - åˆ›å»ºè¿‡ç¨‹å®æ—¶, å®å®šä¹‰å¿…é¡»å•ç‹¬æ”¾åœ¨å®ƒä»¬è‡ªå·±çš„åŒ…ä¸­, å¹¶ä½¿ç”¨ç‰¹æ®Šçš„åŒ…ç±»å‹

- è‡ªå®šä¹‰æ´¾ç”Ÿ
    - å®ä¾‹
        - åˆ›å»ºä¸€ä¸ª `hello_macro` åŒ…, å®šä¹‰ä¸€ä¸ªæ‹¥æœ‰å…³è”å‡½æ•° `hello_macro` çš„ `HelloMacro trait`
        - æä¾›ä¸€ä¸ªèƒ½è‡ªåŠ¨å®ç°è¯¥ trait çš„è¿‡ç¨‹å®
        - åœ¨å®ƒä»¬çš„ç±»å‹ä¸Šæ ‡æ³¨ `#[derive(HelloMacro)]` å¾—åˆ° `hello_macro` çš„é»˜è®¤å®ç°

```toml
# Cargo.toml (ä½¿ç”¨ --lib åˆ›å»º)
[package]
name = "hello_macro_derive"
version = "0.1.0"
edition = "2018"

[lib]
proc-macro = true

[dependencies]
syn = "0.14.4"
quote = "0.6.3"
```

```rust
// lib.rs
extern crate proc_macro;

// å†…ç½® api æ¥å£, æ“ä½œ Rust ä»£ç 
use crate::proc_macro::TokenStream;
// è¯­æ³•æ ‘ -> ä»£ç 
use quote::quote;
// ä»£ç  -> è¯­æ³•æ ‘
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust Code
    // as a syntax tree that we can manipulate.
    let ast = syn::parse(input).unwrap();

    // build the trait implementation
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote!(
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro!");
            }
        }
    );

    gen.into()
}
```

- å±æ€§å®
    - å±æ€§å®ä¸è‡ªå®šä¹‰ `derive` å®ç±»ä¼¼
        - å…è®¸åˆ›å»ºæ–°çš„å±æ€§
        - ä½†ä¸æ˜¯ä¸º `derive` å±æ€§ç”Ÿæˆä»£ç 
    - å±æ€§å®æ›´åŠ çµæ´»
        - `derive` åªèƒ½ç”¨äº `struct` å’Œ `enum`
        - å±æ€§å®å¯ä»¥ç”¨äºä»»æ„æ¡ç›®, ä¾‹å¦‚å‡½æ•°

```rust
// main.rs
// #[route(GET, "/")]
// fn index() {}

// lib.rs
// #[proc_macro_attribute]
// pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
// attr: GET "/" éƒ¨åˆ†
// item: indexå‡½æ•° éƒ¨åˆ†
// å…¶ä»–ä¸ derive å®ç±»ä¼¼
// }
```

- å‡½æ•°å®
    - å‡½æ•°å®å®šä¹‰ç±»ä¼¼äºå‡½æ•°è°ƒç”¨çš„å®, ä½†æ¯”æ™®é€šå‡½æ•°æ›´åŠ çµæ´»
    - å‡½æ•°å®å¯ä»¥æ¥å— `TokenStream` ä½œä¸ºå‚æ•°
    - ä¸å¦å¤–ä¸¤ç§è¿‡ç¨‹å®ä¸€æ ·, åœ¨å®šä¹‰ä¸­ä½¿ç”¨ **Rust** ä»£ç æ¥æ“ä½œ `TokenStream`

```rust
// main.rs
// let sql = sql!(SELECT * FROM posts WHERE id=1);

// lib.rs
// #[proc_macro]
// pub fn sql(input: TokenStream) -> TokenStream {

// }
```

## Rust Async

### å¹¶å‘æ¨¡å‹

#### å…¶ä»–çš„å¹¶å‘æ¨¡å‹

- **OSçº¿ç¨‹**
    - æ— éœ€æ”¹å˜ç¼–ç¨‹æ¨¡å‹, çº¿ç¨‹é—´åŒæ­¥å›°éš¾, æ€§èƒ½å¼€é”€å¤§
    - çº¿ç¨‹æ± å¯ä»¥é™ä½ä¸€äº›æˆæœ¬, ä½†éš¾ä»¥æ”¯æ’‘å¤§é‡IOç»‘å®šçš„å·¥ä½œ
- **Event-driven ç¼–ç¨‹**
    - ä¸å›è°ƒå‡½æ•°ä¸€èµ·ç”¨, å¯èƒ½é«˜æ•ˆ
    - éçº¿æ€§çš„æ§åˆ¶æµ, æ•°æ®æµå’Œé”™è¯¯ä¼ æ’­éš¾ä»¥è¿½è¸ª
- **Coroutines**
    - ç±»ä¼¼çº¿ç¨‹, æ— éœ€æ”¹å˜ç¼–ç¨‹æ¨¡å‹
    - ç±»ä¼¼ `async`, æ”¯æŒå¤§é‡ä»»åŠ¡
    - æŠ½è±¡æ‰äº†åº•å±‚ç»†èŠ‚ (è¿™å¯¹ç³»ç»Ÿç¼–ç¨‹ã€è‡ªå®šä¹‰è¿è¡Œæ—¶çš„å®ç°å¾ˆé‡è¦)
- **Actoræ¨¡å‹**
    - å°†æ‰€æœ‰å¹¶å‘è®¡ç®—åˆ’åˆ†ä¸º`actor`, æ¶ˆæ¯é€šä¿¡æ˜“å‡ºé”™
    - å¯ä»¥æœ‰æ•ˆåœ°å®ç°`actor`æ¨¡å‹, ä½†æœ‰è®¸å¤šå®é™…é—®é¢˜æ²¡æœ‰è§£å†³ (ä¾‹å¦‚æµæ§åˆ¶ã€é‡è¯•é€»è¾‘)

#### Rust çš„å¹¶å‘æ¨¡å‹

- **Future æ˜¯æƒ°æ€§çš„**
    - åªæœ‰ poll æ—¶æ‰èƒ½å–å¾—è¿›å±•; è¢«ä¸¢å¼ƒçš„ future å°±æ— æ³•å–å¾—è¿›å±•äº†
- **Async æ˜¯é›¶æˆæœ¬çš„**
    - ä½¿ç”¨ async, å¯ä»¥æ— éœ€å †å†…å­˜åˆ†é…(heap allocation) å’ŒåŠ¨æ€è°ƒåº¦(dynamic dispatch), å¯¹æ€§èƒ½å¤§å¥½, ä¸”å…è®¸åœ¨å—é™ç¯å¢ƒä½¿ç”¨
      async
- **ä¸æä¾›å†…ç½®è¿è¡Œæ—¶**
    - è¿è¡Œæ—¶ç”±ç¤¾åŒºæä¾›
- **å•çº¿ç¨‹ã€å¤šçº¿ç¨‹å‡æ”¯æŒ**
    - ä½†ä¼˜ç¼ºç‚¹ä¸åŒ

#### Rust çš„ Async å’Œ çº¿ç¨‹ (thread)

- OS çº¿ç¨‹
    - é€‚ç”¨äºå°‘é‡ä»»åŠ¡, æœ‰å†…å­˜å’ŒCPUå¼€é”€, ä¸”çº¿ç¨‹ç”Ÿæˆå’Œçº¿ç¨‹é—´åˆ‡æ¢éå¸¸æ˜‚è´µ
    - çº¿ç¨‹æ± å¯ä»¥é™ä½ä¸€äº›æˆæœ¬
    - å…è®¸é‡ç”¨åŒæ­¥ä»£ç , ä»£ç æ— éœ€å¤§æ¦‚, æ— éœ€ç‰¹å®šç¼–ç¨‹æ¨¡å‹
    - æœ‰äº›ç³»ç»Ÿæ”¯æŒä¿®æ”¹çº¿ç¨‹ä¼˜å…ˆçº§
- Async
    - æ˜¾è‘—é™ä½å†…å­˜å’ŒCPUå¼€é”€
    - åŒç­‰æ¡ä»¶ä¸‹, æ”¯æŒæ¯”çº¿ç¨‹å¤šå‡ ä¸ªæ•°é‡çº§çš„ä»»åŠ¡ (å°‘æ•°çº¿ç¨‹æ”¯æ’‘å¤§é‡ä»»åŠ¡)
    - å¯æ‰§è¡Œæ–‡ä»¶å¤§ (éœ€è¦ç”ŸæˆçŠ¶æ€æœº, æ¯ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æ†ç»‘ä¸€ä¸ªå¼‚æ­¥è¿è¡Œæ—¶)

```rust
fn get_two_site() {
    // spawn two threads to do work.
    let thread1 = thread::spawn(|| download("https://resource1.com"));
    let thread2 = thread::spawn(|| download("https://resource2.com"));

    // wait for both threads to complete
    thread1.join().expect("thread1 panicked!");
    thread2.join().expect("thread2 panicked!");
}

async fn get_two_site_async() {
    // create two different "future" which, when run to completion,
    // will asynchronously download the resources.
    let future1 = download_async("https://resource1.com");
    let future2 = download_async("https://resource2.com");

    // run both futures to completion at the same time.
    join!(future1, future2);
}
```

#### Async Rust ç›®å‰çš„çŠ¶æ€

- éƒ¨åˆ†ç¨³å®š, éƒ¨åˆ†ä»åœ¨å˜åŒ–
- ç‰¹ç‚¹
    - é’ˆå¯¹å…¸å‹å¹¶å‘ä»»åŠ¡, æ€§èƒ½å‡ºè‰²
    - ä¸é«˜çº§è¯­è¨€ç‰¹æ€§é¢‘ç¹äº¤äº’ (ç”Ÿå‘½å‘¨æœŸ, pinning)
    - åŒæ­¥å’Œå¼‚æ­¥ä»£ç é—´ã€ä¸åŒè¿è¡Œæ—¶çš„å¼‚æ­¥ä»£ç é—´å­˜åœ¨å…¼å®¹æ€§çº¦æŸ
    - ç”±äºä¸æ–­è¿›åŒ–, ç»´æŠ¤è´Ÿæ‹…æ›´é‡

#### è¯­è¨€å’Œåº“çš„æ”¯æŒ

- è™½ç„¶ Rust æœ¬èº«å°±æ”¯æŒ async ç¼–ç¨‹, ä½†å¾ˆå¤šåº”ç”¨ä¾èµ–äºç¤¾åŒºçš„åº“
    - æ ‡å‡†åº“æä¾›äº†æœ€åŸºæœ¬çš„ç‰¹æ€§ã€ç±»å‹å’ŒåŠŸèƒ½, ä¾‹å¦‚ `Future trait`
    - async/await è¯­æ³•ç›´æ¥è¢« Rust ç¼–è¯‘å™¨æ”¯æŒ
    - future crate æä¾›äº†è®¸å¤šå®ç”¨ç±»å‹ã€å®å’Œå‡½æ•°, å®ƒä»¬å¯ä»¥ç”¨äºä»»ä½•å¼‚æ­¥åº”ç”¨ç¨‹åº
    - å¼‚æ­¥ä»£ç ã€IOå’Œä»»åŠ¡ç”Ÿæˆçš„æ‰§è¡Œç”± "async runtime" æä¾›, ä¾‹å¦‚ Tokio å’Œ async-std. å¤§å¤šæ•° async åº”ç”¨ç¨‹åºå’Œä¸€äº› async
      crate éƒ½ä¾èµ–äºç‰¹å®šçš„è¿è¡Œæ—¶
- Rust ä¸å…è®¸åœ¨ trait é‡Œå£°æ˜ async å‡½æ•°

#### å…¼å®¹æ€§è€ƒè™‘

- async å’ŒåŒæ­¥ä»£ç ä¸èƒ½æ€»æ˜¯è‡ªç”±ç»„åˆ
    - ä¾‹å¦‚: ä¸èƒ½ç›´æ¥ä»åŒæ­¥ä»£ç è°ƒç”¨å¼‚æ­¥å‡½æ•°
- async ä»£ç é—´ä¹Ÿä¸æ€»æ˜¯èƒ½è‡ªç”±ç»„åˆ
    - ä¸€äº› crate ä¾èµ–äºç‰¹å®šçš„ async è¿è¡Œæ—¶

#### async/await

##### async

- async æŠŠä¸€æ®µä»£ç è½¬æ¢ä¸ºä¸€ä¸ªå®ç°äº† Future trait çš„çŠ¶æ€æœº
- è™½ç„¶åœ¨åŒæ­¥æ–¹æ³•ä¸­è°ƒç”¨é˜»å¡å‡½æ•°ä¼šé˜»å¡æ•´ä¸ªçº¿ç¨‹, ä½†é˜»å¡çš„ Future ä¼šæ”¾å¼ƒå¯¹çº¿ç¨‹çš„æ§åˆ¶, ä»è€Œå…è®¸å…¶ä»– Future æ¥è¿è¡Œ

##### async fn

- å¼‚æ­¥å‡½æ•°è¯­æ³•
    - `async fn do_something() { /** ... */ }`
    - async fn è¿”å›çš„æ˜¯ Future, Futureéœ€è¦ç”±ä¸€ä¸ªæ‰§è¡Œè€…æ¥è¿è¡Œ
- `futures::executor::block_on`
    - `block_on` é˜»å¡å½“å‰çº¿ç¨‹, ç›´åˆ°æä¾›çš„ Future è¿è¡Œå®Œæˆä¸ºæ­¢
    - å…¶ä»–æ‰§è¡Œè€…æä¾›æ›´ä¸ºå¤æ‚çš„è¡Œä¸º, ä¾‹å¦‚å°†å¤šä¸ª Future å®‰æ’åˆ°åŒä¸€ä¸ªçº¿ç¨‹ä¸Š

```rust
use futures::executor::block_on;

async fn hello_world() {
    println!("hello world!");
}

fn main() {
    let future = hello_world();  // ä»€ä¹ˆéƒ½æ²¡æ‰“å°å‡ºæ¥ (æœªæ‰§è¡Œ future)
    block_on(future);  // future è¿è¡Œ, å¹¶æ‰“å°å‡º 'hello world!'
}
```

##### await

- åœ¨ async fn ä¸­, å¯ä»¥ä½¿ç”¨ `.await` æ¥ç­‰å¾…å¦ä¸€ä¸ªå®ç° Future trait çš„å®Œæˆ
- ä¸ `block_on` ä¸åŒ, `.await` ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹, è€Œæ˜¯å¼‚æ­¥çš„ç­‰å¾… Future çš„å®Œæˆ (å¦‚æœè¯¥ Future ç›®å‰æ— æ³•å–å¾—è¿›å±•,
  å°±å…è®¸å…¶ä»–ä»»åŠ¡è¿è¡Œ)

```rust
use futures::executor::block_on;

struct Song {}

async fn learn_song() -> Song {
    Song {}
}

async fn sing_song(song: Song) {}

async fn dance() {}

async fn learn_and_sing() {
    let song = learn_song().await;
    sing_song(song).await;
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();
    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}
```

### Future trait

- æ˜¯ Rust Async ç¼–ç¨‹çš„æ ¸å¿ƒ
- Future æ˜¯ä¸€ç§å¼‚æ­¥è®¡ç®—, å®ƒå¯ä»¥äº§ç”Ÿä¸€ä¸ªå€¼
- å®ç°äº† Future çš„ç±»å‹è¡¨ç¤º*ç›®å‰å¯èƒ½è¿˜ä¸å¯ç”¨çš„å€¼*
- Future ä»£è¡¨ä¸€ç§ä½ å¯ä»¥**æ£€éªŒæ˜¯å¦å®Œæˆ**çš„æ“ä½œ
- Future å¯ä»¥é€šè¿‡è°ƒç”¨ poll å‡½æ•°æ¥å–å¾—è¿›å±•
    - poll å‡½æ•°ä¼šé©±åŠ¨ Future å°½å¯èƒ½æ¥è¿‘å®Œæˆ
    - å¦‚æœ Future å®Œæˆäº†: è¿”å› poll::Ready(result), å…¶ä¸­ result å°±æ˜¯æœ€ç»ˆçš„ç»“æœ
    - å¦‚æœ Future è¿˜æ²¡å®Œæˆ: è¿”å› poll::Pending, å½“ Future å‡†å¤‡å¥½å–å¾—æ›´å¤šè¿›å±•æ—¶è°ƒç”¨ä¸€ä¸ª waker çš„ `wake()` å‡½æ•°

#### Wake() å‡½æ•°

- å½“ `wake()` å‡½æ•°è¢«è°ƒç”¨æ—¶
    - æ‰§è¡Œå™¨å°†é©±åŠ¨ Future å†æ¬¡è°ƒç”¨ poll å‡½æ•°, ä»¥ä¾¿ Future èƒ½å–å¾—æ›´å¤šçš„è¿›å±•
- æ²¡æœ‰ `wake()` å‡½æ•°, æ‰§è¡Œå™¨å°±ä¸çŸ¥é“ç‰¹å®šçš„ Future ä½•æ—¶èƒ½å–å¾—è¿›å±• (å°±å¾—ä¸æ–­çš„ poll)
- é€šè¿‡ `wake()` å‡½æ•°, æ‰§è¡Œå™¨å°±èƒ½ç¡®åˆ‡çš„çŸ¥é“å“ªäº› Future å·²ç»å‡†å¤‡å¥½è¿›è¡Œ `poll()` çš„è°ƒç”¨

- ä¾‹å­1
    - å®ç°ç®€åŒ–çš„ Future

```rust
trait SimpleFuture {
    type Output;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}

pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // The socket has data -- read it into a buffer and return it.
            Poll::Ready(self.socket.read_buf())
        } else {
            // The socket does not yet have data
            //
            // Arrange fr `wake` to be called once data is available.
            // When data becomes available, `wake` will be called, and the user
            // of this `Future` will know to call `poll` again and receive data.
            self.socket.st_readable_callback(wake);
            Poll::Pending
        }
    }
}
```

- ä¾‹å­2
    - ç»„åˆå¤šä¸ªå¼‚æ­¥æ“ä½œ, è€Œæ— éœ€ä¸­é—´åˆ†é…
    - å¯ä»¥é€šè¿‡æ— åˆ†é…çš„çŠ¶æ€æœºæ¥å®ç°å¤šä¸ª Future åŒæ—¶è¿è¡Œæˆ–ä¸²è”è¿è¡Œ

```rust
trait SimpleFuture {
    type Output;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}

pub struct Join<FutureA, FutureB> {
    // Each field may contain a future that should be run to completion.
    // If the future has already completed, the field is set to `None`,
    // This prevent us from polling a future after it has complete,
    // which violate the contract of the `Future` trait
    a: Option<FutureA>,
    b: Option<FutureB>,
}

impl<FutureA, FutureB> SimpleFuture for Join<FutureA, FutureB>
    where
        FutureA: SimpleFuture<Output=()>,
        FutureB: SimpleFuture<Output=()> {
    type Output = ();
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        // Attempt to complete future `a`
        if let Some(a) = &mut self.a {
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take();
            }
        }

        // Attempt to complete future `b`
        if let Some(b) = &mut self.b {
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take();
            }
        }

        if self.a.is_none() && self.b.is_none() {
            // Both futures have completed -- we can return successfully
            Poll::Ready(())
        } else {
            // One or both futures returned `Poll::Pending` and still have
            // work to do. They will `wake()` when progress can be make.
            Poll::Pending
        }
    }
}
```

- ä¾‹å­3
    - å¤šä¸ªè¿ç»­çš„ Future ä¸€ä¸ªæ¥ä¸€ä¸ªçš„æ‰§è¡Œ

```rust
trait SimpleFuture {
    type Output;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}

pub struct AndThenFut<FutureA, FutureB> {
    first: Option<FutureA>,
    second: FutureB,
}

impl<FutureA, FutureB> SimpleFuture for AndThenFut<FutureA, FutureB>
    where
        FutureA: SimpleFuture<Output=()>,
        FutureB: SimpleFuture<Output=()> {
    type Output = ();
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if let Some(first) = &mut self.first {
            match first.poll(wake) {
                // We`ve completed the first future -- remove it and start on the second!
                Poll::Ready(()) => self.first.take(),
                // We couldn`t yet complete the first future.
                Poll::Pending => return Poll::Pending,
            };
        }
        // Now that thw first future is done, attempt to complete the second.
        self.second.poll(wake)
    }
}
```

- çœŸæ­£çš„ Future trait
    - todo!
