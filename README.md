## Links

- [Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ](https://rust.bootcss.com/title-page.html)
- [crates.io](https://crates.io/)

## Cargo

> **æ–°å»ºé¡¹ç›®** `cargo new project_name`

- é¡¹ç›®ç»“æ„:

```yaml
project_name
- src
  - main.rs
- .gitignore
- Cargo.toml
- Cargo.lock
```

> **æ„å»ºé¡¹ç›®** `cargo build`

- åœ¨ç›®æ ‡è·¯å¾„ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶.
- è·¯å¾„: `target/debug/project_name.exe` \(windows\)

**ä¸ºå‘å¸ƒæ„å»º** `cargo build --release`

- ç¼–è¯‘æ—¶ä¼šè¿›è¡Œä¼˜åŒ–, ä»£ç ä¼šè¿è¡Œçš„æ›´å¿«, ä½†ç¼–è¯‘æ—¶é—´æ›´é•¿.
- ä¼šåœ¨ `target/release` ä¸‹ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶, è€Œä¸æ˜¯ `target/debug`

> **æ„å»ºå¹¶è¿è¡Œé¡¹ç›®** `cargo run`

- å¦‚æœé¡¹ç›®ç¼–è¯‘è¿‡ä½†æœªä¿®æ”¹, åˆ™ä¼šç›´æ¥è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶, ä¸ä¼šé‡å¤ç¼–è¯‘.

> **æ£€æŸ¥ä»£ç ** `cargo check`

- æ£€æŸ¥ä»£ç , ç¡®ä¿èƒ½é€šè¿‡ç¼–è¯‘, ä½†ä¸ä¼šäº§ç”Ÿä»»ä½•å¯æ‰§è¡Œæ–‡ä»¶.
- `cargo check` æ¯” `cargo build` å¿«å¾—å¤š, èƒ½è¿ç»­åå¤çš„ä½¿ç”¨ `cargo check` æ£€æŸ¥ä»£ç , æé«˜æ•ˆç‡.

> é…ç½®æ–‡ä»¶ `Cargo.toml` _Tom`s Obvious, Minimal Language_

- å¸¸è§å­—æ®µå«ä¹‰:

```toml
### åŒ…é…ç½®ä¿¡æ¯
[package]

# é¡¹ç›®å
name = "study-rust"

# é¡¹ç›®ç‰ˆæœ¬
version = "0.1.0"

# ä½¿ç”¨çš„rustç‰ˆæœ¬
edition = "2021"

# è½¯ä»¶åŒ…çš„è®¸å¯è¯
license = "MIT"

# ä½œè€…
authors = ["lopo <lopo@zju.edu.cn>"]

# å¯¹åŒ…çš„ç®€è¦ä»‹ç»è¯´æ˜
description = "a brief description of this package"

# æ˜¾å¼å£°æ˜å“ªäº›æ–‡ä»¶è¢«åŒ…å«(æ’é™¤)åœ¨å†…(å¤–)
exclude = ["build/**/*.o", "doc/**/*.html"]
include = ["src/**/*", "Cargo.toml"]

# æ›´å¤šä¿¡æ¯ (url)
documentation = "..."
homepage = "..."
repository = "..."

# æŒ‡å‘READMEæ–‡ä»¶, å¹¶ä¼šè¢«ä¿å­˜åœ¨æ³¨å†Œè¡¨æ•°æ®åº“ä¸­
readme = "..."

### ä¾èµ–ä¿¡æ¯
[dependencies]

# æŒ‡å®šåŒ…çš„ç‰ˆæœ¬
hammer = "0.5.0"

# æŒ‡å®šåŒ…çš„ç‰ˆæœ¬èŒƒå›´
color = "> 0.6.0, < 0.8.0"
```

## Rust

### å˜é‡

> **å˜é‡ä¸å¯å˜æ€§**

- å£°æ˜å˜é‡ä½¿ç”¨ `let` å…³é”®å­—
- é»˜è®¤æƒ…å†µä¸‹å˜é‡æ˜¯ä¸å¯å˜(_immutable_)çš„
- å£°æ˜å˜é‡æ—¶åœ¨å˜é‡å‰åŠ ä¸Š `mut`, ä½¿å˜é‡å¯å˜

```rust
fn mut_example() {
    let immut_variable = 1;
    let mut mut_variable = 1;
    // immut_variable = 2;  // panic
    mut_variable = 2;  // correct
}
```

> **å˜é‡ä¸å¸¸é‡**

- å¸¸é‡(_constant_)åœ¨ç»‘å®šå€¼åä¹Ÿæ˜¯ä¸å¯å˜çš„, ä½†å®ƒä¸ä¸å¯å˜å˜é‡æœ‰å¾ˆå¤šåŒºåˆ«:
    - ä¸å¯ä»¥ä½¿ç”¨ `mut`, å¸¸é‡æ˜¯æ°¸è¿œä¸å¯å˜çš„
    - å£°æ˜å¸¸é‡ä½¿ç”¨ `const` å…³é”®å­—, ä»–çš„ç±»å‹å¿…é¡»è¢«æ ‡æ³¨
    - å¸¸é‡å¯ä»¥åœ¨ä»»æ„ä½œç”¨åŸŸå†…è¿›è¡Œå£°æ˜, åŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
    - å¸¸é‡åªå¯ä»¥ç»‘å®šåˆ°å¸¸é‡è¡¨è¾¾å¼, æ— æ³•ç»‘å®šåˆ°å‡½æ•°çš„è°ƒç”¨ç»“æœæˆ–åªèƒ½åœ¨è¿è¡Œæ—¶æ‰èƒ½è®¡ç®—å¾—åˆ°çš„å€¼
- åœ¨ç¨‹åºè¿è¡ŒæœŸé—´, å¸¸é‡åœ¨å…¶å£°æ˜çš„ä½œç”¨åŸŸå†…ä¸€ç›´æœ‰æ•ˆ
- å‘½åè§„èŒƒ: **Rust**é‡Œçš„å¸¸é‡ä½¿ç”¨å…¨å¤§å†™å­—æ¯, å•è¯é—´ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”. (ä¾‹: `const MAX_POINTS: u32 = 10_000;`)

```rust
fn const_example() {
    const MAX_POINTS: [i32; 2] = [0, 0];
    // const mut MAX_POINTS_MUT: [i32; 2] = [0, 0];  // error
}
```

> **é‡å½± _Shadowing_**

- å¯ä»¥ä½¿ç”¨ç›¸åŒçš„åå­—å£°æ˜æ–°çš„å˜é‡(æ–°çš„ç±»å‹ã€æ–°çš„å€¼), æ–°çš„å˜é‡ä¼šé‡å½±(`shadow`)ä¹‹å‰å£°æ˜çš„å˜é‡
- `shadow` å’ŒæŠŠå˜é‡æ ‡è®°ä¸º `mut`æ˜¯ä¸ä¸€æ ·çš„:
    - å¦‚æœä¸ä½¿ç”¨ `let` å…³é”®å­—, é‚£ä¹ˆé‡æ–°ç»™é `mut` çš„å˜é‡èµ‹å€¼ä¼šå¯¼è‡´ç¼–è¯‘æ—¶é”™è¯¯
    - è€Œä½¿ç”¨ `let` å£°æ˜åŒåæ–°å˜é‡, ä¹Ÿæ˜¯ä¸å¯å˜çš„
    - ä½¿ç”¨ `let` å£°æ˜çš„æ–°å˜é‡, å¯ä»¥ä¸ºæ–°çš„ç±»å‹/æ–°çš„å€¼

```rust
fn shadow_example() {
    let what_type: u32 = 1;  // u32
    let what_type: &str = "1";  // &str
    let what_type: bool = false;  // bool
}
```

### æ•°æ®ç±»å‹

- æ ‡é‡å’Œå¤åˆç±»å‹
- **Rust**æ˜¯é™æ€ç¼–è¯‘è¯­è¨€, åœ¨ç¼–è¯‘æ—¶å¿…é¡»çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹
    - åŸºäºä½¿ç”¨çš„å€¼, ç¼–è¯‘å™¨é€šå¸¸èƒ½å¤Ÿæ¨æ–­å‡ºå®ƒçš„å…·ä½“ç±»å‹
    - ä½†å¦‚æœå¯èƒ½çš„ç±»å‹æ¯”è¾ƒå¤š(å¦‚ `String` çš„ `parse` æ–¹æ³•), å°±å¿…é¡»æ·»åŠ ç±»å‹æ ‡æ³¨, å¦åˆ™å°±ä¼šæŠ¥ç¼–è¯‘æ—¶é”™è¯¯

> **æ ‡é‡ç±»å‹**

- ä¸€ä¸ªæ ‡é‡ç±»å‹ä»£è¡¨ä¸€ä¸ªå•ä¸ªçš„å€¼
- **Rust**æœ‰å››ä¸ªä¸»è¦çš„æ ‡é‡ç±»å‹
    - æ•´æ•°ç±»å‹
    - æµ®ç‚¹ç±»å‹
    - å¸ƒå°”ç±»å‹
    - å­—ç¬¦ç±»å‹

> > **æ•´æ•°ç±»å‹**

- æ•´æ•°ç±»å‹æ²¡æœ‰å°æ•°éƒ¨åˆ†
- æ— ç¬¦å·ä»¥ `u` å¼€å¤´
- æœ‰ç¬¦å·ä»¥ `i` å¼€å¤´
- **Rust**çš„æ•´æ•°ç±»å‹åˆ—è¡¨å¦‚ä¸‹

| length | signed | unsigned |
| --- | --- | --- |
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch | isize | usize |

- `izise` å’Œ `usize` ç±»å‹çš„ä½æ•°ç”±ç¨‹åºè¿è¡Œçš„è®¡ç®—æœºçš„æ¶æ„å†³å®š
    - å¦‚æœæ˜¯64ä½è®¡ç®—æœº, é‚£ä¹ˆå°±æ˜¯64ä½çš„
    - ä½¿ç”¨ `isize` æˆ– `usize` çš„ä¸»è¦åœºæ™¯æ˜¯å¯¹æŸç§é›†åˆè¿›è¡Œç´¢å¼•æ“ä½œ
- æ•´æ•°å­—é¢é‡
    - é™¤äº† `byte` ç±»å‹å¤–, æ‰€æœ‰çš„æ•°å€¼å­—é¢é‡éƒ½å…è®¸ä½¿ç”¨ç±»å‹åç¼€ `42u8`
    - å¦‚æœä¸æ¸…æ¥šè¯¥ä½¿ç”¨ä»€ä¹ˆç±»å‹, åˆ™å¯ä»¥ä½¿ç”¨ç›¸åº”çš„é»˜è®¤ç±»å‹
        - æ•´æ•°çš„é»˜è®¤ç±»å‹æ˜¯ `i32`

| è¿›åˆ¶ | ä¾‹å­ |
| --- | --- |
| Decimal | `10_000` |
| Hex | `0xff` |
| Octal | `0o77` |
| Binary | `0b11` |
| Byte(`u8` only) | `b'A'` |

- æ•´æ•°æº¢å‡º
    - è°ƒè¯•æ¨¡å¼ä¸‹ç¼–è¯‘, **Rust** ä¼šæ£€æŸ¥æ•´æ•°æº¢å‡º, å¦‚æœå‘ç”Ÿæ•´æ•°æº¢å‡ºåˆ™ä¼šå¯¼è‡´ `panic`
    - å‘å¸ƒæ¨¡å¼(`--release`)ä¸‹ç¼–è¯‘, **Rust** ä¸ä¼šæ£€æŸ¥å¯èƒ½å¯¼è‡´ `panic` çš„æ•´æ•°æº¢å‡º
        - å¦‚æœæº¢å‡ºå‘ç”Ÿ, åˆ™ä¼šæ‰§è¡Œ _"ç¯ç»•"_ æ“ä½œ (ä¾‹: `u8` ç±»å‹çš„ `256` å˜æˆ `0`)

> > **æµ®ç‚¹ç±»å‹**

- æµ®ç‚¹ç±»å‹å«æœ‰å°æ•°éƒ¨åˆ†
- **Rust** æœ‰ä¸¤ç§åŸºç¡€çš„æµ®ç‚¹ç±»å‹
    - `f32` 32ä½, å•ç²¾åº¦
    - `f64` 64ä½, åŒç²¾åº¦
- **Rust** çš„æµ®ç‚¹ç±»å‹ä½¿ç”¨äº† `IEEE-754` æ ‡å‡†æ¥è¡¨è¿°
- `f64` æ˜¯é»˜è®¤ç±»å‹, å› ä¸ºç°ä»£CPUä¸Š `f64` å’Œ `f32` é€Ÿåº¦å·®ä¸å¤š, ä½†ç²¾åº¦æ›´é«˜
- æ•°å€¼æ“ä½œ

```rust
fn calculate_example() {
    let sum = 5 + 10;
    let difference = 95.5 - 33.2;
    let product = 4 * 30;
    let quotient = 5.67 / 3.22;
    let remainder = 51 % 4;
}
```

> > **å¸ƒå°”ç±»å‹**

- **Rust** çš„å¸ƒå°”ç±»å‹ä¹Ÿæœ‰ä¸¤ä¸ªå€¼: `true` å’Œ `false`
- å ç”¨ä¸€ä¸ªå­—èŠ‚å¤§å°
- ç¬¦å·ä¸º `bool`

> > **å­—ç¬¦ç±»å‹**

- **Rust** ä¸­çš„ `char` ç±»å‹è¢«ç”¨æ¥æè¿°å•ä¸ªå­—ç¬¦
- å­—ç¬¦ç±»å‹çš„å­—é¢é‡ä½¿ç”¨å•å¼•å· `'`
- å ç”¨4å­—èŠ‚å¤§å°
- æ˜¯ `Unicode` æ ‡é‡å€¼, å¯ä»¥è¡¨ç¤ºæ¯” `ASCII` å¤šå¾—å¤šçš„å­—ç¬¦å†…å®¹ (æ‹¼éŸ³ã€ä¸­æ—¥éŸ©æ–‡ã€emojiè¡¨æƒ…ç­‰)
    - èŒƒå›´ä¸º `U+0000` åˆ° `U+D7FF` å’Œ `U+E000` åˆ° `U+10FFFF`
- ä½† `Unicode` ä¸­æ²¡æœ‰ _å­—ç¬¦_ çš„æ¦‚å¿µ, æ‰€ä»¥ç›´è§‰ä¸Šçš„å­—ç¬¦ä¸ **Rust** ä¸­çš„å­—ç¬¦æ¦‚å¿µå¹¶ä¸ç›¸ç¬¦

```rust
fn char_example() {
    let x = 'x';
    let y: char = 'ãŠ';
    let z = 'ğŸ˜‚';
}
```

> **å¤åˆç±»å‹**

- å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œ
- **Rust** æä¾›äº†ä¸¤ç§åŸºç¡€çš„å¤åˆç±»å‹: å…ƒç»„(`Tuple`) å’Œ æ•°ç»„(`Array`)

> > å…ƒç»„

- å…ƒç»„å¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹ä¸­
- å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„, ä¸€æ—¦å£°æ˜å°±æ— æ³•æ”¹å˜

```rust
fn tuple_example() {
    // å£°æ˜
    let tup: (i32, f64, u8) = (-500, 6.4, 1);

    // è·å–å€¼
    let (x, y, z) = tup;
    println!("{}, {}, {}", x, y, z);  // -500, 6.4, 1

    // è®¿é—®
    println!("{}, {}, {}", tup.0, tup.1, tup.2);  // -500, 6.4, 1
}
```

> > æ•°ç»„

- æ•°ç»„ä¹Ÿå¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹ä¸­
- æ•°ç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„, ä¸”å…¶ä¸­çš„æ¯ä¸ªå…ƒç´ ç±»å‹å¿…é¡»ç›¸åŒ
- æ•°ç»„çš„ç±»å‹ä»¥è¿™ç§å½¢å¼è¡¨ç¤º: `[type; length]`
- \* å¦‚æœæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå€¼éƒ½ç›¸åŒ, é‚£ä¹ˆ:
    - åœ¨ä¸­æ‹¬å·ä¸­æŒ‡å®šåˆå§‹å€¼
    - ä½¿ç”¨åˆ†å·åˆ†éš”
    - æœ€åå†™ä¸Šæ•°ç»„çš„é•¿åº¦
    - `let a = [3; 5];` ç­‰ä»·äº `let a = [3, 3, 3, 3, 3];`
- è®¿é—®æ•°ç»„å…ƒç´ : ä½¿ç”¨ç´¢å¼•è®¿é—®(ç´¢å¼•ä» `0` å¼€å§‹)
- å¦‚æœè®¿é—®çš„ç´¢å¼•è¶…å‡ºäº†æ•°ç»„çš„èŒƒå›´
    - ç¼–è¯‘å¯èƒ½ä¼šé€šè¿‡
    - è¿è¡Œä¼šæŠ¥é”™ (`panic`)
    - **Rust** ä¸å…è®¸å…¶è®¿é—®æ•°ç»„è¶Šç•Œåç›¸åº”åœ°å€çš„å†…å­˜ (ä¸ `c/c++` åŒºåˆ«)

```rust
fn array_example() {
    // å£°æ˜
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let b = [1; 5];

    // è®¿é—®
    println!("a[1]: {}", a[1]);
    println!("b[2]: {}", b[2]);

    // è¶Šç•Œ
    let names = ["name1", "name2", "name3"];
    let idx = [1, 2, 3, 4];
    println!("{}", names[4]);  // panic in compiling
    println!("{}", names[idx[3]]);  // runtime panic
}
```

### å‡½æ•°

- å£°æ˜å‡½æ•°ä½¿ç”¨ `fn` å…³é”®å­—
- é’ˆå¯¹å‡½æ•°å’Œå˜é‡å, **Rust** ä½¿ç”¨ `snake case` å‘½åè§„èŒƒ
    - æ‰€æœ‰å­—æ¯éƒ½å°å†™, å•è¯é—´ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”
- å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆ, å¯é€‰çš„ç”±ä¸€ä¸ªè¡¨è¾¾å¼ç»“æŸ
    - **è¯­å¥** æ˜¯æ‰§è¡Œä¸€ç³»åˆ—åŠ¨ä½œçš„æŒ‡ä»¤
    - **è¡¨è¾¾å¼** ä¼šè®¡ç®—äº§ç”Ÿä¸€ä¸ªå€¼
- å‡½æ•°çš„è¿”å›å€¼
    - åœ¨ `->` ç¬¦å·åé¢å£°æ˜å‡½æ•°è¿”å›å€¼çš„ç±»å‹, ä½†æ˜¯ä¸å¯ä»¥ä¸ºè¿”å›å€¼å‘½å
    - åœ¨ **Rust** ä¸­, è¿”å›å€¼å°±æ˜¯å‡½æ•°ä½“é‡Œçš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
    - è‹¥æƒ³æå‰è¿”å›, åˆ™ä½¿ç”¨ `return` å…³é”®å­—, å¹¶æŒ‡å®šä¸€ä¸ªå€¼
        - å¤§å¤šæ•°å‡½æ•°éƒ½æ˜¯é»˜è®¤ä½¿ç”¨æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼

### æ§åˆ¶æµ

- `if` è¡¨è¾¾å¼
    - `if` è¡¨è¾¾å¼å…è®¸æ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒçš„åˆ†æ”¯ä»£ç , è¿™ä¸ªæ¡ä»¶**å¿…é¡»**æ˜¯ `bool` ç±»å‹çš„
    - ä¸‰ç›®ç”¨æ³• `let a = if condition { x } else { y };`
- `loop` è¡¨è¾¾å¼
    - `loop` å…³é”®å­—åå¤æ‰§è¡Œä¸€å—ä»£ç ç›´åˆ°åœæ­¢å¾ªç¯
    - å¯ä»¥åœ¨ `loop` å¾ªç¯ä¸­ä½¿ç”¨ `break` å…³é”®å­—æ¥å‘Šè¯‰ç¨‹åºä½•æ—¶åœæ­¢å¾ªç¯
    - `breal` é€€å‡ºå¾ªç¯å¯ä»¥è¿”å›å€¼ `let a = loop { break 3; };`
- `while` æ¡ä»¶å¾ªç¯
    - æ¯æ¬¡å¾ªç¯å‰éƒ½åˆ¤æ–­ä¸€æ¬¡æ¡ä»¶
- `for` å¾ªç¯

```rust
fn for_example() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter() {
        println!("{}", element);
    }
}
```

### æ‰€æœ‰æƒ

- **Rust** çš„æ ¸å¿ƒç‰¹æ€§å°±æ˜¯æ‰€æœ‰æƒ
- æ‰€æœ‰è¯­è¨€åœ¨è¿è¡Œæ—¶éƒ½å¿…é¡»ç®¡ç†ä»–ä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼
    - æœ‰çš„è¯­è¨€æœ‰åƒåœ¾æ”¶é›†æœºåˆ¶(`Gabrage Collect, GC`), åœ¨ç¨‹åºè¿è¡Œæ—¶ä¼šä¸æ–­å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜. å¦‚: `C#`, `Java`, `JavaScript` ç­‰
    - æœ‰çš„è¯­è¨€å¿…é¡»æ˜¾å¼åœ°åˆ†é…å’Œé‡Šæ”¾å†…å­˜. å¦‚: `C`, `C++` ç­‰
    - **Rust** ä½¿ç”¨äº†ç¬¬ä¸‰ç§æ–¹å¼, é€šè¿‡ä¸€ä¸ªæ‰€æœ‰æƒç³»ç»Ÿæ¥ç®¡ç†, å…¶åŒ…å«äº†ä¸€ç»„ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™
- æ ˆ`Stack` vs å †`Heap`
    - `Stack` æŒ‰å€¼çš„æ¥å—é¡ºåºæ¥å­˜å‚¨, æŒ‰ç›¸åé¡ºåºå°†ä»–ä»¬ç§»é™¤(**LIFO**)
    - æ‰€æœ‰å­˜å‚¨åœ¨ `Stack` ä¸Šçš„æ•°æ®å¿…é¡»æ‹¥æœ‰å·²çŸ¥ä¸”å›ºå®šçš„å¤§å°
        - ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥çš„æ•°æ®æˆ–è¿è¡Œæ—¶å¤§å°å¯èƒ½å‘ç”Ÿæ”¹å˜çš„æ•°æ®éƒ½å¿…é¡»å­˜æ”¾åœ¨ `Heap` ä¸­
    - `Heap` å†…å­˜ç»„ç»‡æ€§å·®ä¸€äº›
        - å½“æŠŠæ•°æ®æ”¾å…¥ `Heap` æ—¶, ä¼šè¯·æ±‚ä¸€å®šæ•°é‡çš„ç©ºé—´
        - æ“ä½œç³»ç»Ÿåœ¨ `Heap` ä¸­æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºé—´, å°†å…¶æ ‡è®°ä¸ºåœ¨ç”¨, å¹¶è¿”å›è¯¥ç©ºé—´çš„åœ°å€
- æ‰€æœ‰æƒè§£å†³çš„é—®é¢˜
    - è·Ÿè¸ªä»£ç ä¸­å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨ `Heap` çš„å“ªäº›æ•°æ®
    - æœ€å°åŒ– `Heap` ä¸Šçš„é‡å¤æ•°æ®é‡
    - æ¸…ç† `Heap` ä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³
    - æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› : ç®¡ç† `Heap` æ•°æ®
- æ‰€æœ‰æƒè§„åˆ™
    - æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡, è¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„**æ‰€æœ‰è€…**
    - æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
    - å½“æ‰€æœ‰è€…è¶…å‡º**ä½œç”¨åŸŸ**(`scope`)æ—¶, è¯¥å€¼å°†è¢«åˆ é™¤
    - å˜é‡çš„ä½œç”¨åŸŸå°±æ˜¯ç¨‹åºä¸­ä¸€ä¸ªé¡¹ç›®çš„æœ‰æ•ˆèŒƒå›´
    - å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ä¼šè‡ªåŠ¨æ‰§è¡Œä¸€ä¸ª `drop` å‡½æ•°

> å˜é‡å’Œæ•°æ®äº¤äº’çš„æ–¹å¼

- ç§»åŠ¨(`Move`)
    - å¤šä¸ªå˜é‡å¯ä»¥ä¸åŒä¸€ä¸ªæ•°æ®ä½¿ç”¨ä¸€ç§ç‹¬ç‰¹çš„æ–¹å¼æ¥äº¤äº’
- å…‹éš†(`Clone`)
- å¤åˆ¶(`Copy`)
    - `Copy trait` å¯ä»¥ç”¨äºåƒæ•´æ•°è¿™æ ·å®Œå…¨å­˜æ”¾åœ¨ `Stack` ä¸Šçš„ç±»å‹
    - å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy` è¿™ä¸ª `trait`, é‚£ä¹ˆå¤åˆ¶ä¹‹åæ—§çš„å˜é‡ä»»ç„¶å¯ç”¨
    - å¦‚æœä¸€ä¸ªç±»å‹æˆ–è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°äº† `Drop trait`, é‚£ä¹ˆ **Rust** ä¸å…è®¸è®©å®ƒå†å»å®ç° `Copy trait`
    - ä»»ä½•ç®€å•æ ‡é‡çš„ç»„åˆç±»å‹éƒ½æ˜¯å¯ä»¥ `Copy` çš„
    - ä»»ä½•éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§èµ„æºçš„éƒ½ä¸æ˜¯å¯ `Copy` çš„
    - ä¸€äº›å…·æœ‰ `Copy trait` çš„ç±»å‹
        - æ‰€æœ‰çš„æ•´æ•°ç±»å‹, å¦‚ `u32`
        - æ‰€æœ‰çš„æµ®ç‚¹ç±»å‹, å¦‚ `f64`
        - `bool`
        - `char`
        - `Tuple` (å¦‚æœå…¶æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯ `Copy` çš„, é‚£ä¹ˆå®ƒä¹Ÿæ˜¯å¯ `Copy` çš„)

```rust
fn move_and_clone_example() {
    // ç®€å•æ ‡é‡(åœ¨æ ˆä¸Šçš„æ•°æ®), å‘ç”Ÿå¤åˆ¶
    let x = 5;
    let y = x;
    println!("x: {}, y: {}", x, y);  // x: 5, y: 5

    // åœ¨å †ä¸Šçš„æ•°æ®, æ‰€æœ‰æƒå‘ç”Ÿè½¬ç§», s2èµ‹å€¼ås1å°†å¤±æ•ˆ
    let s1 = String::new("rust");
    let s2 = s1;
    println!("s1: {}, s2: {}", s1, s2);  // panic: borrow of moved value "s1"

    // å…‹éš†
    let s3 = s1.clone();
    println!("s1: {}, s3: {}", s1, s3);  // s1: rust, s3: rust
}
```

> æ‰€æœ‰æƒä¸å‡½æ•°

- åœ¨è¯­ä¹‰ä¸Š, å°†å€¼ä¼ é€’ç»™å‡½æ•°å’Œå°†å€¼èµ‹å€¼ç»™å˜é‡æ˜¯ç±»ä¼¼çš„(å€¼ä¼šå‘ç”Ÿ**ç§»åŠ¨**æˆ–**å¤åˆ¶**)
- å‡½æ•°çš„è¿”å›å€¼åœ¨è¿‡ç¨‹ä¸­åŒæ ·ä¹Ÿä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»
- ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªç›¸åŒçš„æ¨¡å¼
    - å°†ä¸€ä¸ªå€¼èµ‹å€¼ç»™å…¶ä»–å˜é‡æ—¶å°±ä¼šå‘ç”Ÿç§»åŠ¨
    - å½“ä¸€ä¸ªåŒ…å« `Heap` çš„æ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶, å®ƒçš„å€¼å°±ä¼šè¢« `drop` å‡½æ•°æ¸…ç†(é™¤éæ•°æ®æ‰€æœ‰æƒç§»åŠ¨åˆ°äº†å¦ä¸€ä¸ªå˜é‡ä¸Š)

> å¼•ç”¨å’Œå€Ÿç”¨

- `&` ç¬¦å·è¡¨ç¤ºå¼•ç”¨: å…è®¸å¼•ç”¨æŸäº›ä¹‹ä½†ä¸è·å¾—å…¶æ‰€æœ‰æƒ
- æŠŠå¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°çš„è¡Œä¸ºå«å€Ÿç”¨
- ä¸èƒ½ä¿®æ”¹å€Ÿç”¨çš„å˜é‡, å¼•ç”¨é»˜è®¤ä¹Ÿæ˜¯ä¸å¯å˜çš„
- å¯å˜å¼•ç”¨ `&mut`
    - å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªé‡è¦é™åˆ¶: åœ¨ç‰¹å®šä½œç”¨åŸŸå†…, å¯¹æŸä¸€æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨(å¯ä»¥åœ¨ç¼–è¯‘æ—¶é˜²æ­¢æ•°æ®ç«äº‰)
    - å¦ä¸€ä¸ªé™åˆ¶: ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€(å¤š)ä¸ªä¸å¯å˜å¼•ç”¨

> åˆ‡ç‰‡

- **Rust** çš„å¦ä¸€ç§ä¸æŒæœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹
- å½¢å¼: `&Origin[start, end]`
    - å¼€å§‹ç´¢å¼•å°±æ˜¯åˆ‡ç‰‡èµ·å§‹ä½ç½®çš„ç´¢å¼•å€¼
    - ç»“æŸç´¢å¼•æ˜¯åˆ‡ç‰‡ç»“æŸä½ç½®çš„ä¸‹ä¸€ä¸ªç´¢å¼•å€¼
- è¯­æ³•ç³–
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å¤´éƒ¨: `&Origin[..end]`
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å°¾éƒ¨: `&Origin[start..]`
    - åˆ‡ç‰‡åŒ…å«å­—ç¬¦ä¸²å…¨éƒ¨: `&Origin[..]`
- å­—ç¬¦ä¸²åˆ‡ç‰‡
    - æ˜¯æŒ‡å‘å­—ç¬¦ä¸²ä¸­ä¸€éƒ¨åˆ†å†…å®¹çš„å¼•ç”¨
    - å­—ç¬¦ä¸²å­—é¢é‡çš„å˜é‡ç±»å‹æ˜¯ `&str`, æ˜¯ä¸€ä¸ªæŒ‡å‘äºŒè¿›åˆ¶ç¨‹åºç‰¹å®šä½ç½®çš„åˆ‡ç‰‡, æ˜¯ä¸å¯å˜å¼•ç”¨
    - æ³¨æ„
        - å­—ç¬¦ä¸²åˆ‡ç‰‡çš„èŒƒå›´ç´¢å¼•å¿…é¡»å‘ç”Ÿåœ¨æœ‰æ•ˆçš„ `UTF-8` å­—ç¬¦è¾¹ç•Œå†…
        - å¦‚æœå°è¯•ä»ä¸€ä¸ªå¤šå­—èŠ‚çš„å­—ç¬¦ä¸­åˆ›å»ºåˆ‡ç‰‡, åˆ™ä¼šå¼•å‘ `panic`

```rust
fn slice_example() {
    let string = String::from("Hello world!");
    let arr = [1, 2, 3, 4, 5];

    let str_slice = &string[1..4];  // ell
    let arr_slice = &arr[2..5];  // [3, 4, 5] 
}
```

### ç»“æ„ä½“

- `struct` ç»“æ„ä½“
    - è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹
    - ä¸ºç›¸å…³è”çš„å€¼å‘½å, æ‰“åŒ… => æœ‰æ„ä¹‰çš„ç»„åˆ
    - ä¸€æ—¦ `struct` æ˜¯å¯å˜çš„, åˆ™ç»“æ„ä½“ä¸­çš„æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯å˜çš„
- å®šä¹‰
    - ä½¿ç”¨ `struct` å…³é”®å­—, å¹¶ä¸ºæ•´ä¸ªç»“æ„ä½“å‘½å
    - åœ¨èŠ±æ‹¬å·å†…ä¸ºæ‰€æœ‰å­—æ®µ(`field`)å®šä¹‰åç§°å’Œç±»å‹
- å®ä¾‹åŒ–
    - ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šå…·ä½“å€¼
    - æ— éœ€æŒ‰å£°æ˜çš„é¡ºåºæŒ‡å®š
- è®¿é—®
    - ä½¿ç”¨ç‚¹æ ‡è®°æ³• `struct_name.field_name`
- å…¶ä»–
    - å­—æ®µç®€å†™: æ„é€ æ—¶åŒ `js`
    - æ›´æ–°: ç±»ä¼¼ `js` å¯¹è±¡è§£æ„
    - `Tuple struct`
        - å¯ä»¥å®šä¹‰ç±»ä¼¼ `tuple` çš„ `struct`, å«åš `tuple struct`
        - `tuple struct` æ•´ä½“æœ‰å, ä½†é‡Œé¢çš„å…ƒç´ æ²¡æœ‰å
        - é€‚ç”¨: æƒ³ç»™æ•´ä¸ª `tuple` èµ·å, å¹¶è®©å®ƒä¸åŒäºå…¶ä»– `tuple`, è€Œä¸”åˆä¸éœ€è¦ç»™æ¯ä¸ªå…ƒç´ èµ·å
    - `Unit-Like Struct` (æ²¡æœ‰ä»»ä½•å­—æ®µ)
        - å¯ä»¥å®šä¹‰æ²¡æœ‰ä»»ä½•å­—æ®µçš„ `struct`, å«åš `Unit-Like struct`(å› ä¸ºä¸`()`, å•å…ƒç±»å‹ç±»ä¼¼)
        - ä½¿ç”¨: åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°æŸä¸ª `trait`, ä½†åˆæ²¡æœ‰æ•°æ®éœ€è¦å­˜å‚¨

```rust
// å®šä¹‰
struct User {
    username: String,
    email: String,
    account: u64,
    active: bool,
}

fn struct_example() {
    // å®ä¾‹åŒ–
    let user = User {
        username: String::from("name"),
        email: String::from("email@example.com"),
        account: 123456789,
        active: true
    };
}

// tuple struct
struct Color(i32, i32, i32);

struct Point(i32, i32, i32);

fn tuple_struct_example() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    // black å’Œ origin æ˜¯ä¸åŒç±»å‹(ä»–ä»¬æ˜¯ä¸åŒçš„ tuple struct çš„å®ä¾‹)
}
```

> `Struct` çš„ æ–¹æ³• / å…³è”å‡½æ•°

- æ–¹æ³•å’Œå‡½æ•°ç±»ä¼¼: `fn` å…³é”®å­—ã€åç§°ã€å‚æ•°ã€è¿”å›å€¼
- æ–¹æ³•å’Œå‡½æ•°ä¸åŒä¹‹å¤„
    - æ–¹æ³•æ˜¯åœ¨ `struct`(æˆ– `enum`, `trait` å¯¹è±¡)çš„ä¸Šä¸‹æ–‡ä¸­å®šä¹‰ (åœ¨ `impl` ä¸­å®ç°)
    - ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ `self`(æˆ– `&self`, `&mut self`), è¡¨ç¤ºæ–¹æ³•è¢«è°ƒç”¨çš„ `struct` å®ä¾‹
- å¯ä»¥åœ¨ `impl` å—é‡Œå®šä¹‰ä¸æŠŠ `self` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°, ä»–ä»¬å«åšå…³è”å‡½æ•°
    - å…³è”å‡½æ•°é€šå¸¸ç”¨äºæ„é€ å™¨(ä¾‹: `String::from()`)

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}
```

### æšä¸¾ä¸æ¨¡å¼åŒ¹é…

> æšä¸¾ `enum`

```rust
// å®šä¹‰
enum IpKind {
    V4,
    V6,
}

enum IpKindValue {
    V4(u8, u8, u8, u8),
    V6(String),
}

// æ–¹æ³•
impl IpKindValue {
    fn call(&self) {
        println!("{:?}", self);
    }
}

// ä½¿ç”¨
fn ip_enum_example() {
    let ipv4 = IpKind::V4;
    let ipv6 = IpKind::V6;

    let ipv4_val = IpKindValue::V4(0, 0, 0, 0);
    let ipv6_val = IpKindValue::V6(String::from("0::0"));

    ipv6_val.call();
}

// Option æšä¸¾
// å¤„ç†å…¶ä»–è¯­è¨€çš„ null æƒ…å†µ
enum Option<T> {
    Some(T),
    None,
}
```

> æ¨¡å¼åŒ¹é…

> > `match`

- å…è®¸ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡ŒåŒ¹é…, å¹¶æ‰§è¡ŒåŒ¹é…çš„æ¨¡å¼å¯¹åº”çš„ä»£ç 
- æ¨¡å¼å¯ä»¥æ˜¯å­—é¢é‡ã€å˜é‡åã€é€šé…ç¬¦ç­‰

```rust
fn match_example() {
    let v: u8 = 3;
    match v {
        // ä¸€è¡Œè¯­å¥: å¯ä»¥ç›´æ¥å†™
        1 => println!("one"),
        // å¤šè¡Œè¯­å¥: åŒ…è£¹åœ¨å—å†…
        2 => {
            println!("two");
            println!("two");
        }
        // æ— å…³å†…å®¹: ç”¨ _ é€šé…åŒ¹é…
        _ => {
            println!("more then 2");
        }
    }
}
```

> > `if let`

- åªå…³å¿ƒä¸€ç§åŒ¹é…è€Œå¿½ç•¥å…¶ä»–åŒ¹é…çš„æƒ…å†µ
- æ›´å°‘çš„ä»£ç ã€æ›´å°‘çš„ç¼©è¿›ã€æ›´å°‘çš„æ¨¡æ¿ä»£ç 
- æ”¾å¼ƒäº†ç©·ä¸¾çš„å¯èƒ½
- å¯ä»¥æ­é… `else`

```rust
fn if_let_example() {
    let v: u8 = 2;

    if let 0 = v % 2 {
        println!("even");
    } else {
        println!("odd");
    }
}
```

### æ¨¡å—ç³»ç»Ÿ

- **Rust** çš„æ¨¡å—ç³»ç»Ÿ
    - `Package`(åŒ…): `Cargo` çš„ç‰¹æ€§, èƒ½å¤Ÿæ„å»ºã€æµ‹è¯•ã€å…±äº« `crate`
    - `Crate`(å•å…ƒåŒ…): ä¸€ä¸ªæ¨¡å—æ ‘, å¯ä»¥äº§ç”Ÿä¸€ä¸ª `library` æˆ–å¯æ‰§è¡Œæ–‡ä»¶
    - `Module`(æ¨¡å—)ã€`use`: èƒ½å¤Ÿæ§åˆ¶ä»£ç çš„ç»„ç»‡ã€ä½œç”¨åŸŸã€ç§æœ‰è·¯å¾„
    - `Path`(è·¯å¾„): ä¸º `struct`ã€`function`ã€`module`ç­‰å‘½åçš„æ–¹å¼

> `Cargo` çš„æƒ¯ä¾‹

- `src/main.rs` æ˜¯ `binary crate` çš„ `crate root`, ä¸” `crate` åä¸ `package` åç›¸åŒ
- `src/lib.rs` æ˜¯ `library crate` çš„ `crate root`, ä¸” `crate` åä¸ `package` åç›¸åŒ
- ä¸€ä¸ª `package` å¯ä»¥åŒæ—¶åŒ…å« `src/main.rs` å’Œ `src.lib.rs`
    - ä¸€ä¸ª `binary crate`, ä¸€ä¸ª `library crate`
- ä¸€ä¸ª `package` å¯ä»¥åŒ…å«å¤šä¸ª `binary crate`
    - æ–‡ä»¶æ”¾åœ¨ `src/bin`
    - æ¯ä¸ªæ–‡ä»¶éƒ½æ˜¯å•ç‹¬çš„ `binary crate`

> `Package`

- ä¸€ä¸ª `Package` åŒ…å« - **1** ä¸ª `Cargo.toml`, ä»–æè¿°äº†å¦‚ä½•æ„å»ºè¿™äº› `crate`
- åªèƒ½åŒ…å« **0-1** ä¸ª `library crate`
- å¯ä»¥åŒ…å« **ä»»æ„æ•°é‡** çš„ `binary crate`
- å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª `crate`(`binary` æˆ– `library`)

> `Crate`

- ç±»å‹: `binary` æˆ– `library`
- ä½œç”¨: å°†ç›¸å…³åŠŸèƒ½æ”¾åˆ°ä¸€ä¸ªä½œç”¨åŸŸå†…, ä¾¿äºåœ¨é¡¹ç›®é—´è¿›è¡Œå…±äº«(é˜²æ­¢å†²çª)
- `crate Root` æ˜¯æºä»£ç æ–‡ä»¶, **Rust** ç¼–è¯‘å™¨ä»è¿™é‡Œå¼€å§‹æ„å»º `crate` æ ¹çš„ `Module`

> `Module`

- åœ¨ä¸€ä¸ª `crate` å†…, å°†ä»£ç è¿›è¡Œåˆ†ç»„
- ä½¿ç”¨ `mod` å…³é”®å­—, å¯åµŒå¥—
- å¯ä»¥åŒ…å«å…¶ä»–é¡¹(`struct`, `enum`, `trait`, å¸¸é‡, å‡½æ•°ç­‰)çš„å®šä¹‰

> `Path`

- ä¸ºäº†åœ¨ **Rust** çš„æ¨¡å—ä¸­æ‰¾åˆ°æŸä¸ªæ¡ç›®, éœ€è¦ä½¿ç”¨è·¯å¾„
- è·¯å¾„çš„ä¸¤ç§å½¢å¼
    - ç»å¯¹è·¯å¾„: ä» `crate root` å¼€å§‹, ä½¿ç”¨ `crate` å æˆ–å­—é¢é‡ `crate`
    - ç›¸å¯¹è·¯å¾„: ä»å½“å‰æ¨¡å—å¼€å§‹, ä½¿ç”¨ `self`, `super` æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦
- è·¯å¾„è‡³å°‘ç”±ä¸€ä¸ªæ ‡è¯†ç¬¦ç»„æˆ, æ ‡è¯†ç¬¦ä¹‹é—´ä½¿ç”¨ `::`

> ç§æœ‰è¾¹ç•Œ `privacy boundary`

- æ¨¡å—ä¸ä»…å¯ä»¥ç»„ç»‡ä»£ç , è¿˜å¯ä»¥å®šä¹‰ç§æœ‰è¾¹ç•Œ
- å¦‚æœæƒ³æŠŠå‡½æ•° æˆ– `struct` ç­‰è®¾ä¸ºç§æœ‰, å¯ä»¥å°†å®ƒæ”¾åˆ°æŸä¸ªæ¨¡å—ä¸­
- **Rust** ä¸­çš„æ‰€æœ‰æ¡ç›®(å‡½æ•°, æ–¹æ³•, å¸¸é‡, æ¨¡å—, `struct`, `enum` ç­‰)é»˜è®¤æ˜¯ç§æœ‰çš„
- çˆ¶çº§æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®
- å­æ¨¡å—å¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
- æ¨¡å—å®šä¹‰æ—¶, å¦‚æœæ¨¡å—åé¢æ˜¯ `;` è€Œä¸æ˜¯ä»£ç å—
    - **Rust** ä¼šä»ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹
    - æ¨¡å—æ ‘çš„ç»“æ„ä¸ä¼šå˜åŒ–
- å…³é”®å­—
    - `pub` æš´éœ²å…¬å…±
    - `super` è®¿é—®çˆ¶çº§æ¨¡å—ä¸­çš„å†…å®¹, ç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„ `..`
    - `pub struct`
        - `struct` æ˜¯å…¬å…±çš„
        - `struct` çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„
    - `pub enum`
        - `enum` æ˜¯å…¬å…±çš„
        - `enum` çš„å˜ä½“é»˜è®¤ä¹Ÿæ˜¯å…¬å…±çš„
    - `use`
        - å¯ä»¥ä½¿ç”¨ `use` å…³é”®å­—å°†è·¯å¾„å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…
        - ä»éµå¾ªç§æœ‰æ€§åŸåˆ™
        - `as`: alias, like js (esm: `import * as customName from "..."`)
        - `pub use`: re-export, like js (esm: `export * from "..."`)
        - `use std::{self, fmt, cmp};`: part-use, like js (esm: `import { classA, classB } from "...""`)
        - `use std::*;`: use all, like js (esm: `import * from "..."`)

```rust
/// module_in_other_file.file
pub fn function_in_other_file() {}

/// lib.rs
// ç”¨ä¸‹è¡Œè¯­å¥å¼•å…¥å¤–éƒ¨æ–‡ä»¶çš„ module
// mod module_in_other_file;

mod outer_module {
    pub mod inner_module {
        pub fn inner_function() {}
    }

    pub struct StructExample {
        private_item: i32,
        pub public_item: i32,
    }

    pub enum EnumExample {
        DefaultToPublic,
        NoNeedOfPub
    }

    fn super_example() {
        super::path_example()
    }
}

pub fn path_example() {
    // absolute
    crate::outer_module::inner_module::inner_function();

    // relative
    outer_module::inner_module::inner_function();
}

fn use_example() {
    use outer_module::inner_module;

    inner_module::inner_function();
}
```

### å¸¸ç”¨é›†åˆ

> `Vector`

- ç±»å‹ä¸º `Vec<T>`
- ç”±æ ‡å‡†åº“æä¾›
- å¯å­˜å‚¨å¤šä¸ªå€¼
- åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„æ•°æ®
- å€¼åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾

```rust
fn vector_example() {
    // åˆ›å»º
    // let mut v: Vec<i32> = Vec::new();
    let mut v = vec![1, 2, 3];

    // æ›´æ–°
    v.push(4);
    v.push(5);

    // å¼•ç”¨
    // - ç´¢å¼•è®¿é—® (è¶Šç•Œä¼š panic)
    let third_1: &i32 = &v[2];
    // - get è®¿é—® (è¶Šç•Œåˆ™ä¸º None)
    let third_2 = match v.get(2) {
        Some(val) => val,
        None => None
    };

    // éå† - for å¾ªç¯
    // - ä¸å¯å˜å¼•ç”¨ å¾ªç¯
    for val in &v {
        print!("{}", val);  // -> 1 2 3 4 5
    }
    // - å¯å˜å¼•ç”¨ å¾ªç¯
    for val in &mut v {
        *val += 10;
        print!("{}", i);  // -> 11 12 13 14 15
    }
}
```

> `String`

- **Rust** çš„ **æ ¸å¿ƒè¯­è¨€å±‚é¢**, åªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹: å­—ç¬¦ä¸²åˆ‡ç‰‡ `&str`
    - å­—ç¬¦ä¸²åˆ‡ç‰‡: å¯¹å­˜å‚¨åœ¨å…¶ä»–åœ°æ–¹çš„ `UTF-8` ç¼–ç çš„å­—ç¬¦ä¸²çš„å¼•ç”¨
    - å­—ç¬¦ä¸²å­—é¢é‡: å­˜å‚¨åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„å­—ç¬¦ä¸²åˆ‡ç‰‡
- `String` ç±»å‹
    - æ¥è‡ª **æ ‡å‡†åº“** è€Œä¸æ˜¯æ ¸å¿ƒè¯­è¨€
    - å¯å¢é•¿ã€å¯ä¿®æ”¹ã€å¯è·å¾—æ‰€æœ‰æƒ
    - `UTF-8` ç¼–ç 
    - æ˜¯å¯¹ `Vec<u8>` çš„åŒ…è£…, `len()` æ–¹æ³• è¿”å›çš„æ˜¯ `Unicode` æ ‡é‡å€¼, è€Œéå¸¸è§„æ„ä¹‰çš„å­—ç¬¦æ•° (ä¸æ”¯æŒç´¢å¼•å½¢å¼è®¿é—®, ç”¨ç´¢å¼•æ–¹å¼è¿›è¡Œè®¿é—®ä¼šæŠ¥é”™)
- å­—èŠ‚`Bytes`ã€æ ‡é‡å€¼`Scalar Values`ã€å­—å½¢ç°‡`Grapheme Clusters`
    - éå†å­—èŠ‚ `for b in s.bytes() {}`
    - éå†`Unicode`æ ‡é‡å€¼ `for c in s.chars() {}`
    - éå†å­—å½¢ç°‡ `æ— æ ‡å‡†åº“æä¾›`

```rust
fn string_example() {
    // åˆ›å»º
    // - ä½¿ç”¨ ::new æ–¹æ³•åˆ›å»º
    let s1 = String::new();
    // - ä½¿ç”¨ to_string æ–¹æ³•
    let s2 = "hello".to_string();
    // - ä½¿ç”¨ ::from æ–¹æ³•åˆ›å»º
    let mut s3 = String::from("hello");

    // æ›´æ–°
    // - push_str æŠŠå­—ç¬¦ä¸²åˆ‡ç‰‡é™„åŠ åˆ° String
    s3.push_str(" world");
    println!("{}", s3);  // -> hello world
    // - push æŠŠå•ä¸ªå­—ç¬¦é™„åŠ åˆ° String
    s3.push('!');
    println!("{}", s3);  // -> hello world!
    // - '+' è¿ç®—ç¬¦
    // ä½¿ç”¨äº†ç±»ä¼¼ fn add(self, s: &str) -> String {...} çš„æ–¹æ³•, ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å¤±å»å…¶æ‰€æœ‰æƒ
    let name = String::from(" bye.");
    let s4 = s3 + &name;  // -> hello world! bye. (s3 å‘ç”Ÿäº†ç§»åŠ¨å·²å¤±æ•ˆ)
    // - format! å® (ç±»ä¼¼ js å­—ç¬¦ä¸²æ¨¡æ¿è¯­æ³•)
    let s5 = format!("{}-{}", s2, s4);
    println!("{}", s5);  // -> hello-hello world! bye

    // è®¿é—®
    // - éå†å­—èŠ‚ 
    for b in s5.bytes() {}
    // - éå†`Unicode`æ ‡é‡å€¼ 
    for c in s5.chars() {}
    // - éå†å­—å½¢ç°‡ æ— æ ‡å‡†åº“æä¾›

    // åˆ‡å‰²
    // å…è®¸ ä½†ä¸èƒ½è·¨è¶Šå­—ç¬¦è¾¹ç•Œ, å¦‚æœåˆ‡å‰²äº†å­—ç¬¦è¾¹ç•Œåˆ™ä¼šå¼•å‘ panic
    // - &string[start..end]
    let string_part = &s5[0..3];
}
```

> `HashMap`

- ç±»å‹ `HashMap<K, V>`
- é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨, ä¸€ä¸ªé”® `K` å¯¹åº”ä¸€ä¸ªå€¼ `V`
- é€‚ç”¨åœºæ™¯: é€šè¿‡ `K` æ¥å¯»æ‰¾æ•°æ®, è€Œä¸æ˜¯é€šè¿‡ç´¢å¼•
- æ‰€æœ‰æƒ
    - å¯¹å®ç°äº† `Copy trait` çš„ç±»å‹(å¦‚`i32`), å€¼ä¼šè¢«å¤åˆ¶åˆ° `HashMap` ä¸­
    - å¯¹æ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼, å…¶å€¼ä¼šè¢«ç§»åŠ¨, æ‰€æœ‰æƒè½¬ç§»ç»™ `HashMap`
        - å¦‚æœå°†å€¼çš„å¼•ç”¨æ’å…¥åˆ° `HashMap` ä¸­, å€¼æœ¬èº«ä¸ä¼šç§»åŠ¨
        - ä½†åœ¨ `HashMap` æœ‰æ•ˆæœŸé—´, è¢«å¼•ç”¨çš„å€¼å¿…é¡»ä¿æŒæœ‰æ•ˆ
- é»˜è®¤æƒ…å†µä¸‹, `HashMap` ä½¿ç”¨åŠ å¯†åŠŸèƒ½å¼ºå¤§çš„ `Hash` å‡½æ•°, å¯ä»¥æŠµæŠ— `Dos` æ”»å‡»
    - ä¸æ˜¯å¯ç”¨çš„æœ€å¿«çš„ `Hash` ç®—æ³•, ä½†å…·æœ‰æ›´å¥½çš„å®‰å…¨æ€§
    - å¯ä»¥æŒ‡å®šä¸åŒçš„ `hasher` æ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå‡½æ•°, `hasher` æ˜¯å®ç° `BuildHasher trait` çš„ç±»å‹

```rust
use std::collections::HashMap;

fn hashmap_example() {
    // åˆ›å»º
    // - ä½¿ç”¨ ::new æ–¹æ³•åˆ›å»º
    let mut map: HashMap<&String, i32> = HashMap::new();
    // - ä½¿ç”¨ ::collect æ–¹æ³•åˆ›å»º
    // åœ¨å…ƒç´ ç±»å‹ä¸º Tuple çš„ Vector ä¸Šä½¿ç”¨ collect æ–¹æ³•, å¯ä»¥ç»„å»ºä¸€ä¸ª HashMap
    let teams = vec![String::from("red"), String::from("blue")];
    let scores = vec![10, 50];
    let team_with_score: HashMap<_, _> = teams.iter()
        .zip(scores.iter())
        .collect();

    // æ·»åŠ æ•°æ®
    let red_team = String::from("red");
    map.insert(&red_team, 10);

    // è®¿é—®æ•°æ®
    let red_score = match map.get(&red_team) {
        Some(score) => score,
        None => None,
    };

    // éå† - for å¾ªç¯
    for (k, v) in &map {
        println!("{}: {}", k, v);
    }

    // æ›´æ–°
    // - K å·²ç»å­˜åœ¨, å¯¹åº”ä¸€ä¸ª V
    // - - æ›¿æ¢ç°æœ‰çš„ V
    map.insert(&red_team, 20);
    // - - ä¿ç•™ç°æœ‰çš„ V, å¿½ç•¥æ–°çš„ V
    map.entry(&red_team).or_insert(30);  // å·²å­˜åœ¨, å¿½ç•¥
    let blue_team = String::from("blue");
    map.entry(&blue_team).or_insert(40);  // ä¸å­˜åœ¨, æ’å…¥
    // - - åˆå¹¶ç°æœ‰çš„ V å’Œæ–°çš„ V
    let text = "a b c a c";
    let mut char_map = HashMap::new();
    for char in text.split_whitespace() {
        let count = char_map.entry(char).or_insert(0);
        *count += 1;
    }
    println!("{:#?}", char_map);  // {"a": 2, "b": 1, "c": 2}
    // - K ä¸å­˜åœ¨: å¢åŠ ä¸€ä¸ª K-V å¯¹
    let new_team = String::from("new");
    map.insert(&new_team, 100);
}
```

### é”™è¯¯å¤„ç†

> **å¯æ¢å¤é”™è¯¯** å’Œ **ä¸å¯æ¢å¤é”™è¯¯**

- å¯æ¢å¤é”™è¯¯ `Result<T, E>`
    - ä¾‹: æ–‡ä»¶æœªæ‰¾åˆ°, å¯å†æ¬¡å°è¯•
    - `Result` æšä¸¾
- ä¸å¯æ¢å¤é”™è¯¯ `panic!`
    - ä¾‹: è®¿é—®çš„ç´¢å¼•è¶Šç•Œ
    - æ‰§è¡Œ `panic!` å®
        - æ‰“å°ä¸€ä¸ªé”™è¯¯ä¿¡æ¯
        - å±•å¼€ `unwind`, æ¸…ç†è°ƒç”¨æ ˆ `stack`
        - é€€å‡ºç¨‹åº

```rust
// Result ç»“æ„å¦‚ä¸‹
// enum Result<T, E> {
//     // æˆåŠŸè¿”å›å€¼
//     Ok(T),
//     // å¤±è´¥è¿”å›å€¼
//     Err(E),
// }
fn result_example() {
    let f = File::open("hello.txt");

    // åŒ¹é…æ–‡ä»¶æ‰“å¼€ç»“æœ
    let f = match f {
        Ok(file) => file,
        // åŒ¹é…é”™è¯¯ç±»å‹
        Err(err) => match err.kind() {
            ErrorKind::NotFound => println!("file not found!"),
            other_error => panic!("other error!"),
        }
    };

    // ä½¿ç”¨é—­åŒ…é‡å†™ä¸Šè¿°ä»£ç 
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() - ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!( "Error creating file: {:?}"ï¼Œ error);
            })
        } else {
            panic!("Error opening file: {:?}", error);
        }
    });
}
```

> `unwrap` å’Œ `expect` å’Œ `?`è¿ç®—ç¬¦

- `unwrap(self)`:
    - å¦‚æœæˆåŠŸ, åˆ™ç›´æ¥è¿”å› `Result::Ok` é‡Œçš„å€¼,
    - å¦‚æœå¤±è´¥, åˆ™è°ƒç”¨ `panic!` å®ä¸­æ­¢ç¨‹åº.
- `expect(self, msg: &str)`:
    - æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²å‚æ•°(åˆ‡ç‰‡ç±»å‹), å½“ç»“æœä¸º`Result::Error`çš„æ—¶å€™è¾“å‡º.
    - å¦‚æœæˆåŠŸ, åˆ™ç›´æ¥è¿”å› `result` é‡Œçš„å€¼,
    - å¦‚æœå¤±è´¥, åˆ™è¾“å‡º`expect`çš„å…¥å‚å¹¶è°ƒç”¨ `panic!` å®ä¸­æ­¢ç¨‹åº.
- `?`è¿ç®—ç¬¦
    - åœ¨è¿”å›ç±»å‹ä¸º `Result` çš„å‡½æ•°ä¸­ä½¿ç”¨
    - åœ¨ `Result` ç±»å‹çš„å€¼åé¢ä½¿ç”¨
    - å¯é“¾å¼è°ƒç”¨, ç±»ä¼¼äº `typescript` ä¸­çš„ `?.` æ“ä½œ
    - å¦‚æœæˆåŠŸ, `Ok(res)` ä¸­çš„ `res`ä½œä¸ºè¡¨è¾¾å¼çš„ç»“æœ, å‡½æ•°ç»§ç»­æ‰§è¡Œ
    - å¦‚æœå¤±è´¥, æ•´ä¸ªå‡½æ•°è¿”å› `Err(err)`, ç›¸å½“äºæ‰§è¡Œäº† `return Err(err)`

### æ³›å‹ã€`Trait`ã€ç”Ÿå‘½å‘¨æœŸ

> æ³›å‹

- æé«˜ä»£ç å¤ç”¨èƒ½åŠ›
- æ˜¯å…·ä½“ç±»å‹æˆ–å…¶ä»–å±æ€§çš„æŠ½è±¡ä»£æ›¿
- ä¸ `typescript` ç±»ä¼¼
    - `fn` -> `function`
    - `struct` -> `class`
    - `enum` -> `type` / `interface`
- `fn largest<T>(list: &[T]) -> T {...}`
- æ€§èƒ½å’Œæ™®é€šä»£ç ä¸€è‡´, å› ä¸ºç¼–è¯‘å™¨ä¼šæ‰§è¡Œå•æ€åŒ–(ç±»ä¼¼`c++`)

> `Trait`

- æŠŠæ–¹æ³•ç­¾åæ”¾åœ¨ä¸€èµ·, å®šä¹‰å®ç°æŸç§ç›®çš„æ‰€å¿…é¡»çš„ä¸€ç»„è¡Œä¸º (ç±»ä¼¼æŠ½è±¡ç±»)
    - å…³é”®å­— `trait`
    - åªæœ‰æ–¹æ³•ç­¾å, æ²¡æœ‰å…·ä½“å®ç°
    - `trait` å¯ä»¥æœ‰å¤šä¸ªæ–¹æ³•: æ¯ä¸ªæ–¹æ³•ç­¾åå ä¸€è¡Œ, ä»¥ `;` ç»“å°¾
    - å®ç°è¯¥ `trait` çš„ç±»å‹å¿…é¡»æä¾›å…·ä½“çš„æ–¹æ³•å®ç°
- å®ç° `trait` çš„çº¦æŸ
    - è¿™ä¸ªç±»å‹æˆ–è¿™ä¸ª `trait` æ˜¯åœ¨æœ¬åœ° `crate` é‡Œå®šä¹‰çš„
    - æ— æ³•ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨çš„ `trait` (å­¤å„¿è§„åˆ™)
- é»˜è®¤å®ç°
    - åœ¨ `trait` ä¸­ç›´æ¥å®ç°æ–¹æ³•, ä½œä¸ºé»˜è®¤å®ç°
    - é»˜è®¤å®ç°ä¸­çš„æ–¹æ³•å¯ä»¥è°ƒç”¨ `trait` ä¸­å…¶ä»–çš„æ–¹æ³•, å³ä½¿è¿™äº›æ–¹æ³•æ²¡ç”¨é»˜è®¤å®ç°
- `trait` ä½œä¸ºå‚æ•°
    - `impl trait` è¯­æ³•, é€‚ç”¨äºç®€å•æƒ…å†µ (`trait bound` çš„ä¸€ç§è¯­æ³•ç³–)
    - `trait bound` è¯­æ³•, é€‚ç”¨äºå¤æ‚æƒ…å†µ
    - ä½¿ç”¨ `+` æŒ‡å®šå¤šä¸ª `trait bound`
    - `trait bound` å¯ä½¿ç”¨ `where` å­å¥
- `trait` ä½œä¸ºè¿”å›ç±»å‹
    - `impl trait` è¯­æ³•: åªèƒ½è¿”å›ç¡®å®šçš„åŒä¸€ç§ç±»å‹, è¿”å›å¯èƒ½ä¸åŒç±»å‹çš„ä»£ç ä¼šæŠ¥é”™

```rust
pub trait Summary {
    fn summarize1(&self) -> String;
    fn summarize2(&self) -> String;
}

pub trait Display {
    fn display1(&self) -> String;
    fn display2(&self) -> String;
}

// trait ä½œä¸ºå‚æ•°
fn impl_trait_example(item: impl Summary + Display) {
    println!("{}", item.summarize1());
}

fn trait_bound_example<T: Summary + Display>(item: T) {
    println!("{}", item.summarize1());
}

fn where_example<T, K>(item1: T, item2: K)
    where
        T: Summary,
        K: Summary + Display,
{
    println!("{}, {}", item1.summarize1(), item2.display1());
}

// trait ä½œä¸ºè¿”å›ç±»å‹
fn trait_as_result_example() -> impl Summary {
    // native code
}
```

> ç”Ÿå‘½å‘¨æœŸ

- å¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸ
    - é¿å…å‚æ‚¬å¼•ç”¨ (`dangling reference`)
    - æ¯ä¸ªå¼•ç”¨éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
    - å¤§å¤šæ•°æƒ…å†µæ˜¯éšå¼çš„ã€å¯æ¨æ–­çš„
    - å½“å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½ä»¥ä¸åŒçš„æ–¹å¼äº’ç›¸å…³è”æ—¶, å¯ä»¥æ‰‹åŠ¨æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
- å€Ÿç”¨æ£€æŸ¥å™¨
    - æ¯”è¾ƒä½œç”¨åŸŸæ¥åˆ¤æ–­æ‰€æœ‰çš„å€Ÿç”¨æ˜¯å¦åˆæ³•
- ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    - ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ä¸ä¼šæ”¹å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦
    - å½“æŒ‡å®šäº†æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°, å‡½æ•°å¯ä»¥æ¥æ”¶å¸¦æœ‰ä»»ä½•ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
    - ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨æè¿°äº†å¤šä¸ªå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¹‹é—´çš„å…³ç³», ä½†ä¸å½±å“ç”Ÿå‘½å‘¨æœŸ
    - è¯­æ³•
        - å‚æ•°åä»¥ `'` å¼€å¤´, é€šå¸¸å…¨å°å†™éå¸¸çŸ­(`'a`)
        - `&i32`  // ä¸€ä¸ªå¼•ç”¨
        - `&'a i32`  // å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
        - `&'a mut i32`  // å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¯å˜å¼•ç”¨
- ç”Ÿå‘½å‘¨æœŸçœç•¥çš„ä¸‰ä¸ªè§„åˆ™ (é€‚ç”¨äº `fn` å’Œ `impl`)
    - è§„åˆ™1: æ¯ä¸ªå¼•ç”¨ç±»å‹çš„å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
    - è§„åˆ™2: å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°, é‚£ä¹ˆè¯¥ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
    - è§„åˆ™3: (åªé€‚ç”¨äºæ–¹æ³•) å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°, ä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ `&self` æˆ– `&mut self`, é‚£ä¹ˆ `self` çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
- å‡½æ•°å®šä¹‰ä¸­çš„å£°æ˜å‘¨æœŸæ ‡æ³¨
    - æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°å£°æ˜åœ¨åœ¨å‡½æ•°åå’Œå‚æ•°åˆ—è¡¨ä¹‹é—´çš„ `<>` é‡Œ
    - æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°çš„æ–¹å¼ä¾èµ–äºå‡½æ•°æ‰€åšçš„äº‹
        - ä»å‡½æ•°è¿”å›å¼•ç”¨æ—¶, è¿”å›ç±»å‹çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°éœ€è¦ä¸å…¶ä¸­ä¸€ä¸ªå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸåŒ¹é…
        - å¦‚æœè¿”å›çš„å¼•ç”¨æ²¡æœ‰æŒ‡å‘ä»»ä½•å‚æ•°, é‚£ä¹ˆå®ƒåªèƒ½å¼•ç”¨å‡½æ•°å†…åˆ›å»ºçš„å€¼(å‘ç”Ÿäº†æ‚¬å‚å¼•ç”¨, å› ä¸ºè¯¥å€¼åœ¨å‡½æ•°ç»“æŸæ—¶ç»“æŸäº†å…¶ç”Ÿå‘½å‘¨æœŸ)
- ç»“æ„ä½“å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨(è§ä¸‹ `code example`)
- æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    - åœ¨ `struct` ä¸Šä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå®ç°æ–¹æ³•, è¯­æ³•å’Œæ³›å‹å‚æ•°çš„è¯­æ³•ä¸€è‡´
    - `struct` å­—æ®µçš„ç”Ÿå‘½å‘¨æœŸå
        - åœ¨ `impl` åå£°æ˜
        - åœ¨ `struct` åä½¿ç”¨
        - è¿™äº›ç”Ÿå‘½å‘¨æœŸå‚æ•°æ˜¯ `struct` ç±»å‹çš„ä¸€éƒ¨åˆ†
    - `impl` å—å†…çš„æ–¹æ³•ç­¾åä¸­
        - å¼•ç”¨å¿…é¡»ç»‘å®šäº `struct` å­—æ®µå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ, æˆ–è€…å¼•ç”¨æ˜¯ç‹¬ç«‹çš„ä¹Ÿå¯ä»¥
        - ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ç»å¸¸ä½¿å¾—æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸æ˜¯å¿…é¡»çš„
- é™æ€ç”Ÿå‘½å‘¨æœŸ
    - `'static` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç”Ÿå‘½å‘¨æœŸ, æ˜¯æ•´ä¸ªç¨‹åºçš„æŒç»­æ—¶é—´
        - ä¾‹å¦‚: æ‰€æœ‰çš„å­—ç¬¦ä¸²å­—é¢é‡éƒ½æ‹¥æœ‰ `'static` çš„ç”Ÿå‘½å‘¨æœŸ

```rust
// ç”Ÿå‘½å‘¨æœŸé”™è¯¯ç¤ºä¾‹
fn life_circle_error_example() {
    let r;
    {
        let x = 5;
        r = &x;  // error[E0597]: borrowed value does not live long enough
    }
    println!("r: {}", r);
}

// ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å®ä¾‹
fn life_circle_mark_example() {
    let s1 = String::from("abcd");
    let s2 = "xyz";

    let result = longest(s1.as_str(), s2);

    println!("longest string is: {}", result);
}

// æ­¤å¤„çš„ç”Ÿå‘½å‘¨æœŸ 'a çš„å®é™…ç”Ÿå‘½å‘¨æœŸæ˜¯: x å’Œ y ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸä¸­è¾ƒå°çš„é‚£ä¸ª
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// ç”Ÿå‘½å‘¨æœŸå‚æ•°çœç•¥è§„åˆ™

// ä¾‹1
// åŸå§‹
fn ex1(s: &str) -> &str { "native code" }

// è§„åˆ™1
fn ex1_mid<'a>(s: &'a str) -> &str { "native code" }

// è§„åˆ™2
fn ex1_auto<'a>(s: &'a str) -> &'a str { "native code" }
// æ­¤æ—¶ç¬¦åˆ [æ‰€æœ‰å¼•ç”¨éƒ½æœ‰å…¶ç”Ÿå‘½å‘¨æœŸ] -> å³å¯ä»¥çœç•¥

// ä¾‹2
// åŸå§‹
fn ex2(x: &str, y: &str) -> &str { "native code" }

// è§„åˆ™1, è§„åˆ™23ä¸é€‚ç”¨
fn ex2_auto<'a, 'b>(x: &'a str, y: &'b str) -> &str { "native code" }
// æ­¤æ—¶ä¸ç¬¦åˆ [æ‰€æœ‰å¼•ç”¨éƒ½æœ‰å…¶ç”Ÿå‘½å‘¨æœŸ] -> å³ä¸å¯ä»¥çœç•¥

// ä¾‹3
struct LifeCircleMark<'a> {
    part: &'a str
}

impl<'a> LifeCircleMark<'a> {
    // æ— å¼•ç”¨è¿”å›, åˆ™æ— éœ€ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    fn no_ref_return(&self) -> i32 { 1 }

    // æ ¹æ®è§„åˆ™3, è‡ªåŠ¨ä¸ºè¿”å›ç±»å‹æ ‡æ³¨ä¸º self çš„ç”Ÿå‘½å‘¨æœŸ
    fn with_ref_return(&self, arg1: &str) -> &str {
        "native code"
    }
}
```

```rust
// ç»¼åˆä½¿ç”¨
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>
(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);

    if x.len() > y.len() { x } else { y }
}
```

### æµ‹è¯•

- ä½¿ç”¨ `#[test]` æ ‡æ³¨æ‰€æœ‰çš„æµ‹è¯•å‡½æ•°
- ä½¿ç”¨ `cargo test` å‘½ä»¤è¿è¡Œæ‰€æœ‰çš„æµ‹è¯•å‡½æ•°
    - æ„å»ºä¸€ä¸ª `Test Runner` å¯æ‰§è¡Œæ–‡ä»¶
    - è¿è¡Œæ ‡æ³¨äº† `test` çš„å‡½æ•°å¹¶æŠ¥å‘Šå…¶æ˜¯å¦æˆåŠŸ
- å½“ä½¿ç”¨ `cargo` åˆ›å»º `library` é¡¹ç›®æ—¶, ä¼šç”Ÿæˆä¸€ä¸ª `test module`, é‡Œé¢æœ‰ä¸€ä¸ª `test` å‡½æ•°
    - å¯ä»¥æœ‰ä»»æ„æ•°é‡çš„ `test module` å’Œ `test` å‡½æ•°

> æ–­è¨€

- `assert!` æµ‹è¯• `bool`
    - æ–­è¨€å¤±è´¥: è¾“å‡º `FAILED`
- `assert_eq!` å’Œ `assert_ne!` æµ‹è¯•ç›¸ç­‰æ€§
    - ä¸¤ä¸ªå‚æ•°
    - è¦æ±‚å‚æ•°å®ç°äº† `PartialEq` å’Œ `Debug` è¿™ä¸¤ä¸ª `trait` (æ‰€æœ‰çš„åŸºæœ¬ç±»å‹å’Œæ ‡å‡†åº“çš„å¤§éƒ¨åˆ†ç±»å‹éƒ½å·²å®ç°)
    - æ–­è¨€å¤±è´¥: è¾“å‡º ä¸¤ä¸ªå‚æ•°çš„å€¼
- æ·»åŠ è‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯
    - åœ¨ `assert!` çš„ç¬¬äºŒä¸ªå‚æ•°å’Œ `assert_eq!`/`assert_ne!` çš„ç¬¬ä¸‰ä¸ªå‚æ•°æ·»åŠ è‡ªå®šä¹‰ä¿¡æ¯ (å¯ä»¥ä½¿ç”¨å ä½ç¬¦æ·»åŠ æ›´å¤šä¿¡æ¯)
- ä½¿ç”¨ `#[should_panic]` æ ‡æ³¨åº”è¯¥å‘ç”Ÿ `panic`
    - `#[should_panic(expected = "expected error msg")]` æ ‡æ³¨å‘ç”Ÿ `panic` çš„é”™è¯¯ä¿¡æ¯åº”è¯¥åŒ…å«æŸäº›å†…å®¹æ–‡æœ¬
- ä½¿ç”¨ `Result<T, E>` (æ— éœ€ `panic`)
    - è¿”å› `Ok`: æµ‹è¯•é€šè¿‡
    - è¿”å› `Err`: æµ‹è¯•å¤±è´¥

> `cargo test`

- é»˜è®¤è¡Œä¸º
    - å¹¶è¡Œè¿è¡Œ
    - æ‰§è¡Œæ‰€æœ‰æµ‹è¯•
    - æ•è·(ä¸æ˜¾ç¤º)æ‰€æœ‰è¾“å‡º, ä½¿è¯»å–ä¸æµ‹è¯•ç»“æœç›¸å…³çš„è¾“å‡ºæ›´å®¹æ˜“
- å‘½ä»¤è¡Œå‚æ•°
    - é’ˆå¯¹ `cargo`: æ”¾åœ¨ `cargo test` ä¹‹å
        - ä½¿ç”¨ `cargo test --help` æŸ¥çœ‹å¯ç”¨ä¿¡æ¯
    - é’ˆå¯¹æµ‹è¯•å¯æ‰§è¡Œç¨‹åº: æ”¾åœ¨ `--` ä¹‹å
        - ä½¿ç”¨ `cargo test -- --help` æŸ¥çœ‹å¯ç”¨ä¿¡æ¯
- å¹¶è¡Œ/ä¸²è¡Œ è¿è¡Œæµ‹è¯•
    - å¹¶è¡Œ(é»˜è®¤)
        - è¿è¡Œæ›´å¿«
        - éœ€è¦ç¡®ä¿æµ‹è¯•ä¹‹é—´ä¸äº’ç›¸ä¾èµ–ä¸”ä¸ä¾èµ–äºæŸä¸€å…±äº«çŠ¶æ€
    - ä¸²è¡Œ(æ§åˆ¶çº¿ç¨‹æ•°é‡)
        - `cargo test -- --test-threads=1`
- æ˜¾å¼å‡½æ•°è¾“å‡º
    - å¦‚æœæµ‹è¯•é€šè¿‡, é»˜è®¤ä¼šæ•è·æ‰€æœ‰æ ‡å‡†è¾“å‡ºå†…å®¹(ä¸æ˜¾ç¤º)
    - ä½¿ç”¨ `cargo test -- --show-output` åœ¨æˆåŠŸçš„æµ‹è¯•ä¸­æ˜¾ç¤ºè¾“å‡º
- æŒ‰åç§°è¿è¡Œæµ‹è¯•
    - å°†æµ‹è¯•çš„åç§°(ä¸€ä¸ªæˆ–å¤šä¸ª)ä½œä¸º `cargo test` çš„å‚æ•°
    - `cargo test name_of_test_fn`
    - ç”¨æµ‹è¯•åçš„ä¸€éƒ¨åˆ†åŒ¹é…å¤šä¸ªæµ‹è¯•
        - å¦‚: ä½¿ç”¨ `cargo test my_test` åŒ¹é… `my_test_1`ã€`my_test_2` ç­‰å¤šä¸ªæµ‹è¯•å‡½æ•°
    - å¿½ç•¥æŸäº›æµ‹è¯•, è¿è¡Œå‰©ä½™æµ‹è¯•
        - ä½¿ç”¨ `#[ignore]` æ ‡è®°å¿½ç•¥æµ‹è¯•å‡½æ•°
        - ä½¿ç”¨ `cargo test -- --ignored` åªè¿è¡Œè¢«æ ‡è®°ä¸ºå¿½ç•¥çš„æµ‹è¯•å‡½æ•°

> å•å…ƒæµ‹è¯• / é›†æˆæµ‹è¯•

- å•å…ƒæµ‹è¯•
    - ä¸€æ¬¡å¯¹ä¸€ä¸ªæ¨¡å—è¿›è¡Œéš”ç¦»çš„æµ‹è¯•
    - å¯æµ‹è¯• `private` æ¥å£
    - ä¸€èˆ¬ä¸æ¨¡å—åŒæ–‡ä»¶ä¸‹, ä½¿ç”¨ `#[cfg(test)]` è¿›è¡Œæ ‡æ³¨
        - åªæœ‰è¿è¡Œ `cargo test` æ‰ä¼šç¼–è¯‘è¿è¡Œä»£ç 
        - è¿è¡Œ `cargo build` ä¸ä¼šç¼–è¯‘/è¿è¡Œ ä»£ç 
    - æµ‹è¯•ç§æœ‰å‡½æ•°
        - å…è®¸ç›´æ¥è°ƒç”¨ç§æœ‰å‡½æ•°
- é›†æˆæµ‹è¯•
    - å’Œå¤–éƒ¨ä»£ç ä¸€æ ·è°ƒç”¨æ¨¡å—(å¯èƒ½ä½¿ç”¨åˆ°å¤šä¸ªæ¨¡å—)
    - åªèƒ½æµ‹è¯• `public` æ¥å£
    - `tests` ç›®å½•(ä¸ `src` å¹¶åˆ—)
        - ä¸éœ€è¦ `#[cfg(test)]` æ ‡æ³¨
        - åªä¼šåœ¨ä½¿ç”¨ `cargo test` æ—¶ç¼–è¯‘
        - æ¯ä¸€ä¸ªæ–‡ä»¶éƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„ `crate`
    - è¿è¡ŒæŒ‡å®šçš„é›†æˆæµ‹è¯•
        - è¿è¡Œç‰¹å®šçš„é›†æˆæµ‹è¯•: `cargo test name_of_test_fn`
        - è¿è¡ŒæŸä¸ªæµ‹è¯•æ–‡ä»¶å†…çš„æ‰€æœ‰æµ‹è¯•: `cargo test --test filename`
- é’ˆå¯¹ `binary crate` çš„é›†æˆæµ‹è¯•
    - å¦‚æœé¡¹ç›®æ˜¯ `binary crate`, åªå«æœ‰ `src/main.rs` è€Œæ²¡æœ‰ `src/lib.rs`
        - ä¸èƒ½åœ¨ `tests` ç›®å½•ä¸‹åˆ›å»ºé›†æˆæµ‹è¯•
        - æ— æ³•æŠŠ `main.rs` çš„å‡½æ•°å¯¼å…¥åˆ°ä½œç”¨åŸŸ
            - åªæœ‰ `library crate` æ‰èƒ½æš´éœ²å‡½æ•°ç»™å…¶ä»– `crate` ä½¿ç”¨
            - `binary crate` æ„å‘³ç€ç‹¬ç«‹è¿è¡Œ
- `#[cfg(condition)]`: `configuration`(é…ç½®)
    - åªæœ‰åœ¨æŒ‡å®šçš„é…ç½®æ¡ä»¶ä¸‹æ‰è¢«åŒ…å«

### é—­åŒ…ã€è¿­ä»£å™¨

> é—­åŒ… `closure`

- åŸºæœ¬
    - é—­åŒ…æ˜¯å¯ä»¥æ•è·å…¶æ‰€åœ¨ç¯å¢ƒçš„åŒ¿åå‡½æ•°
        - æ˜¯åŒ¿åå‡½æ•°
        - ä¿å­˜ä¸ºå˜é‡, ä½œä¸ºå‚æ•°ä½¿ç”¨
        - å¯ä»¥åœ¨ä¸€ä¸ªåœ°æ–¹åˆ›å»ºé—­åŒ…, åœ¨å¦ä¸€ä¸ªä¸Šä¸‹æ–‡ä¸­è°ƒç”¨é—­åŒ…æ¥å®Œæˆè¿ç®—
        - å¯ä»¥ä»å…¶å®šä¹‰çš„ä½œç”¨åŸŸæ•è·å€¼
    - ä¸è¦æ±‚æ ‡æ³¨å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹(ä¹Ÿå¯ä»¥æ‰‹åŠ¨æ ‡æ³¨)
    - é€šå¸¸å¾ˆçŸ­å°, åªåœ¨ç‹­å°çš„ä¸Šä¸‹æ–‡ä¸­å·¥ä½œ, ç¼–è¯‘å™¨ä¸€èˆ¬èƒ½å¤Ÿæ¨æ–­å…¶å‚æ•°å’Œè¿”å›ç±»å‹

```rust
fn closure_example() {
    let closure1 = |x1| x1 + 1;
    let closure2 = |x2| {
        println!("x2: {}", x2);
        x2 + 1
    };
    let closure3 = |x3: u32| -> u32 {
        println!("x3: {}", x3);
        x3 + 1
    };
}
```

- è®© `struct` æŒæœ‰é—­åŒ…
    - `Fn trait`: `Fn`, `FnMut`, `FnOnce`

```rust
struct Cacher<F>
    where F: Fn(u32) -> u32 {
    closure: F,
    value: Option<u32>
}

impl<T> Cacher<T>
    where T: Fn(u32) -> u32 {
    fn new() -> Self <T> {
        Self {
            closure: |x| x + 1,
            value: None,
        }
    }
    fn calculate(&mut self, arg: u32) {
        match self.value {
            Some(v) => v,
            None => {
                let v = self.closure(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

fn closure_in_struct_example() {}
```

- é—­åŒ…ä»æ‰€åœ¨ç¯å¢ƒæ•è·å€¼çš„æ–¹å¼
    - å–å¾—æ‰€æœ‰æƒ: `FnOnce`, æ‰€æœ‰é—­åŒ…éƒ½å®ç°äº† `FnOnce`
    - å¯å˜å€Ÿç”¨: `FnMut`, æ²¡æœ‰ç§»åŠ¨æ•è·å˜é‡çš„å®ç°äº† `FnMut`
    - ä¸å¯å˜å€Ÿç”¨: `Fn`, æ— éœ€å¯å˜è®¿é—®æ•è·å˜é‡çš„é—­åŒ…å®ç°äº† `Fn`
    - `move` å…³é”®å­—: åœ¨å‚æ•°åˆ—è¡¨å‰ä½¿ç”¨ `move` å…³é”®å­—, å¯ä»¥å¼ºåˆ¶é—­åŒ…å–å¾—å®ƒæ‰€ä½¿ç”¨çš„ç¯å¢ƒå€¼çš„æ‰€æœ‰æƒ

> è¿­ä»£å™¨ `iterator`

- **Rust** çš„è¿­ä»£å™¨: é™¤éè°ƒç”¨æ¶ˆè´¹è¿­ä»£å™¨çš„æ–¹æ³•, å¦åˆ™è¿­ä»£å™¨æœ¬èº«æ²¡æœ‰ä»»ä½•æ•ˆæœ
- `Iterator trait`
    - æ‰€æœ‰çš„è¿­ä»£å™¨éƒ½å®ç°äº† `Iterator trait`
    - `type Item` å’Œ `Self::Item` å®šä¹‰äº†ä¸æ­¤ `trait` å…³è”çš„ç±»å‹
    - `Iterator trait` ä»…è¦æ±‚å®ç°ä¸€ä¸ªæ–¹æ³• `next`
        - æ¯æ¬¡è¿”å›è¿­ä»£å™¨ä¸­çš„ä¸€é¡¹
        - è¿”å›ç»“æœåŒ…è£¹åœ¨ `Some` é‡Œ
        - è¿­ä»£ç»“æŸè¿”å› `None`
        - å¯ä»¥ç›´æ¥åœ¨è¿­ä»£å™¨ä¸Šè°ƒç”¨ `next` æ–¹æ³•
- è¿­ä»£æ–¹æ³•
    - `iter`: åœ¨ä¸å¯å˜å¼•ç”¨ä¸Šåˆ›å»ºè¿­ä»£å™¨
    - `into_iter`: åˆ›å»ºçš„è¿­ä»£å™¨ä¼šè·å¾—æ‰€æœ‰æƒ
    - `iter_mut`: è¿­ä»£å¯å˜çš„å¼•ç”¨
- æ¶ˆè€—è¿­ä»£å™¨çš„æ–¹æ³• (æ¶ˆè€—å‹é€‚é…å™¨)
    - ä¾‹: `sum` æ–¹æ³•, ä¼šå°†ç»“æœæ”¶å½•ä¸ºä¸€ä¸ªæ€»å’Œ
    - ä¾‹: `collect` æ–¹æ³•, ä¼šå°†ç»“æœæ”¶é›†åˆ°ä¸€ä¸ªé›†åˆç±»å‹ä¸­
- äº§ç”Ÿå…¶ä»–è¿­ä»£å™¨çš„æ–¹æ³• (è¿­ä»£å™¨é€‚é…å™¨)
    - ä¾‹: `map` æ–¹æ³•, ä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„è¿­ä»£å™¨
- ä½¿ç”¨é—­åŒ…æ•è·ç¯å¢ƒ
    - `filter` æ–¹æ³• (ç”¨æ³•åŒ`js` çš„ `filter`)
- è‡ªå®šä¹‰è¿­ä»£å™¨ (è§ `code example`)
- å¾ªç¯ vs è¿­ä»£å™¨
  - è¿­ä»£å™¨: é›¶æˆæœ¬æŠ½è±¡

```rust
// Iterator trait
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// è‡ªå®šä¹‰è¿­ä»£å™¨
struct Counter {
    count: u32,
    max: u32,
}

impl Counter {
    fn new(max: u32) -> Self {
        Self {
            count: 0,
            max
        }
    }
}

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        if self.count <= self.max {
            self.count += 1;
            Some(self.count - 1)
        } else {
            None
        }
    }
}
```